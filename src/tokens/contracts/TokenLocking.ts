/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace TokenLockingDataTypes {
  export type LockStruct = {
    lockCount: PromiseOrValue<BigNumberish>;
    balance: PromiseOrValue<BigNumberish>;
    DEPRECATED_timestamp: PromiseOrValue<BigNumberish>;
    pendingBalance: PromiseOrValue<BigNumberish>;
  };

  export type LockStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    lockCount: BigNumber;
    balance: BigNumber;
    DEPRECATED_timestamp: BigNumber;
    pendingBalance: BigNumber;
  };
}

export interface TokenLockingInterface extends utils.Interface {
  functions: {
    "authority()": FunctionFragment;
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getChainId()": FunctionFragment;
    "owner()": FunctionFragment;
    "setAuthority(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "verify(address,uint256,uint256,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getMetatransactionNonce(address)": FunctionFragment;
    "setColonyNetwork(address)": FunctionFragment;
    "getColonyNetwork()": FunctionFragment;
    "lockToken(address)": FunctionFragment;
    "unlockTokenForUser(address,address,uint256)": FunctionFragment;
    "incrementLockCounterTo(address,uint256)": FunctionFragment;
    "deposit(address,uint256,bool)": FunctionFragment;
    "deposit(address,uint256)": FunctionFragment;
    "depositFor(address,uint256,address)": FunctionFragment;
    "transfer(address,uint256,address,bool)": FunctionFragment;
    "withdraw(address,uint256,bool)": FunctionFragment;
    "withdraw(address,uint256)": FunctionFragment;
    "approveStake(address,uint256,address)": FunctionFragment;
    "obligateStake(address,uint256,address)": FunctionFragment;
    "deobligateStake(address,uint256,address)": FunctionFragment;
    "transferStake(address,uint256,address,address)": FunctionFragment;
    "reward(address,uint256)": FunctionFragment;
    "getTotalLockCount(address)": FunctionFragment;
    "getUserLock(address,address)": FunctionFragment;
    "getTotalObligation(address,address)": FunctionFragment;
    "getApproval(address,address,address)": FunctionFragment;
    "getObligation(address,address,address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "authority"
      | "executeMetaTransaction"
      | "getChainId"
      | "owner"
      | "setAuthority"
      | "setOwner"
      | "verify"
      | "getMetatransactionNonce"
      | "setColonyNetwork"
      | "getColonyNetwork"
      | "lockToken"
      | "unlockTokenForUser"
      | "incrementLockCounterTo"
      | "deposit(address,uint256,bool)"
      | "deposit(address,uint256)"
      | "depositFor"
      | "transfer"
      | "withdraw(address,uint256,bool)"
      | "withdraw(address,uint256)"
      | "approveStake"
      | "obligateStake"
      | "deobligateStake"
      | "transferStake"
      | "reward"
      | "getTotalLockCount"
      | "getUserLock"
      | "getTotalObligation"
      | "getApproval"
      | "getObligation"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getChainId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAuthority",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "verify",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetatransactionNonce",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setColonyNetwork",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getColonyNetwork",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "lockToken",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "unlockTokenForUser",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "incrementLockCounterTo",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit(address,uint256,bool)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit(address,uint256)",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "depositFor",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw(address,uint256,bool)",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw(address,uint256)",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "approveStake",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "obligateStake",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deobligateStake",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "transferStake",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "reward",
    values: [PromiseOrValue<string>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalLockCount",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserLock",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalObligation",
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproval",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getObligation",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string;

  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getChainId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "verify", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMetatransactionNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setColonyNetwork",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getColonyNetwork",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lockToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unlockTokenForUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "incrementLockCounterTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deposit(address,uint256,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deposit(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdraw(address,uint256,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdraw(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "obligateStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deobligateStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "reward", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getTotalLockCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserLock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalObligation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getObligation",
    data: BytesLike
  ): Result;

  events: {
    "ColonyNetworkSet(address)": EventFragment;
    "LogSetAuthority(address)": EventFragment;
    "LogSetOwner(address)": EventFragment;
    "MetaTransactionExecuted(address,address,bytes)": EventFragment;
    "StakeTransferred(address,address,address,address,uint256)": EventFragment;
    "TokenLocked(address,address,uint256)": EventFragment;
    "UserTokenApproved(address,address,address,uint256)": EventFragment;
    "UserTokenClaimed(address,address,uint256)": EventFragment;
    "UserTokenDeobligated(address,address,address,uint256)": EventFragment;
    "UserTokenDeposited(address,address,uint256)": EventFragment;
    "UserTokenObligated(address,address,address,uint256)": EventFragment;
    "UserTokenTransferred(address,address,address,uint256)": EventFragment;
    "UserTokenUnlocked(address,address,uint256)": EventFragment;
    "UserTokenWithdrawn(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ColonyNetworkSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenLocked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenApproved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenDeobligated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenDeposited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenObligated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenUnlocked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenWithdrawn"): EventFragment;
}

export interface ColonyNetworkSetEventObject {
  colonyNetwork: string;
}
export type ColonyNetworkSetEvent = TypedEvent<
  [string],
  ColonyNetworkSetEventObject
>;

export type ColonyNetworkSetEventFilter =
  TypedEventFilter<ColonyNetworkSetEvent>;

export interface LogSetAuthorityEventObject {
  authority: string;
}
export type LogSetAuthorityEvent = TypedEvent<
  [string],
  LogSetAuthorityEventObject
>;

export type LogSetAuthorityEventFilter = TypedEventFilter<LogSetAuthorityEvent>;

export interface LogSetOwnerEventObject {
  owner: string;
}
export type LogSetOwnerEvent = TypedEvent<[string], LogSetOwnerEventObject>;

export type LogSetOwnerEventFilter = TypedEventFilter<LogSetOwnerEvent>;

export interface MetaTransactionExecutedEventObject {
  user: string;
  relayerAddress: string;
  functionSignature: string;
}
export type MetaTransactionExecutedEvent = TypedEvent<
  [string, string, string],
  MetaTransactionExecutedEventObject
>;

export type MetaTransactionExecutedEventFilter =
  TypedEventFilter<MetaTransactionExecutedEvent>;

export interface StakeTransferredEventObject {
  token: string;
  by: string;
  from: string;
  to: string;
  amount: BigNumber;
}
export type StakeTransferredEvent = TypedEvent<
  [string, string, string, string, BigNumber],
  StakeTransferredEventObject
>;

export type StakeTransferredEventFilter =
  TypedEventFilter<StakeTransferredEvent>;

export interface TokenLockedEventObject {
  token: string;
  lockedBy: string;
  lockCount: BigNumber;
}
export type TokenLockedEvent = TypedEvent<
  [string, string, BigNumber],
  TokenLockedEventObject
>;

export type TokenLockedEventFilter = TypedEventFilter<TokenLockedEvent>;

export interface UserTokenApprovedEventObject {
  token: string;
  user: string;
  approvedBy: string;
  amount: BigNumber;
}
export type UserTokenApprovedEvent = TypedEvent<
  [string, string, string, BigNumber],
  UserTokenApprovedEventObject
>;

export type UserTokenApprovedEventFilter =
  TypedEventFilter<UserTokenApprovedEvent>;

export interface UserTokenClaimedEventObject {
  token: string;
  user: string;
  amount: BigNumber;
}
export type UserTokenClaimedEvent = TypedEvent<
  [string, string, BigNumber],
  UserTokenClaimedEventObject
>;

export type UserTokenClaimedEventFilter =
  TypedEventFilter<UserTokenClaimedEvent>;

export interface UserTokenDeobligatedEventObject {
  token: string;
  user: string;
  obligatedBy: string;
  amount: BigNumber;
}
export type UserTokenDeobligatedEvent = TypedEvent<
  [string, string, string, BigNumber],
  UserTokenDeobligatedEventObject
>;

export type UserTokenDeobligatedEventFilter =
  TypedEventFilter<UserTokenDeobligatedEvent>;

export interface UserTokenDepositedEventObject {
  token: string;
  user: string;
  amount: BigNumber;
}
export type UserTokenDepositedEvent = TypedEvent<
  [string, string, BigNumber],
  UserTokenDepositedEventObject
>;

export type UserTokenDepositedEventFilter =
  TypedEventFilter<UserTokenDepositedEvent>;

export interface UserTokenObligatedEventObject {
  token: string;
  user: string;
  obligatedBy: string;
  amount: BigNumber;
}
export type UserTokenObligatedEvent = TypedEvent<
  [string, string, string, BigNumber],
  UserTokenObligatedEventObject
>;

export type UserTokenObligatedEventFilter =
  TypedEventFilter<UserTokenObligatedEvent>;

export interface UserTokenTransferredEventObject {
  token: string;
  user: string;
  recipient: string;
  amount: BigNumber;
}
export type UserTokenTransferredEvent = TypedEvent<
  [string, string, string, BigNumber],
  UserTokenTransferredEventObject
>;

export type UserTokenTransferredEventFilter =
  TypedEventFilter<UserTokenTransferredEvent>;

export interface UserTokenUnlockedEventObject {
  token: string;
  user: string;
  lockId: BigNumber;
}
export type UserTokenUnlockedEvent = TypedEvent<
  [string, string, BigNumber],
  UserTokenUnlockedEventObject
>;

export type UserTokenUnlockedEventFilter =
  TypedEventFilter<UserTokenUnlockedEvent>;

export interface UserTokenWithdrawnEventObject {
  token: string;
  user: string;
  amount: BigNumber;
}
export type UserTokenWithdrawnEvent = TypedEvent<
  [string, string, BigNumber],
  UserTokenWithdrawnEventObject
>;

export type UserTokenWithdrawnEventFilter =
  TypedEventFilter<UserTokenWithdrawnEvent>;

export interface TokenLocking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TokenLockingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    authority(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getChainId(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getMetatransactionNonce(
      userAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    setColonyNetwork(
      _colonyNetwork: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getColonyNetwork(overrides?: CallOverrides): Promise<[string]>;

    lockToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    unlockTokenForUser(
      _token: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      _lockId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    incrementLockCounterTo(
      _token: PromiseOrValue<string>,
      _lockId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "deposit(address,uint256,bool)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _force: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "deposit(address,uint256)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    depositFor(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transfer(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      _force: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "withdraw(address,uint256,bool)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _force: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    "withdraw(address,uint256)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    approveStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    obligateStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    deobligateStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    transferStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    reward(
      _recipient: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[void]>;

    getTotalLockCount(
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getUserLock(
      _token: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<
      [TokenLockingDataTypes.LockStructOutput] & {
        lock: TokenLockingDataTypes.LockStructOutput;
      }
    >;

    getTotalObligation(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getApproval(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _obligator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getObligation(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _obligator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;
  };

  authority(overrides?: CallOverrides): Promise<string>;

  /**
   * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
   * @param _payload Function call to make via meta transaction
   * @param _sigR R part of the signature
   * @param _sigS S part of the signature
   * @param _sigV V part of the signature
   * @param _user Address of user trying to do meta transaction
   */
  executeMetaTransaction(
    _user: PromiseOrValue<string>,
    _payload: PromiseOrValue<BytesLike>,
    _sigR: PromiseOrValue<BytesLike>,
    _sigS: PromiseOrValue<BytesLike>,
    _sigV: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getChainId(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  setAuthority(
    authority_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    owner_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  verify(
    _owner: PromiseOrValue<string>,
    _nonce: PromiseOrValue<BigNumberish>,
    _chainId: PromiseOrValue<BigNumberish>,
    _payload: PromiseOrValue<BytesLike>,
    _sigR: PromiseOrValue<BytesLike>,
    _sigS: PromiseOrValue<BytesLike>,
    _sigV: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getMetatransactionNonce(
    userAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  setColonyNetwork(
    _colonyNetwork: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getColonyNetwork(overrides?: CallOverrides): Promise<string>;

  lockToken(
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  unlockTokenForUser(
    _token: PromiseOrValue<string>,
    _user: PromiseOrValue<string>,
    _lockId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  incrementLockCounterTo(
    _token: PromiseOrValue<string>,
    _lockId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "deposit(address,uint256,bool)"(
    _token: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _force: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "deposit(address,uint256)"(
    _token: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  depositFor(
    _token: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _recipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transfer(
    _token: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _recipient: PromiseOrValue<string>,
    _force: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "withdraw(address,uint256,bool)"(
    _token: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _force: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  "withdraw(address,uint256)"(
    _token: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  approveStake(
    _user: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  obligateStake(
    _user: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  deobligateStake(
    _user: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  transferStake(
    _user: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    _token: PromiseOrValue<string>,
    _recipient: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  reward(
    _recipient: PromiseOrValue<string>,
    _amount: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<void>;

  getTotalLockCount(
    _token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getUserLock(
    _token: PromiseOrValue<string>,
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<TokenLockingDataTypes.LockStructOutput>;

  getTotalObligation(
    _user: PromiseOrValue<string>,
    _token: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getApproval(
    _user: PromiseOrValue<string>,
    _token: PromiseOrValue<string>,
    _obligator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getObligation(
    _user: PromiseOrValue<string>,
    _token: PromiseOrValue<string>,
    _obligator: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    authority(overrides?: CallOverrides): Promise<string>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getMetatransactionNonce(
      userAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setColonyNetwork(
      _colonyNetwork: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    getColonyNetwork(overrides?: CallOverrides): Promise<string>;

    lockToken(
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    unlockTokenForUser(
      _token: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      _lockId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    incrementLockCounterTo(
      _token: PromiseOrValue<string>,
      _lockId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    "deposit(address,uint256,bool)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _force: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    "deposit(address,uint256)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    depositFor(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    transfer(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      _force: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    "withdraw(address,uint256,bool)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _force: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    "withdraw(address,uint256)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    approveStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    obligateStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    deobligateStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    transferStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    reward(
      _recipient: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getTotalLockCount(
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserLock(
      _token: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<TokenLockingDataTypes.LockStructOutput>;

    getTotalObligation(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getApproval(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _obligator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getObligation(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _obligator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "ColonyNetworkSet(address)"(
      colonyNetwork?: null
    ): ColonyNetworkSetEventFilter;
    ColonyNetworkSet(colonyNetwork?: null): ColonyNetworkSetEventFilter;

    "LogSetAuthority(address)"(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;
    LogSetAuthority(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;

    "LogSetOwner(address)"(
      owner?: PromiseOrValue<string> | null
    ): LogSetOwnerEventFilter;
    LogSetOwner(owner?: PromiseOrValue<string> | null): LogSetOwnerEventFilter;

    "MetaTransactionExecuted(address,address,bytes)"(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;
    MetaTransactionExecuted(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;

    "StakeTransferred(address,address,address,address,uint256)"(
      token?: null,
      by?: null,
      from?: null,
      to?: null,
      amount?: null
    ): StakeTransferredEventFilter;
    StakeTransferred(
      token?: null,
      by?: null,
      from?: null,
      to?: null,
      amount?: null
    ): StakeTransferredEventFilter;

    "TokenLocked(address,address,uint256)"(
      token?: PromiseOrValue<string> | null,
      lockedBy?: PromiseOrValue<string> | null,
      lockCount?: null
    ): TokenLockedEventFilter;
    TokenLocked(
      token?: PromiseOrValue<string> | null,
      lockedBy?: PromiseOrValue<string> | null,
      lockCount?: null
    ): TokenLockedEventFilter;

    "UserTokenApproved(address,address,address,uint256)"(
      token?: null,
      user?: null,
      approvedBy?: null,
      amount?: null
    ): UserTokenApprovedEventFilter;
    UserTokenApproved(
      token?: null,
      user?: null,
      approvedBy?: null,
      amount?: null
    ): UserTokenApprovedEventFilter;

    "UserTokenClaimed(address,address,uint256)"(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenClaimedEventFilter;
    UserTokenClaimed(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenClaimedEventFilter;

    "UserTokenDeobligated(address,address,address,uint256)"(
      token?: null,
      user?: null,
      obligatedBy?: null,
      amount?: null
    ): UserTokenDeobligatedEventFilter;
    UserTokenDeobligated(
      token?: null,
      user?: null,
      obligatedBy?: null,
      amount?: null
    ): UserTokenDeobligatedEventFilter;

    "UserTokenDeposited(address,address,uint256)"(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenDepositedEventFilter;
    UserTokenDeposited(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenDepositedEventFilter;

    "UserTokenObligated(address,address,address,uint256)"(
      token?: null,
      user?: null,
      obligatedBy?: null,
      amount?: null
    ): UserTokenObligatedEventFilter;
    UserTokenObligated(
      token?: null,
      user?: null,
      obligatedBy?: null,
      amount?: null
    ): UserTokenObligatedEventFilter;

    "UserTokenTransferred(address,address,address,uint256)"(
      token?: null,
      user?: null,
      recipient?: null,
      amount?: null
    ): UserTokenTransferredEventFilter;
    UserTokenTransferred(
      token?: null,
      user?: null,
      recipient?: null,
      amount?: null
    ): UserTokenTransferredEventFilter;

    "UserTokenUnlocked(address,address,uint256)"(
      token?: null,
      user?: null,
      lockId?: null
    ): UserTokenUnlockedEventFilter;
    UserTokenUnlocked(
      token?: null,
      user?: null,
      lockId?: null
    ): UserTokenUnlockedEventFilter;

    "UserTokenWithdrawn(address,address,uint256)"(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenWithdrawnEventFilter;
    UserTokenWithdrawn(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenWithdrawnEventFilter;
  };

  estimateGas: {
    authority(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMetatransactionNonce(
      userAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setColonyNetwork(
      _colonyNetwork: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getColonyNetwork(overrides?: CallOverrides): Promise<BigNumber>;

    lockToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    unlockTokenForUser(
      _token: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      _lockId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    incrementLockCounterTo(
      _token: PromiseOrValue<string>,
      _lockId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "deposit(address,uint256,bool)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _force: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "deposit(address,uint256)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    depositFor(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transfer(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      _force: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "withdraw(address,uint256,bool)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _force: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    "withdraw(address,uint256)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    approveStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    obligateStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    deobligateStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    transferStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    reward(
      _recipient: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalLockCount(
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserLock(
      _token: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalObligation(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getApproval(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _obligator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getObligation(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _obligator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMetatransactionNonce(
      userAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setColonyNetwork(
      _colonyNetwork: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getColonyNetwork(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockToken(
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    unlockTokenForUser(
      _token: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      _lockId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    incrementLockCounterTo(
      _token: PromiseOrValue<string>,
      _lockId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "deposit(address,uint256,bool)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _force: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "deposit(address,uint256)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    depositFor(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transfer(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _recipient: PromiseOrValue<string>,
      _force: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "withdraw(address,uint256,bool)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _force: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    "withdraw(address,uint256)"(
      _token: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    approveStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    obligateStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    deobligateStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    transferStake(
      _user: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      _recipient: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    reward(
      _recipient: PromiseOrValue<string>,
      _amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalLockCount(
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserLock(
      _token: PromiseOrValue<string>,
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalObligation(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getApproval(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _obligator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getObligation(
      _user: PromiseOrValue<string>,
      _token: PromiseOrValue<string>,
      _obligator: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
