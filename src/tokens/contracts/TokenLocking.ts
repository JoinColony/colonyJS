/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace TokenLockingDataTypes {
  export type LockStruct = {
    lockCount: BigNumberish;
    balance: BigNumberish;
    DEPRECATED_timestamp: BigNumberish;
    pendingBalance: BigNumberish;
  };

  export type LockStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    lockCount: BigNumber;
    balance: BigNumber;
    DEPRECATED_timestamp: BigNumber;
    pendingBalance: BigNumber;
  };
}

export interface TokenLockingInterface extends utils.Interface {
  functions: {
    "authority()": FunctionFragment;
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getChainId()": FunctionFragment;
    "owner()": FunctionFragment;
    "setAuthority(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "verify(address,uint256,uint256,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getMetatransactionNonce(address)": FunctionFragment;
    "setColonyNetwork(address)": FunctionFragment;
    "getColonyNetwork()": FunctionFragment;
    "lockToken(address)": FunctionFragment;
    "unlockTokenForUser(address,address,uint256)": FunctionFragment;
    "incrementLockCounterTo(address,uint256)": FunctionFragment;
    "deposit(address,uint256,bool)": FunctionFragment;
    "deposit(address,uint256)": FunctionFragment;
    "depositFor(address,uint256,address)": FunctionFragment;
    "transfer(address,uint256,address,bool)": FunctionFragment;
    "withdraw(address,uint256,bool)": FunctionFragment;
    "withdraw(address,uint256)": FunctionFragment;
    "approveStake(address,uint256,address)": FunctionFragment;
    "obligateStake(address,uint256,address)": FunctionFragment;
    "deobligateStake(address,uint256,address)": FunctionFragment;
    "transferStake(address,uint256,address,address)": FunctionFragment;
    "reward(address,uint256)": FunctionFragment;
    "getTotalLockCount(address)": FunctionFragment;
    "getUserLock(address,address)": FunctionFragment;
    "getTotalObligation(address,address)": FunctionFragment;
    "getApproval(address,address,address)": FunctionFragment;
    "getObligation(address,address,address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "authority"
      | "executeMetaTransaction"
      | "getChainId"
      | "owner"
      | "setAuthority"
      | "setOwner"
      | "verify"
      | "getMetatransactionNonce"
      | "setColonyNetwork"
      | "getColonyNetwork"
      | "lockToken"
      | "unlockTokenForUser"
      | "incrementLockCounterTo"
      | "deposit(address,uint256,bool)"
      | "deposit(address,uint256)"
      | "depositFor"
      | "transfer"
      | "withdraw(address,uint256,bool)"
      | "withdraw(address,uint256)"
      | "approveStake"
      | "obligateStake"
      | "deobligateStake"
      | "transferStake"
      | "reward"
      | "getTotalLockCount"
      | "getUserLock"
      | "getTotalObligation"
      | "getApproval"
      | "getObligation"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [string, BytesLike, BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getChainId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAuthority",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "setOwner", values: [string]): string;
  encodeFunctionData(
    functionFragment: "verify",
    values: [
      string,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike,
      BytesLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetatransactionNonce",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setColonyNetwork",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getColonyNetwork",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "lockToken", values: [string]): string;
  encodeFunctionData(
    functionFragment: "unlockTokenForUser",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "incrementLockCounterTo",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit(address,uint256,bool)",
    values: [string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "deposit(address,uint256)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "depositFor",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "transfer",
    values: [string, BigNumberish, string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw(address,uint256,bool)",
    values: [string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "withdraw(address,uint256)",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "approveStake",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "obligateStake",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "deobligateStake",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "transferStake",
    values: [string, BigNumberish, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "reward",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalLockCount",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserLock",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalObligation",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproval",
    values: [string, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getObligation",
    values: [string, string, string]
  ): string;

  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getChainId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "verify", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMetatransactionNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setColonyNetwork",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getColonyNetwork",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lockToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unlockTokenForUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "incrementLockCounterTo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deposit(address,uint256,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deposit(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "depositFor", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "transfer", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "withdraw(address,uint256,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "withdraw(address,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "obligateStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deobligateStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "reward", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getTotalLockCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserLock",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalObligation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getObligation",
    data: BytesLike
  ): Result;

  events: {
    "ColonyNetworkSet(address)": EventFragment;
    "LogSetAuthority(address)": EventFragment;
    "LogSetOwner(address)": EventFragment;
    "MetaTransactionExecuted(address,address,bytes)": EventFragment;
    "StakeTransferred(address,address,address,address,uint256)": EventFragment;
    "TokenLocked(address,address,uint256)": EventFragment;
    "UserTokenApproved(address,address,address,uint256)": EventFragment;
    "UserTokenClaimed(address,address,uint256)": EventFragment;
    "UserTokenDeobligated(address,address,address,uint256)": EventFragment;
    "UserTokenDeposited(address,address,uint256)": EventFragment;
    "UserTokenObligated(address,address,address,uint256)": EventFragment;
    "UserTokenTransferred(address,address,address,uint256)": EventFragment;
    "UserTokenUnlocked(address,address,uint256)": EventFragment;
    "UserTokenWithdrawn(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ColonyNetworkSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenLocked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenApproved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenDeobligated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenDeposited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenObligated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenUnlocked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserTokenWithdrawn"): EventFragment;
}

export interface ColonyNetworkSetEventObject {
  colonyNetwork: string;
}
export type ColonyNetworkSetEvent = TypedEvent<
  [string],
  ColonyNetworkSetEventObject
>;

export type ColonyNetworkSetEventFilter =
  TypedEventFilter<ColonyNetworkSetEvent>;

export interface LogSetAuthorityEventObject {
  authority: string;
}
export type LogSetAuthorityEvent = TypedEvent<
  [string],
  LogSetAuthorityEventObject
>;

export type LogSetAuthorityEventFilter = TypedEventFilter<LogSetAuthorityEvent>;

export interface LogSetOwnerEventObject {
  owner: string;
}
export type LogSetOwnerEvent = TypedEvent<[string], LogSetOwnerEventObject>;

export type LogSetOwnerEventFilter = TypedEventFilter<LogSetOwnerEvent>;

export interface MetaTransactionExecutedEventObject {
  user: string;
  relayerAddress: string;
  functionSignature: string;
}
export type MetaTransactionExecutedEvent = TypedEvent<
  [string, string, string],
  MetaTransactionExecutedEventObject
>;

export type MetaTransactionExecutedEventFilter =
  TypedEventFilter<MetaTransactionExecutedEvent>;

export interface StakeTransferredEventObject {
  token: string;
  by: string;
  from: string;
  to: string;
  amount: BigNumber;
}
export type StakeTransferredEvent = TypedEvent<
  [string, string, string, string, BigNumber],
  StakeTransferredEventObject
>;

export type StakeTransferredEventFilter =
  TypedEventFilter<StakeTransferredEvent>;

export interface TokenLockedEventObject {
  token: string;
  lockedBy: string;
  lockCount: BigNumber;
}
export type TokenLockedEvent = TypedEvent<
  [string, string, BigNumber],
  TokenLockedEventObject
>;

export type TokenLockedEventFilter = TypedEventFilter<TokenLockedEvent>;

export interface UserTokenApprovedEventObject {
  token: string;
  user: string;
  approvedBy: string;
  amount: BigNumber;
}
export type UserTokenApprovedEvent = TypedEvent<
  [string, string, string, BigNumber],
  UserTokenApprovedEventObject
>;

export type UserTokenApprovedEventFilter =
  TypedEventFilter<UserTokenApprovedEvent>;

export interface UserTokenClaimedEventObject {
  token: string;
  user: string;
  amount: BigNumber;
}
export type UserTokenClaimedEvent = TypedEvent<
  [string, string, BigNumber],
  UserTokenClaimedEventObject
>;

export type UserTokenClaimedEventFilter =
  TypedEventFilter<UserTokenClaimedEvent>;

export interface UserTokenDeobligatedEventObject {
  token: string;
  user: string;
  obligatedBy: string;
  amount: BigNumber;
}
export type UserTokenDeobligatedEvent = TypedEvent<
  [string, string, string, BigNumber],
  UserTokenDeobligatedEventObject
>;

export type UserTokenDeobligatedEventFilter =
  TypedEventFilter<UserTokenDeobligatedEvent>;

export interface UserTokenDepositedEventObject {
  token: string;
  user: string;
  amount: BigNumber;
}
export type UserTokenDepositedEvent = TypedEvent<
  [string, string, BigNumber],
  UserTokenDepositedEventObject
>;

export type UserTokenDepositedEventFilter =
  TypedEventFilter<UserTokenDepositedEvent>;

export interface UserTokenObligatedEventObject {
  token: string;
  user: string;
  obligatedBy: string;
  amount: BigNumber;
}
export type UserTokenObligatedEvent = TypedEvent<
  [string, string, string, BigNumber],
  UserTokenObligatedEventObject
>;

export type UserTokenObligatedEventFilter =
  TypedEventFilter<UserTokenObligatedEvent>;

export interface UserTokenTransferredEventObject {
  token: string;
  user: string;
  recipient: string;
  amount: BigNumber;
}
export type UserTokenTransferredEvent = TypedEvent<
  [string, string, string, BigNumber],
  UserTokenTransferredEventObject
>;

export type UserTokenTransferredEventFilter =
  TypedEventFilter<UserTokenTransferredEvent>;

export interface UserTokenUnlockedEventObject {
  token: string;
  user: string;
  lockId: BigNumber;
}
export type UserTokenUnlockedEvent = TypedEvent<
  [string, string, BigNumber],
  UserTokenUnlockedEventObject
>;

export type UserTokenUnlockedEventFilter =
  TypedEventFilter<UserTokenUnlockedEvent>;

export interface UserTokenWithdrawnEventObject {
  token: string;
  user: string;
  amount: BigNumber;
}
export type UserTokenWithdrawnEvent = TypedEvent<
  [string, string, BigNumber],
  UserTokenWithdrawnEventObject
>;

export type UserTokenWithdrawnEventFilter =
  TypedEventFilter<UserTokenWithdrawnEvent>;

export interface TokenLocking extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: TokenLockingInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    authority(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    getChainId(overrides?: CallOverrides): Promise<[BigNumber]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    setColonyNetwork(
      _colonyNetwork: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    getColonyNetwork(overrides?: CallOverrides): Promise<[string]>;

    lockToken(
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    unlockTokenForUser(
      _token: string,
      _user: string,
      _lockId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    incrementLockCounterTo(
      _token: string,
      _lockId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    "deposit(address,uint256,bool)"(
      _token: string,
      _amount: BigNumberish,
      _force: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    "deposit(address,uint256)"(
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    depositFor(
      _token: string,
      _amount: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    transfer(
      _token: string,
      _amount: BigNumberish,
      _recipient: string,
      _force: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    "withdraw(address,uint256,bool)"(
      _token: string,
      _amount: BigNumberish,
      _force: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    "withdraw(address,uint256)"(
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    approveStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    obligateStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    deobligateStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    transferStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      _recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    getTotalLockCount(
      _token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getUserLock(
      _token: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<
      [TokenLockingDataTypes.LockStructOutput] & {
        lock: TokenLockingDataTypes.LockStructOutput;
      }
    >;

    getTotalObligation(
      _user: string,
      _token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getApproval(
      _user: string,
      _token: string,
      _obligator: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;

    getObligation(
      _user: string,
      _token: string,
      _obligator: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;
  };

  authority(overrides?: CallOverrides): Promise<string>;

  /**
   * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
   * @param _payload Function call to make via meta transaction
   * @param _sigR R part of the signature
   * @param _sigS S part of the signature
   * @param _sigV V part of the signature
   * @param _user Address of user trying to do meta transaction
   */
  executeMetaTransaction(
    _user: string,
    _payload: BytesLike,
    _sigR: BytesLike,
    _sigS: BytesLike,
    _sigV: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  getChainId(overrides?: CallOverrides): Promise<BigNumber>;

  owner(overrides?: CallOverrides): Promise<string>;

  setAuthority(
    authority_: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setOwner(
    owner_: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  verify(
    _owner: string,
    _nonce: BigNumberish,
    _chainId: BigNumberish,
    _payload: BytesLike,
    _sigR: BytesLike,
    _sigS: BytesLike,
    _sigV: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  getMetatransactionNonce(
    userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  setColonyNetwork(
    _colonyNetwork: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  getColonyNetwork(overrides?: CallOverrides): Promise<string>;

  lockToken(
    _token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  unlockTokenForUser(
    _token: string,
    _user: string,
    _lockId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  incrementLockCounterTo(
    _token: string,
    _lockId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  "deposit(address,uint256,bool)"(
    _token: string,
    _amount: BigNumberish,
    _force: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  "deposit(address,uint256)"(
    _token: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  depositFor(
    _token: string,
    _amount: BigNumberish,
    _recipient: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  transfer(
    _token: string,
    _amount: BigNumberish,
    _recipient: string,
    _force: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  "withdraw(address,uint256,bool)"(
    _token: string,
    _amount: BigNumberish,
    _force: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  "withdraw(address,uint256)"(
    _token: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  approveStake(
    _user: string,
    _amount: BigNumberish,
    _token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  obligateStake(
    _user: string,
    _amount: BigNumberish,
    _token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  deobligateStake(
    _user: string,
    _amount: BigNumberish,
    _token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  transferStake(
    _user: string,
    _amount: BigNumberish,
    _token: string,
    _recipient: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  reward(
    _recipient: string,
    _amount: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  getTotalLockCount(
    _token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getUserLock(
    _token: string,
    _user: string,
    overrides?: CallOverrides
  ): Promise<TokenLockingDataTypes.LockStructOutput>;

  getTotalObligation(
    _user: string,
    _token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getApproval(
    _user: string,
    _token: string,
    _obligator: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  getObligation(
    _user: string,
    _token: string,
    _obligator: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    authority(overrides?: CallOverrides): Promise<string>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<string>;

    setAuthority(authority_: string, overrides?: CallOverrides): Promise<void>;

    setOwner(owner_: string, overrides?: CallOverrides): Promise<void>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setColonyNetwork(
      _colonyNetwork: string,
      overrides?: CallOverrides
    ): Promise<void>;

    getColonyNetwork(overrides?: CallOverrides): Promise<string>;

    lockToken(_token: string, overrides?: CallOverrides): Promise<BigNumber>;

    unlockTokenForUser(
      _token: string,
      _user: string,
      _lockId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    incrementLockCounterTo(
      _token: string,
      _lockId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    "deposit(address,uint256,bool)"(
      _token: string,
      _amount: BigNumberish,
      _force: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    "deposit(address,uint256)"(
      _token: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    depositFor(
      _token: string,
      _amount: BigNumberish,
      _recipient: string,
      overrides?: CallOverrides
    ): Promise<void>;

    transfer(
      _token: string,
      _amount: BigNumberish,
      _recipient: string,
      _force: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    "withdraw(address,uint256,bool)"(
      _token: string,
      _amount: BigNumberish,
      _force: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    "withdraw(address,uint256)"(
      _token: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    approveStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    obligateStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    deobligateStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    transferStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      _recipient: string,
      overrides?: CallOverrides
    ): Promise<void>;

    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    getTotalLockCount(
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserLock(
      _token: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<TokenLockingDataTypes.LockStructOutput>;

    getTotalObligation(
      _user: string,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getApproval(
      _user: string,
      _token: string,
      _obligator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getObligation(
      _user: string,
      _token: string,
      _obligator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "ColonyNetworkSet(address)"(
      colonyNetwork?: null
    ): ColonyNetworkSetEventFilter;
    ColonyNetworkSet(colonyNetwork?: null): ColonyNetworkSetEventFilter;

    "LogSetAuthority(address)"(
      authority?: string | null
    ): LogSetAuthorityEventFilter;
    LogSetAuthority(authority?: string | null): LogSetAuthorityEventFilter;

    "LogSetOwner(address)"(owner?: string | null): LogSetOwnerEventFilter;
    LogSetOwner(owner?: string | null): LogSetOwnerEventFilter;

    "MetaTransactionExecuted(address,address,bytes)"(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;
    MetaTransactionExecuted(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;

    "StakeTransferred(address,address,address,address,uint256)"(
      token?: null,
      by?: null,
      from?: null,
      to?: null,
      amount?: null
    ): StakeTransferredEventFilter;
    StakeTransferred(
      token?: null,
      by?: null,
      from?: null,
      to?: null,
      amount?: null
    ): StakeTransferredEventFilter;

    "TokenLocked(address,address,uint256)"(
      token?: string | null,
      lockedBy?: string | null,
      lockCount?: null
    ): TokenLockedEventFilter;
    TokenLocked(
      token?: string | null,
      lockedBy?: string | null,
      lockCount?: null
    ): TokenLockedEventFilter;

    "UserTokenApproved(address,address,address,uint256)"(
      token?: null,
      user?: null,
      approvedBy?: null,
      amount?: null
    ): UserTokenApprovedEventFilter;
    UserTokenApproved(
      token?: null,
      user?: null,
      approvedBy?: null,
      amount?: null
    ): UserTokenApprovedEventFilter;

    "UserTokenClaimed(address,address,uint256)"(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenClaimedEventFilter;
    UserTokenClaimed(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenClaimedEventFilter;

    "UserTokenDeobligated(address,address,address,uint256)"(
      token?: null,
      user?: null,
      obligatedBy?: null,
      amount?: null
    ): UserTokenDeobligatedEventFilter;
    UserTokenDeobligated(
      token?: null,
      user?: null,
      obligatedBy?: null,
      amount?: null
    ): UserTokenDeobligatedEventFilter;

    "UserTokenDeposited(address,address,uint256)"(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenDepositedEventFilter;
    UserTokenDeposited(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenDepositedEventFilter;

    "UserTokenObligated(address,address,address,uint256)"(
      token?: null,
      user?: null,
      obligatedBy?: null,
      amount?: null
    ): UserTokenObligatedEventFilter;
    UserTokenObligated(
      token?: null,
      user?: null,
      obligatedBy?: null,
      amount?: null
    ): UserTokenObligatedEventFilter;

    "UserTokenTransferred(address,address,address,uint256)"(
      token?: null,
      user?: null,
      recipient?: null,
      amount?: null
    ): UserTokenTransferredEventFilter;
    UserTokenTransferred(
      token?: null,
      user?: null,
      recipient?: null,
      amount?: null
    ): UserTokenTransferredEventFilter;

    "UserTokenUnlocked(address,address,uint256)"(
      token?: null,
      user?: null,
      lockId?: null
    ): UserTokenUnlockedEventFilter;
    UserTokenUnlocked(
      token?: null,
      user?: null,
      lockId?: null
    ): UserTokenUnlockedEventFilter;

    "UserTokenWithdrawn(address,address,uint256)"(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenWithdrawnEventFilter;
    UserTokenWithdrawn(
      token?: null,
      user?: null,
      amount?: null
    ): UserTokenWithdrawnEventFilter;
  };

  estimateGas: {
    authority(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    setColonyNetwork(
      _colonyNetwork: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    getColonyNetwork(overrides?: CallOverrides): Promise<BigNumber>;

    lockToken(
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    unlockTokenForUser(
      _token: string,
      _user: string,
      _lockId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    incrementLockCounterTo(
      _token: string,
      _lockId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    "deposit(address,uint256,bool)"(
      _token: string,
      _amount: BigNumberish,
      _force: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    "deposit(address,uint256)"(
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    depositFor(
      _token: string,
      _amount: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    transfer(
      _token: string,
      _amount: BigNumberish,
      _recipient: string,
      _force: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    "withdraw(address,uint256,bool)"(
      _token: string,
      _amount: BigNumberish,
      _force: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    "withdraw(address,uint256)"(
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    approveStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    obligateStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    deobligateStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    transferStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      _recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalLockCount(
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getUserLock(
      _token: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTotalObligation(
      _user: string,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getApproval(
      _user: string,
      _token: string,
      _obligator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getObligation(
      _user: string,
      _token: string,
      _obligator: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    setColonyNetwork(
      _colonyNetwork: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getColonyNetwork(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    lockToken(
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    unlockTokenForUser(
      _token: string,
      _user: string,
      _lockId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    incrementLockCounterTo(
      _token: string,
      _lockId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    "deposit(address,uint256,bool)"(
      _token: string,
      _amount: BigNumberish,
      _force: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    "deposit(address,uint256)"(
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    depositFor(
      _token: string,
      _amount: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    transfer(
      _token: string,
      _amount: BigNumberish,
      _recipient: string,
      _force: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    "withdraw(address,uint256,bool)"(
      _token: string,
      _amount: BigNumberish,
      _force: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    "withdraw(address,uint256)"(
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    approveStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    obligateStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    deobligateStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    transferStake(
      _user: string,
      _amount: BigNumberish,
      _token: string,
      _recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalLockCount(
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getUserLock(
      _token: string,
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalObligation(
      _user: string,
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getApproval(
      _user: string,
      _token: string,
      _obligator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getObligation(
      _user: string,
      _token: string,
      _obligator: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
