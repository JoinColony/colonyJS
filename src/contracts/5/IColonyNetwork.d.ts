/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface IColonyNetworkInterface extends Interface {
  functions: {
    approveExitRecovery: TypedFunctionDescription<{ encode([]: []): string }>;

    checkNotAdditionalProtectedVariable: TypedFunctionDescription<{
      encode([_slot]: [BigNumberish]): string;
    }>;

    enterRecoveryMode: TypedFunctionDescription<{ encode([]: []): string }>;

    exitRecoveryMode: TypedFunctionDescription<{ encode([]: []): string }>;

    isInRecoveryMode: TypedFunctionDescription<{ encode([]: []): string }>;

    numRecoveryRoles: TypedFunctionDescription<{ encode([]: []): string }>;

    removeRecoveryRole: TypedFunctionDescription<{
      encode([_user]: [string]): string;
    }>;

    setRecoveryRole: TypedFunctionDescription<{
      encode([_user]: [string]): string;
    }>;

    setStorageSlotRecovery: TypedFunctionDescription<{
      encode([_slot, _value]: [BigNumberish, Arrayish]): string;
    }>;

    supportsInterface: TypedFunctionDescription<{
      encode([interfaceID]: [Arrayish]): string;
    }>;

    setReplacementReputationUpdateLogEntry: TypedFunctionDescription<{
      encode([
        _reputationMiningCycle,
        _id,
        _user,
        _amount,
        _skillId,
        _colony,
        _nUpdates,
        _nPreviousUpdates
      ]: [
        string,
        BigNumberish,
        string,
        BigNumberish,
        BigNumberish,
        string,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getReplacementReputationUpdateLogEntry: TypedFunctionDescription<{
      encode([_reputationMiningCycle, _id]: [string, BigNumberish]): string;
    }>;

    getReplacementReputationUpdateLogsExist: TypedFunctionDescription<{
      encode([_reputationMiningCycle]: [string]): string;
    }>;

    getMetaColony: TypedFunctionDescription<{ encode([]: []): string }>;

    getColonyCount: TypedFunctionDescription<{ encode([]: []): string }>;

    isColony: TypedFunctionDescription<{ encode([_colony]: [string]): string }>;

    addSkill: TypedFunctionDescription<{
      encode([_parentSkillId]: [BigNumberish]): string;
    }>;

    getSkill: TypedFunctionDescription<{
      encode([_skillId]: [BigNumberish]): string;
    }>;

    deprecateSkill: TypedFunctionDescription<{
      encode([_skillId]: [BigNumberish]): string;
    }>;

    appendReputationUpdateLog: TypedFunctionDescription<{
      encode([_user, _amount, _skillId]: [
        string,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getSkillCount: TypedFunctionDescription<{ encode([]: []): string }>;

    getReputationMiningSkillId: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    setTokenLocking: TypedFunctionDescription<{
      encode([_tokenLockingAddress]: [string]): string;
    }>;

    getTokenLocking: TypedFunctionDescription<{ encode([]: []): string }>;

    createMetaColony: TypedFunctionDescription<{
      encode([_tokenAddress]: [string]): string;
    }>;

    createColony: TypedFunctionDescription<{
      encode([_tokenAddress]: [string]): string;
    }>;

    addColonyVersion: TypedFunctionDescription<{
      encode([_version, _resolver]: [BigNumberish, string]): string;
    }>;

    initialise: TypedFunctionDescription<{
      encode([_resolver, _version]: [string, BigNumberish]): string;
    }>;

    getColony: TypedFunctionDescription<{
      encode([_id]: [BigNumberish]): string;
    }>;

    getCurrentColonyVersion: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getParentSkillId: TypedFunctionDescription<{
      encode([_skillId, _parentSkillIndex]: [
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getChildSkillId: TypedFunctionDescription<{
      encode([_skillId, _childSkillIndex]: [
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getReputationMiningCycle: TypedFunctionDescription<{
      encode([_active]: [boolean]): string;
    }>;

    calculateMinerWeight: TypedFunctionDescription<{
      encode([_timeStaked, _submissonIndex]: [
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getColonyVersionResolver: TypedFunctionDescription<{
      encode([_version]: [BigNumberish]): string;
    }>;

    setReputationRootHash: TypedFunctionDescription<{
      encode([newHash, newNLeaves, stakers]: [
        Arrayish,
        BigNumberish,
        string[]
      ]): string;
    }>;

    startNextCycle: TypedFunctionDescription<{ encode([]: []): string }>;

    initialiseReputationMining: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getReputationRootHash: TypedFunctionDescription<{ encode([]: []): string }>;

    getReputationRootHashNLeaves: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getReputationRootHashNNodes: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    startTokenAuction: TypedFunctionDescription<{
      encode([_token]: [string]): string;
    }>;

    setupRegistrar: TypedFunctionDescription<{
      encode([_ens, _rootNode]: [string, Arrayish]): string;
    }>;

    registerUserLabel: TypedFunctionDescription<{
      encode([username, orbitdb]: [string, string]): string;
    }>;

    registerColonyLabel: TypedFunctionDescription<{
      encode([colonyName, orbitdb]: [string, string]): string;
    }>;

    updateColonyOrbitDB: TypedFunctionDescription<{
      encode([orbitdb]: [string]): string;
    }>;

    updateUserOrbitDB: TypedFunctionDescription<{
      encode([orbitdb]: [string]): string;
    }>;

    getProfileDBAddress: TypedFunctionDescription<{
      encode([node]: [Arrayish]): string;
    }>;

    lookupRegisteredENSDomain: TypedFunctionDescription<{
      encode([addr]: [string]): string;
    }>;

    addr: TypedFunctionDescription<{ encode([node]: [Arrayish]): string }>;

    getENSRegistrar: TypedFunctionDescription<{ encode([]: []): string }>;

    setMiningResolver: TypedFunctionDescription<{
      encode([miningResolverAddress]: [string]): string;
    }>;

    getMiningResolver: TypedFunctionDescription<{ encode([]: []): string }>;

    addExtensionToNetwork: TypedFunctionDescription<{
      encode([extensionId, resolver]: [Arrayish, string]): string;
    }>;

    installExtension: TypedFunctionDescription<{
      encode([extensionId, version]: [Arrayish, BigNumberish]): string;
    }>;

    upgradeExtension: TypedFunctionDescription<{
      encode([extensionId, newVersion]: [Arrayish, BigNumberish]): string;
    }>;

    deprecateExtension: TypedFunctionDescription<{
      encode([extensionId, deprecated]: [Arrayish, boolean]): string;
    }>;

    uninstallExtension: TypedFunctionDescription<{
      encode([extensionId]: [Arrayish]): string;
    }>;

    getExtensionResolver: TypedFunctionDescription<{
      encode([extensionId, version]: [Arrayish, BigNumberish]): string;
    }>;

    getExtensionInstallation: TypedFunctionDescription<{
      encode([extensionId, colony]: [Arrayish, string]): string;
    }>;

    getFeeInverse: TypedFunctionDescription<{ encode([]: []): string }>;

    setFeeInverse: TypedFunctionDescription<{
      encode([_feeInverse]: [BigNumberish]): string;
    }>;

    getPayoutWhitelist: TypedFunctionDescription<{
      encode([_token]: [string]): string;
    }>;

    setPayoutWhitelist: TypedFunctionDescription<{
      encode([_token, _status]: [string, boolean]): string;
    }>;

    punishStakers: TypedFunctionDescription<{
      encode([_stakers, _amount]: [string[], BigNumberish]): string;
    }>;

    stakeForMining: TypedFunctionDescription<{
      encode([_amount]: [BigNumberish]): string;
    }>;

    unstakeForMining: TypedFunctionDescription<{
      encode([_amount]: [BigNumberish]): string;
    }>;

    getMiningStake: TypedFunctionDescription<{
      encode([_user]: [string]): string;
    }>;

    reward: TypedFunctionDescription<{
      encode([_recipient, _amount]: [string, BigNumberish]): string;
    }>;

    burnUnneededRewards: TypedFunctionDescription<{
      encode([_amount]: [BigNumberish]): string;
    }>;

    claimMiningReward: TypedFunctionDescription<{
      encode([_recipient]: [string]): string;
    }>;

    setAnnualMetaColonyStipend: TypedFunctionDescription<{
      encode([_amount]: [BigNumberish]): string;
    }>;

    issueMetaColonyStipend: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    setReputationMiningCycleReward: TypedFunctionDescription<{
      encode([_amount]: [BigNumberish]): string;
    }>;

    getReputationMiningCycleReward: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getAnnualMetaColonyStipend: TypedFunctionDescription<{
      encode([]: []): string;
    }>;
  };

  events: {
    AuctionCreated: TypedEventDescription<{
      encodeTopics([auction, token, quantity]: [null, null, null]): string[];
    }>;

    ColonyAdded: TypedEventDescription<{
      encodeTopics([colonyId, colonyAddress, token]: [
        BigNumberish | null,
        string | null,
        null
      ]): string[];
    }>;

    ColonyLabelRegistered: TypedEventDescription<{
      encodeTopics([colony, label]: [string | null, null]): string[];
    }>;

    ColonyNetworkInitialised: TypedEventDescription<{
      encodeTopics([resolver]: [null]): string[];
    }>;

    ColonyVersionAdded: TypedEventDescription<{
      encodeTopics([version, resolver]: [null, null]): string[];
    }>;

    ExtensionAddedToNetwork: TypedEventDescription<{
      encodeTopics([extensionId, version]: [Arrayish | null, null]): string[];
    }>;

    ExtensionDeprecated: TypedEventDescription<{
      encodeTopics([extensionId, colony, deprecated]: [
        Arrayish | null,
        string | null,
        null
      ]): string[];
    }>;

    ExtensionInstalled: TypedEventDescription<{
      encodeTopics([extensionId, colony, version]: [
        Arrayish | null,
        string | null,
        null
      ]): string[];
    }>;

    ExtensionUninstalled: TypedEventDescription<{
      encodeTopics([extensionId, colony]: [
        Arrayish | null,
        string | null
      ]): string[];
    }>;

    ExtensionUpgraded: TypedEventDescription<{
      encodeTopics([extensionId, colony, version]: [
        Arrayish | null,
        string | null,
        null
      ]): string[];
    }>;

    MetaColonyCreated: TypedEventDescription<{
      encodeTopics([metaColony, token, rootSkillId]: [
        null,
        null,
        null
      ]): string[];
    }>;

    MiningCycleResolverSet: TypedEventDescription<{
      encodeTopics([miningCycleResolver]: [null]): string[];
    }>;

    NetworkFeeInverseSet: TypedEventDescription<{
      encodeTopics([feeInverse]: [null]): string[];
    }>;

    RecoveryModeEntered: TypedEventDescription<{
      encodeTopics([user]: [null]): string[];
    }>;

    RecoveryModeExitApproved: TypedEventDescription<{
      encodeTopics([user]: [null]): string[];
    }>;

    RecoveryModeExited: TypedEventDescription<{
      encodeTopics([user]: [null]): string[];
    }>;

    RecoveryRoleSet: TypedEventDescription<{
      encodeTopics([user, setTo]: [string | null, null]): string[];
    }>;

    RecoveryStorageSlotSet: TypedEventDescription<{
      encodeTopics([user, slot, fromValue, toValue]: [
        null,
        null,
        null,
        null
      ]): string[];
    }>;

    ReputationMinerPenalised: TypedEventDescription<{
      encodeTopics([miner, tokensLost]: [null, null]): string[];
    }>;

    ReputationMiningCycleComplete: TypedEventDescription<{
      encodeTopics([hash, nLeaves]: [null, null]): string[];
    }>;

    ReputationMiningInitialised: TypedEventDescription<{
      encodeTopics([inactiveReputationMiningCycle]: [null]): string[];
    }>;

    ReputationRootHashSet: TypedEventDescription<{
      encodeTopics([newHash, newNLeaves, stakers, reward]: [
        null,
        null,
        null,
        null
      ]): string[];
    }>;

    SkillAdded: TypedEventDescription<{
      encodeTopics([skillId, parentSkillId]: [null, null]): string[];
    }>;

    TokenLockingAddressSet: TypedEventDescription<{
      encodeTopics([tokenLocking]: [null]): string[];
    }>;

    TokenWhitelisted: TypedEventDescription<{
      encodeTopics([token, status]: [null, null]): string[];
    }>;

    UserLabelRegistered: TypedEventDescription<{
      encodeTopics([user, label]: [string | null, null]): string[];
    }>;
  };
}

export class IColonyNetwork extends Contract {
  connect(signerOrProvider: Signer | Provider | string): IColonyNetwork;
  attach(addressOrName: string): IColonyNetwork;
  deployed(): Promise<IColonyNetwork>;

  on(event: EventFilter | string, listener: Listener): IColonyNetwork;
  once(event: EventFilter | string, listener: Listener): IColonyNetwork;
  addListener(
    eventName: EventFilter | string,
    listener: Listener
  ): IColonyNetwork;
  removeAllListeners(eventName: EventFilter | string): IColonyNetwork;
  removeListener(eventName: any, listener: Listener): IColonyNetwork;

  interface: IColonyNetworkInterface;

  functions: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(_slot: BigNumberish): Promise<void>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(): Promise<boolean>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(): Promise<BigNumber>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Interface identification is specified in ERC-165.
     * Query if a contract implements an interface
     * @param interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(interfaceID: Arrayish): Promise<boolean>;

    /**
     * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
     * Set a replacement log entry if we're in recovery mode.
     * @param _amount The amount of reputation being earned / lost
     * @param _colony The address of the colony being updated
     * @param _id The number of the log entry in the reputation mining cycle in question.
     * @param _nPreviousUpdates The number of updates in the log before this entry
     * @param _nUpdates The number of updates the log entry corresponds to
     * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
     * @param _skillId The id of the origin skill for the reputation update
     * @param _user The address of the user earning / losing the reputation
     */
    setReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
     * @param _id The log entry number we wish to see if there is a replacement for
     * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
     */
    getReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish
    ): Promise<{
      user: string;
      amount: BigNumber;
      skillId: BigNumber;
      colony: string;
      nUpdates: BigNumber;
      nPreviousUpdates: BigNumber;
      0: string;
      1: BigNumber;
      2: BigNumber;
      3: string;
      4: BigNumber;
      5: BigNumber;
    }>;

    /**
     * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
     * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
     */
    getReplacementReputationUpdateLogsExist(
      _reputationMiningCycle: string
    ): Promise<boolean>;

    /**
     * Get the Meta Colony address.
     */
    getMetaColony(): Promise<string>;

    /**
     * Get the number of colonies in the network.
     */
    getColonyCount(): Promise<BigNumber>;

    /**
     * Check if specific address is a colony created on colony network.
     * @param _colony Address of the colony
     */
    isColony(_colony: string): Promise<boolean>;

    /**
     * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
     * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
     * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
     */
    addSkill(
      _parentSkillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get the `nParents` and `nChildren` of skill with id `_skillId`.
     * @param _skillId Id of the skill
     */
    getSkill(
      _skillId: BigNumberish
    ): Promise<{
      nParents: BigNumber;
      nChildren: BigNumber;
      parents: BigNumber[];
      children: BigNumber[];
      globalSkill: boolean;
      deprecated: boolean;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber[];
      3: BigNumber[];
      4: boolean;
      5: boolean;
    }>;

    /**
     * Mark a global skill as deprecated which stops new tasks and payments from using it.
     * @param _skillId Id of the skill
     */
    deprecateSkill(
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
     * Adds a reputation update entry to log.
     * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
     * @param _skillId The skill for the reputation update
     * @param _user The address of the user for the reputation update
     */
    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get the number of skills in the network including both global and local skills.
     */
    getSkillCount(): Promise<BigNumber>;

    /**
     * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
     */
    getReputationMiningSkillId(): Promise<BigNumber>;

    /**
     * Sets the token locking address. This is only set once, and can't be changed afterwards.
     * @param _tokenLockingAddress Address of the locking contract
     */
    setTokenLocking(
      _tokenLockingAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get token locking contract address.
     */
    getTokenLocking(): Promise<string>;

    /**
     * Create the Meta Colony, same as a normal colony plus the root skill.
     * @param _tokenAddress Address of the CLNY token
     */
    createMetaColony(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, at version 3
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
     */
    "createColony(address)"(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _metadata The metadata associated with the new colony
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _orbitdb DEPRECATED Currently a no-op
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _useExtensionManager DEPRECATED Currently a no-op
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string,bool)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _orbitdb: string,
      _useExtensionManager: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
     * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
     * @param _version The new Colony contract version
     */
    addColonyVersion(
      _version: BigNumberish,
      _resolver: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Only allowed to be run once, by the Network owner before any Colony versions are added.
     * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
     * @param _resolver Address of the resolver for Colony contract
     * @param _version Version of the Colony contract the resolver represents
     */
    initialise(
      _resolver: string,
      _version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get a colony address by its Id in the network.
     * @param _id Id of the colony to get
     */
    getColony(_id: BigNumberish): Promise<string>;

    /**
     * Returns the latest Colony contract version. This is the version used to create all new colonies.
     */
    getCurrentColonyVersion(): Promise<BigNumber>;

    /**
     * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
     * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
     * @param _skillId Id of the skill
     */
    getParentSkillId(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish
    ): Promise<BigNumber>;

    /**
     * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
     * @param _childSkillIndex Index of the `skill.children` array to get
     * @param _skillId Id of the skill
     */
    getChildSkillId(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish
    ): Promise<BigNumber>;

    /**
     * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
     * @param _active Whether the user wants the active or inactive reputation mining cycle
     */
    getReputationMiningCycle(_active: boolean): Promise<string>;

    /**
     * Calculate raw miner weight in WADs.
     * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
     * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
     */
    calculateMinerWeight(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish
    ): Promise<BigNumber>;

    /**
     * Get the `Resolver` address for Colony contract version `_version`.
     * @param _version The Colony contract version
     */
    getColonyVersionResolver(_version: BigNumberish): Promise<string>;

    /**
     * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
     * @param newHash The reputation root hash
     * @param newNLeaves The updated leaves count value
     * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    "setReputationRootHash(bytes32,uint256,address[])"(
      newHash: Arrayish,
      newNLeaves: BigNumberish,
      stakers: string[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This version of setReputationRootHash is deprecated and will be removed in a future release. It transparently calls the new version if it is called (essentially, removing the `reward` parameter.
     * @param newHash The reputation root hash
     * @param newNLeaves The updated leaves count value
     * @param reward Amount of CLNY to be distributed as reward to miners (not used)
     * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    "setReputationRootHash(bytes32,uint256,address[],uint256)"(
      newHash: Arrayish,
      newNLeaves: BigNumberish,
      stakers: string[],
      reward: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
     */
    startNextCycle(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Creates initial inactive reputation mining cycle.
     */
    initialiseReputationMining(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get the root hash of the current reputation state tree.
     */
    getReputationRootHash(): Promise<string>;

    /**
     * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNLeaves(): Promise<BigNumber>;

    /**
     * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNNodes(): Promise<BigNumber>;

    /**
     * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
     * @param _token Address of the token held by the network to be auctioned
     */
    startTokenAuction(
      _token: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Setup registrar with ENS and root node.
     * @param _ens Address of ENS registrar
     * @param _rootNode Namehash of the root node for the domain
     */
    setupRegistrar(
      _ens: string,
      _rootNode: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Register a "user.joincolony.eth" label.
     * @param orbitdb The path of the orbitDB database associated with the user profile
     * @param username The label to register
     */
    registerUserLabel(
      username: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
     * @param colonyName The label to register.
     * @param orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      colonyName: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the user
     */
    updateUserOrbitDB(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Retrieve the orbitdb address corresponding to a registered account.
     * @param node The Namehash of the account being queried.
     */
    getProfileDBAddress(node: Arrayish): Promise<string>;

    /**
     * Reverse lookup a username from an address.
     * @param addr The address we wish to find the corresponding ENS domain for (if any)
     */
    lookupRegisteredENSDomain(addr: string): Promise<string>;

    /**
     * Returns the address the supplied node resolves do, if we are the resolver.
     * @param node The namehash of the ENS address being requested
     */
    addr(node: Arrayish): Promise<string>;

    /**
     * Returns the address of the ENSRegistrar for the Network.
     */
    getENSRegistrar(): Promise<string>;

    /**
     * Set the resolver to be used by new instances of ReputationMiningCycle.
     * @param miningResolverAddress The address of the Resolver contract with the functions correctly wired.
     */
    setMiningResolver(
      miningResolverAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get the resolver to be used by new instances of ReputationMiningCycle.
     */
    getMiningResolver(): Promise<string>;

    /**
     * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
     * Add a new extension resolver to the Extensions repository.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param resolver The deployed resolver containing the extension contract logic
     */
    addExtensionToNetwork(
      extensionId: Arrayish,
      resolver: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Install an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension to install
     */
    installExtension(
      extensionId: Arrayish,
      version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Upgrade an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param newVersion Version of the extension to upgrade to (must be one greater than current)
     */
    upgradeExtension(
      extensionId: Arrayish,
      newVersion: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set the deprecation of an extension in a colony. Can only be called by a Colony.
     * @param deprecated Whether to deprecate the extension or not
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      extensionId: Arrayish,
      deprecated: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Uninstall an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      extensionId: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get an extension's resolver.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension
     */
    getExtensionResolver(
      extensionId: Arrayish,
      version: BigNumberish
    ): Promise<string>;

    /**
     * Get an extension's installation.
     * @param colony Address of the colony the extension is installed in
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    getExtensionInstallation(
      extensionId: Arrayish,
      colony: string
    ): Promise<string>;

    /**
     * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getFeeInverse(): Promise<BigNumber>;

    /**
     * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
     * @param _feeInverse The inverse of the network fee to set
     */
    setFeeInverse(
      _feeInverse: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get a token's status in the payout whitelist
     * @param _token The token being queried
     */
    getPayoutWhitelist(_token: string): Promise<boolean>;

    /**
     * Set a token's status in the payout whitelist
     * @param _status The whitelist status
     * @param _token The token being set
     */
    setPayoutWhitelist(
      _token: string,
      _status: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * While external, it can only be called successfully by the current ReputationMiningCycle.
     * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
     * @param _amount Amount of stake to slash
     * @param _stakers Array of the addresses of stakers to punish
     */
    punishStakers(
      _stakers: string[],
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Stake CLNY to allow the staker to participate in reputation mining.
     * @param _amount Amount of CLNY to stake for the purposes of mining
     */
    stakeForMining(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Unstake CLNY currently staked for reputation mining.
     * @param _amount Amount of CLNY staked for mining to unstake
     */
    unstakeForMining(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * returns how much CLNY _user has staked for the purposes of reputation mining
     * @param _user The user to query
     */
    getMiningStake(
      _user: string
    ): Promise<{
      amount: BigNumber;
      timestamp: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to track that a user is eligible to claim a reward
     * @param _amount The amount of CLNY to be awarded
     * @param _recipient The address receiving the award
     */
    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
     * @param _amount The amount of CLNY to burn
     */
    burnUnneededRewards(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Can be called by anyone, not just _recipient
     * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
     * @param _recipient The user whose rewards to claim
     */
    claimMiningReward(
      _recipient: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the metaColony stipend. This value will be the total amount of CLNY created for the metacolony in a single year. The corresponding `issueMetaColonyStipend` function can be called at any interval.
     * @param _amount The amount of CLNY to issue to the metacolony every year
     */
    setAnnualMetaColonyStipend(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Called to issue the metaColony stipend. This external function can be called by anyone at any interval, and an appropriate amount of CLNY will be minted based on the time since the last time it was called.
     */
    issueMetaColonyStipend(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the total per-cycle reputation reward, which will be split between all miners.
     */
    setReputationMiningCycleReward(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    getReputationMiningCycleReward(): Promise<BigNumber>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    getAnnualMetaColonyStipend(): Promise<BigNumber>;
  };

  /**
   * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
   */
  approveExitRecovery(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
   * Check whether the supplied slot is a protected variable specific to this contract
   * @param _slot The storage slot number to check.
   */
  checkNotAdditionalProtectedVariable(_slot: BigNumberish): Promise<void>;

  /**
   * Put colony network mining into recovery mode. Can only be called by user with recovery role.
   */
  enterRecoveryMode(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
   */
  exitRecoveryMode(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Is colony network in recovery mode.
   */
  isInRecoveryMode(): Promise<boolean>;

  /**
   * Return number of recovery roles.
   */
  numRecoveryRoles(): Promise<BigNumber>;

  /**
   * Remove colony recovery role. Can only be called by root role.
   * @param _user User we want to remove recovery role from
   */
  removeRecoveryRole(
    _user: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set new colony recovery role. Can be called by root.
   * @param _user User we want to give a recovery role to
   */
  setRecoveryRole(
    _user: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * certain critical variables are protected from editing in this function
   * Update value of arbitrary storage variable. Can only be called by user with recovery role.
   * @param _slot Uint address of storage slot to be updated
   * @param _value word of data to be set
   */
  setStorageSlotRecovery(
    _slot: BigNumberish,
    _value: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Interface identification is specified in ERC-165.
   * Query if a contract implements an interface
   * @param interfaceID The interface identifier, as specified in ERC-165
   */
  supportsInterface(interfaceID: Arrayish): Promise<boolean>;

  /**
   * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
   * Set a replacement log entry if we're in recovery mode.
   * @param _amount The amount of reputation being earned / lost
   * @param _colony The address of the colony being updated
   * @param _id The number of the log entry in the reputation mining cycle in question.
   * @param _nPreviousUpdates The number of updates in the log before this entry
   * @param _nUpdates The number of updates the log entry corresponds to
   * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
   * @param _skillId The id of the origin skill for the reputation update
   * @param _user The address of the user earning / losing the reputation
   */
  setReplacementReputationUpdateLogEntry(
    _reputationMiningCycle: string,
    _id: BigNumberish,
    _user: string,
    _amount: BigNumberish,
    _skillId: BigNumberish,
    _colony: string,
    _nUpdates: BigNumberish,
    _nPreviousUpdates: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
   * @param _id The log entry number we wish to see if there is a replacement for
   * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
   */
  getReplacementReputationUpdateLogEntry(
    _reputationMiningCycle: string,
    _id: BigNumberish
  ): Promise<{
    user: string;
    amount: BigNumber;
    skillId: BigNumber;
    colony: string;
    nUpdates: BigNumber;
    nPreviousUpdates: BigNumber;
    0: string;
    1: BigNumber;
    2: BigNumber;
    3: string;
    4: BigNumber;
    5: BigNumber;
  }>;

  /**
   * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
   * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
   */
  getReplacementReputationUpdateLogsExist(
    _reputationMiningCycle: string
  ): Promise<boolean>;

  /**
   * Get the Meta Colony address.
   */
  getMetaColony(): Promise<string>;

  /**
   * Get the number of colonies in the network.
   */
  getColonyCount(): Promise<BigNumber>;

  /**
   * Check if specific address is a colony created on colony network.
   * @param _colony Address of the colony
   */
  isColony(_colony: string): Promise<boolean>;

  /**
   * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
   * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
   * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
   */
  addSkill(
    _parentSkillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get the `nParents` and `nChildren` of skill with id `_skillId`.
   * @param _skillId Id of the skill
   */
  getSkill(
    _skillId: BigNumberish
  ): Promise<{
    nParents: BigNumber;
    nChildren: BigNumber;
    parents: BigNumber[];
    children: BigNumber[];
    globalSkill: boolean;
    deprecated: boolean;
    0: BigNumber;
    1: BigNumber;
    2: BigNumber[];
    3: BigNumber[];
    4: boolean;
    5: boolean;
  }>;

  /**
   * Mark a global skill as deprecated which stops new tasks and payments from using it.
   * @param _skillId Id of the skill
   */
  deprecateSkill(
    _skillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
   * Adds a reputation update entry to log.
   * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
   * @param _skillId The skill for the reputation update
   * @param _user The address of the user for the reputation update
   */
  appendReputationUpdateLog(
    _user: string,
    _amount: BigNumberish,
    _skillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get the number of skills in the network including both global and local skills.
   */
  getSkillCount(): Promise<BigNumber>;

  /**
   * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
   */
  getReputationMiningSkillId(): Promise<BigNumber>;

  /**
   * Sets the token locking address. This is only set once, and can't be changed afterwards.
   * @param _tokenLockingAddress Address of the locking contract
   */
  setTokenLocking(
    _tokenLockingAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get token locking contract address.
   */
  getTokenLocking(): Promise<string>;

  /**
   * Create the Meta Colony, same as a normal colony plus the root skill.
   * @param _tokenAddress Address of the CLNY token
   */
  createMetaColony(
    _tokenAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
   * Creates a new colony in the network, at version 3
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
   */
  "createColony(address)"(
    _tokenAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
   * Creates a new colony in the network, with an optional ENS name
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _metadata The metadata associated with the new colony
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  "createColony(address,uint256,string,string)"(
    _tokenAddress: string,
    _version: BigNumberish,
    _colonyName: string,
    _metadata: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * For the colony to mint tokens, token ownership must be transferred to the new colony
   * Creates a new colony in the network, with an optional ENS name
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  "createColony(address,uint256,string)"(
    _tokenAddress: string,
    _version: BigNumberish,
    _colonyName: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
   * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _orbitdb DEPRECATED Currently a no-op
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token
   * @param _useExtensionManager DEPRECATED Currently a no-op
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  "createColony(address,uint256,string,string,bool)"(
    _tokenAddress: string,
    _version: BigNumberish,
    _colonyName: string,
    _orbitdb: string,
    _useExtensionManager: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
   * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
   * @param _version The new Colony contract version
   */
  addColonyVersion(
    _version: BigNumberish,
    _resolver: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Only allowed to be run once, by the Network owner before any Colony versions are added.
   * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
   * @param _resolver Address of the resolver for Colony contract
   * @param _version Version of the Colony contract the resolver represents
   */
  initialise(
    _resolver: string,
    _version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get a colony address by its Id in the network.
   * @param _id Id of the colony to get
   */
  getColony(_id: BigNumberish): Promise<string>;

  /**
   * Returns the latest Colony contract version. This is the version used to create all new colonies.
   */
  getCurrentColonyVersion(): Promise<BigNumber>;

  /**
   * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
   * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
   * @param _skillId Id of the skill
   */
  getParentSkillId(
    _skillId: BigNumberish,
    _parentSkillIndex: BigNumberish
  ): Promise<BigNumber>;

  /**
   * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
   * @param _childSkillIndex Index of the `skill.children` array to get
   * @param _skillId Id of the skill
   */
  getChildSkillId(
    _skillId: BigNumberish,
    _childSkillIndex: BigNumberish
  ): Promise<BigNumber>;

  /**
   * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
   * @param _active Whether the user wants the active or inactive reputation mining cycle
   */
  getReputationMiningCycle(_active: boolean): Promise<string>;

  /**
   * Calculate raw miner weight in WADs.
   * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
   * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
   */
  calculateMinerWeight(
    _timeStaked: BigNumberish,
    _submissonIndex: BigNumberish
  ): Promise<BigNumber>;

  /**
   * Get the `Resolver` address for Colony contract version `_version`.
   * @param _version The Colony contract version
   */
  getColonyVersionResolver(_version: BigNumberish): Promise<string>;

  /**
   * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
   * @param newHash The reputation root hash
   * @param newNLeaves The updated leaves count value
   * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
   */
  "setReputationRootHash(bytes32,uint256,address[])"(
    newHash: Arrayish,
    newNLeaves: BigNumberish,
    stakers: string[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This version of setReputationRootHash is deprecated and will be removed in a future release. It transparently calls the new version if it is called (essentially, removing the `reward` parameter.
   * @param newHash The reputation root hash
   * @param newNLeaves The updated leaves count value
   * @param reward Amount of CLNY to be distributed as reward to miners (not used)
   * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
   */
  "setReputationRootHash(bytes32,uint256,address[],uint256)"(
    newHash: Arrayish,
    newNLeaves: BigNumberish,
    stakers: string[],
    reward: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
   */
  startNextCycle(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Creates initial inactive reputation mining cycle.
   */
  initialiseReputationMining(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get the root hash of the current reputation state tree.
   */
  getReputationRootHash(): Promise<string>;

  /**
   * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
   * Get the number of leaves in the current reputation state tree.
   */
  getReputationRootHashNLeaves(): Promise<BigNumber>;

  /**
   * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
   * Get the number of leaves in the current reputation state tree.
   */
  getReputationRootHashNNodes(): Promise<BigNumber>;

  /**
   * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
   * @param _token Address of the token held by the network to be auctioned
   */
  startTokenAuction(
    _token: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Setup registrar with ENS and root node.
   * @param _ens Address of ENS registrar
   * @param _rootNode Namehash of the root node for the domain
   */
  setupRegistrar(
    _ens: string,
    _rootNode: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Register a "user.joincolony.eth" label.
   * @param orbitdb The path of the orbitDB database associated with the user profile
   * @param username The label to register
   */
  registerUserLabel(
    username: string,
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
   * @param colonyName The label to register.
   * @param orbitdb The path of the orbitDB database associated with the colony name
   */
  registerColonyLabel(
    colonyName: string,
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
   * @param orbitdb The path of the orbitDB database to be associated with the colony
   */
  updateColonyOrbitDB(
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
   * @param orbitdb The path of the orbitDB database to be associated with the user
   */
  updateUserOrbitDB(
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Retrieve the orbitdb address corresponding to a registered account.
   * @param node The Namehash of the account being queried.
   */
  getProfileDBAddress(node: Arrayish): Promise<string>;

  /**
   * Reverse lookup a username from an address.
   * @param addr The address we wish to find the corresponding ENS domain for (if any)
   */
  lookupRegisteredENSDomain(addr: string): Promise<string>;

  /**
   * Returns the address the supplied node resolves do, if we are the resolver.
   * @param node The namehash of the ENS address being requested
   */
  addr(node: Arrayish): Promise<string>;

  /**
   * Returns the address of the ENSRegistrar for the Network.
   */
  getENSRegistrar(): Promise<string>;

  /**
   * Set the resolver to be used by new instances of ReputationMiningCycle.
   * @param miningResolverAddress The address of the Resolver contract with the functions correctly wired.
   */
  setMiningResolver(
    miningResolverAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get the resolver to be used by new instances of ReputationMiningCycle.
   */
  getMiningResolver(): Promise<string>;

  /**
   * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
   * Add a new extension resolver to the Extensions repository.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param resolver The deployed resolver containing the extension contract logic
   */
  addExtensionToNetwork(
    extensionId: Arrayish,
    resolver: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Install an extension in a colony. Can only be called by a Colony.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param version Version of the extension to install
   */
  installExtension(
    extensionId: Arrayish,
    version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Upgrade an extension in a colony. Can only be called by a Colony.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param newVersion Version of the extension to upgrade to (must be one greater than current)
   */
  upgradeExtension(
    extensionId: Arrayish,
    newVersion: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set the deprecation of an extension in a colony. Can only be called by a Colony.
   * @param deprecated Whether to deprecate the extension or not
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  deprecateExtension(
    extensionId: Arrayish,
    deprecated: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Uninstall an extension in a colony. Can only be called by a Colony.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  uninstallExtension(
    extensionId: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get an extension's resolver.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param version Version of the extension
   */
  getExtensionResolver(
    extensionId: Arrayish,
    version: BigNumberish
  ): Promise<string>;

  /**
   * Get an extension's installation.
   * @param colony Address of the colony the extension is installed in
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  getExtensionInstallation(
    extensionId: Arrayish,
    colony: string
  ): Promise<string>;

  /**
   * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
   */
  getFeeInverse(): Promise<BigNumber>;

  /**
   * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
   * @param _feeInverse The inverse of the network fee to set
   */
  setFeeInverse(
    _feeInverse: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get a token's status in the payout whitelist
   * @param _token The token being queried
   */
  getPayoutWhitelist(_token: string): Promise<boolean>;

  /**
   * Set a token's status in the payout whitelist
   * @param _status The whitelist status
   * @param _token The token being set
   */
  setPayoutWhitelist(
    _token: string,
    _status: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * While external, it can only be called successfully by the current ReputationMiningCycle.
   * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
   * @param _amount Amount of stake to slash
   * @param _stakers Array of the addresses of stakers to punish
   */
  punishStakers(
    _stakers: string[],
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Stake CLNY to allow the staker to participate in reputation mining.
   * @param _amount Amount of CLNY to stake for the purposes of mining
   */
  stakeForMining(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Unstake CLNY currently staked for reputation mining.
   * @param _amount Amount of CLNY staked for mining to unstake
   */
  unstakeForMining(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * returns how much CLNY _user has staked for the purposes of reputation mining
   * @param _user The user to query
   */
  getMiningStake(
    _user: string
  ): Promise<{
    amount: BigNumber;
    timestamp: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  /**
   * Only callable by the active reputation mining cycle
   * Used to track that a user is eligible to claim a reward
   * @param _amount The amount of CLNY to be awarded
   * @param _recipient The address receiving the award
   */
  reward(
    _recipient: string,
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Only callable by the active reputation mining cycle
   * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
   * @param _amount The amount of CLNY to burn
   */
  burnUnneededRewards(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Can be called by anyone, not just _recipient
   * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
   * @param _recipient The user whose rewards to claim
   */
  claimMiningReward(
    _recipient: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Can only be called by the MetaColony.
   * Called to set the metaColony stipend. This value will be the total amount of CLNY created for the metacolony in a single year. The corresponding `issueMetaColonyStipend` function can be called at any interval.
   * @param _amount The amount of CLNY to issue to the metacolony every year
   */
  setAnnualMetaColonyStipend(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Called to issue the metaColony stipend. This external function can be called by anyone at any interval, and an appropriate amount of CLNY will be minted based on the time since the last time it was called.
   */
  issueMetaColonyStipend(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Can only be called by the MetaColony.
   * Called to set the total per-cycle reputation reward, which will be split between all miners.
   */
  setReputationMiningCycleReward(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Called to get the total per-cycle reputation mining reward.
   */
  getReputationMiningCycleReward(): Promise<BigNumber>;

  /**
   * Called to get the total per-cycle reputation mining reward.
   */
  getAnnualMetaColonyStipend(): Promise<BigNumber>;

  filters: {
    AuctionCreated(auction: null, token: null, quantity: null): EventFilter;

    ColonyAdded(
      colonyId: BigNumberish | null,
      colonyAddress: string | null,
      token: null
    ): EventFilter;

    ColonyLabelRegistered(colony: string | null, label: null): EventFilter;

    ColonyNetworkInitialised(resolver: null): EventFilter;

    ColonyVersionAdded(version: null, resolver: null): EventFilter;

    ExtensionAddedToNetwork(
      extensionId: Arrayish | null,
      version: null
    ): EventFilter;

    ExtensionDeprecated(
      extensionId: Arrayish | null,
      colony: string | null,
      deprecated: null
    ): EventFilter;

    ExtensionInstalled(
      extensionId: Arrayish | null,
      colony: string | null,
      version: null
    ): EventFilter;

    ExtensionUninstalled(
      extensionId: Arrayish | null,
      colony: string | null
    ): EventFilter;

    ExtensionUpgraded(
      extensionId: Arrayish | null,
      colony: string | null,
      version: null
    ): EventFilter;

    MetaColonyCreated(
      metaColony: null,
      token: null,
      rootSkillId: null
    ): EventFilter;

    MiningCycleResolverSet(miningCycleResolver: null): EventFilter;

    NetworkFeeInverseSet(feeInverse: null): EventFilter;

    RecoveryModeEntered(user: null): EventFilter;

    RecoveryModeExitApproved(user: null): EventFilter;

    RecoveryModeExited(user: null): EventFilter;

    RecoveryRoleSet(user: string | null, setTo: null): EventFilter;

    RecoveryStorageSlotSet(
      user: null,
      slot: null,
      fromValue: null,
      toValue: null
    ): EventFilter;

    ReputationMinerPenalised(miner: null, tokensLost: null): EventFilter;

    ReputationMiningCycleComplete(hash: null, nLeaves: null): EventFilter;

    ReputationMiningInitialised(
      inactiveReputationMiningCycle: null
    ): EventFilter;

    ReputationRootHashSet(
      newHash: null,
      newNLeaves: null,
      stakers: null,
      reward: null
    ): EventFilter;

    SkillAdded(skillId: null, parentSkillId: null): EventFilter;

    TokenLockingAddressSet(tokenLocking: null): EventFilter;

    TokenWhitelisted(token: null, status: null): EventFilter;

    UserLabelRegistered(user: string | null, label: null): EventFilter;
  };

  estimate: {
    approveExitRecovery(): Promise<BigNumber>;

    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish
    ): Promise<BigNumber>;

    enterRecoveryMode(): Promise<BigNumber>;

    exitRecoveryMode(): Promise<BigNumber>;

    isInRecoveryMode(): Promise<BigNumber>;

    numRecoveryRoles(): Promise<BigNumber>;

    removeRecoveryRole(_user: string): Promise<BigNumber>;

    setRecoveryRole(_user: string): Promise<BigNumber>;

    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: Arrayish
    ): Promise<BigNumber>;

    supportsInterface(interfaceID: Arrayish): Promise<BigNumber>;

    setReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish
    ): Promise<BigNumber>;

    getReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish
    ): Promise<BigNumber>;

    getReplacementReputationUpdateLogsExist(
      _reputationMiningCycle: string
    ): Promise<BigNumber>;

    getMetaColony(): Promise<BigNumber>;

    getColonyCount(): Promise<BigNumber>;

    isColony(_colony: string): Promise<BigNumber>;

    addSkill(_parentSkillId: BigNumberish): Promise<BigNumber>;

    getSkill(_skillId: BigNumberish): Promise<BigNumber>;

    deprecateSkill(_skillId: BigNumberish): Promise<BigNumber>;

    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish
    ): Promise<BigNumber>;

    getSkillCount(): Promise<BigNumber>;

    getReputationMiningSkillId(): Promise<BigNumber>;

    setTokenLocking(_tokenLockingAddress: string): Promise<BigNumber>;

    getTokenLocking(): Promise<BigNumber>;

    createMetaColony(_tokenAddress: string): Promise<BigNumber>;

    createColony(_tokenAddress: string): Promise<BigNumber>;

    addColonyVersion(
      _version: BigNumberish,
      _resolver: string
    ): Promise<BigNumber>;

    initialise(_resolver: string, _version: BigNumberish): Promise<BigNumber>;

    getColony(_id: BigNumberish): Promise<BigNumber>;

    getCurrentColonyVersion(): Promise<BigNumber>;

    getParentSkillId(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish
    ): Promise<BigNumber>;

    getChildSkillId(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish
    ): Promise<BigNumber>;

    getReputationMiningCycle(_active: boolean): Promise<BigNumber>;

    calculateMinerWeight(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish
    ): Promise<BigNumber>;

    getColonyVersionResolver(_version: BigNumberish): Promise<BigNumber>;

    setReputationRootHash(
      newHash: Arrayish,
      newNLeaves: BigNumberish,
      stakers: string[]
    ): Promise<BigNumber>;

    startNextCycle(): Promise<BigNumber>;

    initialiseReputationMining(): Promise<BigNumber>;

    getReputationRootHash(): Promise<BigNumber>;

    getReputationRootHashNLeaves(): Promise<BigNumber>;

    getReputationRootHashNNodes(): Promise<BigNumber>;

    startTokenAuction(_token: string): Promise<BigNumber>;

    setupRegistrar(_ens: string, _rootNode: Arrayish): Promise<BigNumber>;

    registerUserLabel(username: string, orbitdb: string): Promise<BigNumber>;

    registerColonyLabel(
      colonyName: string,
      orbitdb: string
    ): Promise<BigNumber>;

    updateColonyOrbitDB(orbitdb: string): Promise<BigNumber>;

    updateUserOrbitDB(orbitdb: string): Promise<BigNumber>;

    getProfileDBAddress(node: Arrayish): Promise<BigNumber>;

    lookupRegisteredENSDomain(addr: string): Promise<BigNumber>;

    addr(node: Arrayish): Promise<BigNumber>;

    getENSRegistrar(): Promise<BigNumber>;

    setMiningResolver(miningResolverAddress: string): Promise<BigNumber>;

    getMiningResolver(): Promise<BigNumber>;

    addExtensionToNetwork(
      extensionId: Arrayish,
      resolver: string
    ): Promise<BigNumber>;

    installExtension(
      extensionId: Arrayish,
      version: BigNumberish
    ): Promise<BigNumber>;

    upgradeExtension(
      extensionId: Arrayish,
      newVersion: BigNumberish
    ): Promise<BigNumber>;

    deprecateExtension(
      extensionId: Arrayish,
      deprecated: boolean
    ): Promise<BigNumber>;

    uninstallExtension(extensionId: Arrayish): Promise<BigNumber>;

    getExtensionResolver(
      extensionId: Arrayish,
      version: BigNumberish
    ): Promise<BigNumber>;

    getExtensionInstallation(
      extensionId: Arrayish,
      colony: string
    ): Promise<BigNumber>;

    getFeeInverse(): Promise<BigNumber>;

    setFeeInverse(_feeInverse: BigNumberish): Promise<BigNumber>;

    getPayoutWhitelist(_token: string): Promise<BigNumber>;

    setPayoutWhitelist(_token: string, _status: boolean): Promise<BigNumber>;

    punishStakers(
      _stakers: string[],
      _amount: BigNumberish
    ): Promise<BigNumber>;

    stakeForMining(_amount: BigNumberish): Promise<BigNumber>;

    unstakeForMining(_amount: BigNumberish): Promise<BigNumber>;

    getMiningStake(_user: string): Promise<BigNumber>;

    reward(_recipient: string, _amount: BigNumberish): Promise<BigNumber>;

    burnUnneededRewards(_amount: BigNumberish): Promise<BigNumber>;

    claimMiningReward(_recipient: string): Promise<BigNumber>;

    setAnnualMetaColonyStipend(_amount: BigNumberish): Promise<BigNumber>;

    issueMetaColonyStipend(): Promise<BigNumber>;

    setReputationMiningCycleReward(_amount: BigNumberish): Promise<BigNumber>;

    getReputationMiningCycleReward(): Promise<BigNumber>;

    getAnnualMetaColonyStipend(): Promise<BigNumber>;
  };
}
