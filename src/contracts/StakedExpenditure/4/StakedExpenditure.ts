/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace StakedExpenditure {
  export type StakeStruct = { creator: string; amount: BigNumberish };

  export type StakeStructOutput = [string, BigNumber] & {
    creator: string;
    amount: BigNumber;
  };
}

export interface StakedExpenditureInterface extends utils.Interface {
  functions: {
    "authority()": FunctionFragment;
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getCapabilityRoles(bytes4)": FunctionFragment;
    "getChainId()": FunctionFragment;
    "getColony()": FunctionFragment;
    "getDeprecated()": FunctionFragment;
    "getMetatransactionNonce(address)": FunctionFragment;
    "multicall(bytes[])": FunctionFragment;
    "owner()": FunctionFragment;
    "setAuthority(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "verify(address,uint256,uint256,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "identifier()": FunctionFragment;
    "version()": FunctionFragment;
    "install(address)": FunctionFragment;
    "finishUpgrade()": FunctionFragment;
    "deprecate(bool)": FunctionFragment;
    "uninstall()": FunctionFragment;
    "initialise(uint256)": FunctionFragment;
    "setStakeFraction(uint256)": FunctionFragment;
    "makeExpenditureWithStake(uint256,uint256,uint256,bytes,bytes,uint256,bytes32[])": FunctionFragment;
    "reclaimStake(uint256)": FunctionFragment;
    "cancelAndReclaimStake(uint256,uint256,uint256)": FunctionFragment;
    "cancelAndPunish(uint256,uint256,uint256,uint256,uint256,bool)": FunctionFragment;
    "getStakeFraction()": FunctionFragment;
    "getStake(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "authority"
      | "executeMetaTransaction"
      | "getCapabilityRoles"
      | "getChainId"
      | "getColony"
      | "getDeprecated"
      | "getMetatransactionNonce"
      | "multicall"
      | "owner"
      | "setAuthority"
      | "setOwner"
      | "verify"
      | "identifier"
      | "version"
      | "install"
      | "finishUpgrade"
      | "deprecate"
      | "uninstall"
      | "initialise"
      | "setStakeFraction"
      | "makeExpenditureWithStake"
      | "reclaimStake"
      | "cancelAndReclaimStake"
      | "cancelAndPunish"
      | "getStakeFraction"
      | "getStake"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [string, BytesLike, BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCapabilityRoles",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getChainId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getColony", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getDeprecated",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMetatransactionNonce",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAuthority",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "setOwner", values: [string]): string;
  encodeFunctionData(
    functionFragment: "verify",
    values: [
      string,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike,
      BytesLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "identifier",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(functionFragment: "install", values: [string]): string;
  encodeFunctionData(
    functionFragment: "finishUpgrade",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "deprecate", values: [boolean]): string;
  encodeFunctionData(functionFragment: "uninstall", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "initialise",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setStakeFraction",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "makeExpenditureWithStake",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike,
      BigNumberish,
      BytesLike[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "reclaimStake",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelAndReclaimStake",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelAndPunish",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getStakeFraction",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getStake",
    values: [BigNumberish]
  ): string;

  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCapabilityRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getChainId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getColony", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDeprecated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetatransactionNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "verify", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "identifier", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "install", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finishUpgrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deprecate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "uninstall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialise", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setStakeFraction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "makeExpenditureWithStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reclaimStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelAndReclaimStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelAndPunish",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getStakeFraction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getStake", data: BytesLike): Result;

  events: {
    "ExpenditureCancelled(address,uint256)": EventFragment;
    "ExpenditureMadeViaStake(address,uint256,uint256)": EventFragment;
    "ExpenditureStakerPunished(address,uint256,bool)": EventFragment;
    "ExtensionInitialised()": EventFragment;
    "LogSetAuthority(address)": EventFragment;
    "LogSetOwner(address)": EventFragment;
    "MetaTransactionExecuted(address,address,bytes)": EventFragment;
    "StakeFractionSet(address,uint256)": EventFragment;
    "StakeReclaimed(uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ExpenditureCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExpenditureMadeViaStake"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExpenditureStakerPunished"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExtensionInitialised"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeFractionSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "StakeReclaimed"): EventFragment;
}

export interface ExpenditureCancelledEventObject {
  agent: string;
  expenditureId: BigNumber;
}
export type ExpenditureCancelledEvent = TypedEvent<
  [string, BigNumber],
  ExpenditureCancelledEventObject
>;

export type ExpenditureCancelledEventFilter =
  TypedEventFilter<ExpenditureCancelledEvent>;

export interface ExpenditureMadeViaStakeEventObject {
  creator: string;
  expenditureId: BigNumber;
  stake: BigNumber;
}
export type ExpenditureMadeViaStakeEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  ExpenditureMadeViaStakeEventObject
>;

export type ExpenditureMadeViaStakeEventFilter =
  TypedEventFilter<ExpenditureMadeViaStakeEvent>;

export interface ExpenditureStakerPunishedEventObject {
  agent: string;
  expenditureId: BigNumber;
  punished: boolean;
}
export type ExpenditureStakerPunishedEvent = TypedEvent<
  [string, BigNumber, boolean],
  ExpenditureStakerPunishedEventObject
>;

export type ExpenditureStakerPunishedEventFilter =
  TypedEventFilter<ExpenditureStakerPunishedEvent>;

export interface ExtensionInitialisedEventObject {}
export type ExtensionInitialisedEvent = TypedEvent<
  [],
  ExtensionInitialisedEventObject
>;

export type ExtensionInitialisedEventFilter =
  TypedEventFilter<ExtensionInitialisedEvent>;

export interface LogSetAuthorityEventObject {
  authority: string;
}
export type LogSetAuthorityEvent = TypedEvent<
  [string],
  LogSetAuthorityEventObject
>;

export type LogSetAuthorityEventFilter = TypedEventFilter<LogSetAuthorityEvent>;

export interface LogSetOwnerEventObject {
  owner: string;
}
export type LogSetOwnerEvent = TypedEvent<[string], LogSetOwnerEventObject>;

export type LogSetOwnerEventFilter = TypedEventFilter<LogSetOwnerEvent>;

export interface MetaTransactionExecutedEventObject {
  user: string;
  relayerAddress: string;
  functionSignature: string;
}
export type MetaTransactionExecutedEvent = TypedEvent<
  [string, string, string],
  MetaTransactionExecutedEventObject
>;

export type MetaTransactionExecutedEventFilter =
  TypedEventFilter<MetaTransactionExecutedEvent>;

export interface StakeFractionSetEventObject {
  agent: string;
  stakeFraction: BigNumber;
}
export type StakeFractionSetEvent = TypedEvent<
  [string, BigNumber],
  StakeFractionSetEventObject
>;

export type StakeFractionSetEventFilter =
  TypedEventFilter<StakeFractionSetEvent>;

export interface StakeReclaimedEventObject {
  expenditureId: BigNumber;
}
export type StakeReclaimedEvent = TypedEvent<
  [BigNumber],
  StakeReclaimedEventObject
>;

export type StakeReclaimedEventFilter = TypedEventFilter<StakeReclaimedEvent>;

export interface StakedExpenditure extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: StakedExpenditureInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    authority(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getChainId(overrides?: CallOverrides): Promise<[BigNumber]>;

    getColony(overrides?: CallOverrides): Promise<[string]>;

    getDeprecated(overrides?: CallOverrides): Promise<[boolean]>;

    getMetatransactionNonce(
      _user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    multicall(
      data: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns the identifier of the extension
     */
    identifier(
      overrides?: CallOverrides
    ): Promise<[string] & { _identifier: string }>;

    /**
     * Returns the version of the extension
     */
    version(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _version: BigNumber }>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialise the extension
     * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
     */
    initialise(
      _stakeFraction: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets the stake fraction
     * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
     */
    setStakeFraction(
      _stakeFraction: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Make an expenditure by putting up a stake
     * @param _branchMask The branchmask of the proof
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`,
     * @param _domainId The domain where the expenditure belongs
     * @param _key A reputation hash tree key, of the total reputation in _domainId
     * @param _permissionDomainId The domainId in which the extension has the administration permission
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the total reputation in _domainId
     */
    makeExpenditureWithStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _key: BytesLike,
      _value: BytesLike,
      _branchMask: BigNumberish,
      _siblings: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Reclaims the stake if the expenditure is finalized or cancelled
     * @param _expenditureId The id of the expenditure
     */
    reclaimStake(
      _expenditureId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Cancel the expenditure and reclaim the stake in one transactionCan only be called by expenditure owner while expenditure is in draft state
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _expenditureId The id of the expenditure
     * @param _permissionDomainId The domainId in which the extension has the arbitration permission
     */
    cancelAndReclaimStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _expenditureId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Cancel the expenditure and punish the stakerCan only be called by an arbitration user
     * @param _callerChildSkillIndex The index that the `_domainId` is relative to `_callerPermissionDomainId`
     * @param _callerPermissionDomainId The domainId in which the caller has the arbitration permission
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _expenditureId The id of the expenditure
     * @param _permissionDomainId The domainId in which the extension has the arbitration permission
     * @param _punish Whether the staker should be punished by losing an amount of reputation equal to the stake
     */
    cancelAndPunish(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _callerPermissionDomainId: BigNumberish,
      _callerChildSkillIndex: BigNumberish,
      _expenditureId: BigNumberish,
      _punish: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get the stake fraction
     */
    getStakeFraction(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _stakeFraction: BigNumber }>;

    /**
     * Get the stake for an expenditure
     * @param _expenditureId The id of the expenditure to get the stake for
     */
    getStake(
      _expenditureId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [StakedExpenditure.StakeStructOutput] & {
        stake: StakedExpenditure.StakeStructOutput;
      }
    >;
  };

  authority(overrides?: CallOverrides): Promise<string>;

  /**
   * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
   * @param _payload Function call to make via meta transaction
   * @param _sigR R part of the signature
   * @param _sigS S part of the signature
   * @param _sigV V part of the signature
   * @param _user Address of user trying to do meta transaction
   */
  executeMetaTransaction(
    _user: string,
    _payload: BytesLike,
    _sigR: BytesLike,
    _sigS: BytesLike,
    _sigV: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  getCapabilityRoles(
    _sig: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  getChainId(overrides?: CallOverrides): Promise<BigNumber>;

  getColony(overrides?: CallOverrides): Promise<string>;

  getDeprecated(overrides?: CallOverrides): Promise<boolean>;

  getMetatransactionNonce(
    _user: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  multicall(
    data: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  setAuthority(
    authority_: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setOwner(
    owner_: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  verify(
    _owner: string,
    _nonce: BigNumberish,
    _chainId: BigNumberish,
    _payload: BytesLike,
    _sigR: BytesLike,
    _sigS: BytesLike,
    _sigV: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns the identifier of the extension
   */
  identifier(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the version of the extension
   */
  version(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Configures the extension
   * @param _colony The colony in which the extension holds permissions
   */
  install(
    _colony: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called when upgrading the extension
   */
  finishUpgrade(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called when deprecating (or undeprecating) the extension
   * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
   */
  deprecate(
    _deprecated: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called when uninstalling the extension
   */
  uninstall(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialise the extension
   * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
   */
  initialise(
    _stakeFraction: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets the stake fraction
   * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
   */
  setStakeFraction(
    _stakeFraction: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Make an expenditure by putting up a stake
   * @param _branchMask The branchmask of the proof
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`,
   * @param _domainId The domain where the expenditure belongs
   * @param _key A reputation hash tree key, of the total reputation in _domainId
   * @param _permissionDomainId The domainId in which the extension has the administration permission
   * @param _siblings The siblings of the proof
   * @param _value Reputation value indicating the total reputation in _domainId
   */
  makeExpenditureWithStake(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _domainId: BigNumberish,
    _key: BytesLike,
    _value: BytesLike,
    _branchMask: BigNumberish,
    _siblings: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Reclaims the stake if the expenditure is finalized or cancelled
   * @param _expenditureId The id of the expenditure
   */
  reclaimStake(
    _expenditureId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Cancel the expenditure and reclaim the stake in one transactionCan only be called by expenditure owner while expenditure is in draft state
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _expenditureId The id of the expenditure
   * @param _permissionDomainId The domainId in which the extension has the arbitration permission
   */
  cancelAndReclaimStake(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _expenditureId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Cancel the expenditure and punish the stakerCan only be called by an arbitration user
   * @param _callerChildSkillIndex The index that the `_domainId` is relative to `_callerPermissionDomainId`
   * @param _callerPermissionDomainId The domainId in which the caller has the arbitration permission
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _expenditureId The id of the expenditure
   * @param _permissionDomainId The domainId in which the extension has the arbitration permission
   * @param _punish Whether the staker should be punished by losing an amount of reputation equal to the stake
   */
  cancelAndPunish(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _callerPermissionDomainId: BigNumberish,
    _callerChildSkillIndex: BigNumberish,
    _expenditureId: BigNumberish,
    _punish: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get the stake fraction
   */
  getStakeFraction(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the stake for an expenditure
   * @param _expenditureId The id of the expenditure to get the stake for
   */
  getStake(
    _expenditureId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<StakedExpenditure.StakeStructOutput>;

  callStatic: {
    authority(overrides?: CallOverrides): Promise<string>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<string>;

    getDeprecated(overrides?: CallOverrides): Promise<boolean>;

    getMetatransactionNonce(
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    multicall(data: BytesLike[], overrides?: CallOverrides): Promise<string[]>;

    owner(overrides?: CallOverrides): Promise<string>;

    setAuthority(authority_: string, overrides?: CallOverrides): Promise<void>;

    setOwner(owner_: string, overrides?: CallOverrides): Promise<void>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(_colony: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(overrides?: CallOverrides): Promise<void>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(_deprecated: boolean, overrides?: CallOverrides): Promise<void>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialise the extension
     * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
     */
    initialise(
      _stakeFraction: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the stake fraction
     * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
     */
    setStakeFraction(
      _stakeFraction: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Make an expenditure by putting up a stake
     * @param _branchMask The branchmask of the proof
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`,
     * @param _domainId The domain where the expenditure belongs
     * @param _key A reputation hash tree key, of the total reputation in _domainId
     * @param _permissionDomainId The domainId in which the extension has the administration permission
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the total reputation in _domainId
     */
    makeExpenditureWithStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _key: BytesLike,
      _value: BytesLike,
      _branchMask: BigNumberish,
      _siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Reclaims the stake if the expenditure is finalized or cancelled
     * @param _expenditureId The id of the expenditure
     */
    reclaimStake(
      _expenditureId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Cancel the expenditure and reclaim the stake in one transactionCan only be called by expenditure owner while expenditure is in draft state
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _expenditureId The id of the expenditure
     * @param _permissionDomainId The domainId in which the extension has the arbitration permission
     */
    cancelAndReclaimStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _expenditureId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Cancel the expenditure and punish the stakerCan only be called by an arbitration user
     * @param _callerChildSkillIndex The index that the `_domainId` is relative to `_callerPermissionDomainId`
     * @param _callerPermissionDomainId The domainId in which the caller has the arbitration permission
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _expenditureId The id of the expenditure
     * @param _permissionDomainId The domainId in which the extension has the arbitration permission
     * @param _punish Whether the staker should be punished by losing an amount of reputation equal to the stake
     */
    cancelAndPunish(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _callerPermissionDomainId: BigNumberish,
      _callerChildSkillIndex: BigNumberish,
      _expenditureId: BigNumberish,
      _punish: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the stake fraction
     */
    getStakeFraction(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the stake for an expenditure
     * @param _expenditureId The id of the expenditure to get the stake for
     */
    getStake(
      _expenditureId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<StakedExpenditure.StakeStructOutput>;
  };

  filters: {
    "ExpenditureCancelled(address,uint256)"(
      agent?: null,
      expenditureId?: null
    ): ExpenditureCancelledEventFilter;
    ExpenditureCancelled(
      agent?: null,
      expenditureId?: null
    ): ExpenditureCancelledEventFilter;

    "ExpenditureMadeViaStake(address,uint256,uint256)"(
      creator?: string | null,
      expenditureId?: null,
      stake?: null
    ): ExpenditureMadeViaStakeEventFilter;
    ExpenditureMadeViaStake(
      creator?: string | null,
      expenditureId?: null,
      stake?: null
    ): ExpenditureMadeViaStakeEventFilter;

    "ExpenditureStakerPunished(address,uint256,bool)"(
      agent?: null,
      expenditureId?: null,
      punished?: null
    ): ExpenditureStakerPunishedEventFilter;
    ExpenditureStakerPunished(
      agent?: null,
      expenditureId?: null,
      punished?: null
    ): ExpenditureStakerPunishedEventFilter;

    "ExtensionInitialised()"(): ExtensionInitialisedEventFilter;
    ExtensionInitialised(): ExtensionInitialisedEventFilter;

    "LogSetAuthority(address)"(
      authority?: string | null
    ): LogSetAuthorityEventFilter;
    LogSetAuthority(authority?: string | null): LogSetAuthorityEventFilter;

    "LogSetOwner(address)"(owner?: string | null): LogSetOwnerEventFilter;
    LogSetOwner(owner?: string | null): LogSetOwnerEventFilter;

    "MetaTransactionExecuted(address,address,bytes)"(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;
    MetaTransactionExecuted(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;

    "StakeFractionSet(address,uint256)"(
      agent?: null,
      stakeFraction?: null
    ): StakeFractionSetEventFilter;
    StakeFractionSet(
      agent?: null,
      stakeFraction?: null
    ): StakeFractionSetEventFilter;

    "StakeReclaimed(uint256)"(expenditureId?: null): StakeReclaimedEventFilter;
    StakeReclaimed(expenditureId?: null): StakeReclaimedEventFilter;
  };

  estimateGas: {
    authority(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<BigNumber>;

    getDeprecated(overrides?: CallOverrides): Promise<BigNumber>;

    getMetatransactionNonce(
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    multicall(
      data: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Initialise the extension
     * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
     */
    initialise(
      _stakeFraction: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets the stake fraction
     * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
     */
    setStakeFraction(
      _stakeFraction: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Make an expenditure by putting up a stake
     * @param _branchMask The branchmask of the proof
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`,
     * @param _domainId The domain where the expenditure belongs
     * @param _key A reputation hash tree key, of the total reputation in _domainId
     * @param _permissionDomainId The domainId in which the extension has the administration permission
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the total reputation in _domainId
     */
    makeExpenditureWithStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _key: BytesLike,
      _value: BytesLike,
      _branchMask: BigNumberish,
      _siblings: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Reclaims the stake if the expenditure is finalized or cancelled
     * @param _expenditureId The id of the expenditure
     */
    reclaimStake(
      _expenditureId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Cancel the expenditure and reclaim the stake in one transactionCan only be called by expenditure owner while expenditure is in draft state
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _expenditureId The id of the expenditure
     * @param _permissionDomainId The domainId in which the extension has the arbitration permission
     */
    cancelAndReclaimStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _expenditureId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Cancel the expenditure and punish the stakerCan only be called by an arbitration user
     * @param _callerChildSkillIndex The index that the `_domainId` is relative to `_callerPermissionDomainId`
     * @param _callerPermissionDomainId The domainId in which the caller has the arbitration permission
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _expenditureId The id of the expenditure
     * @param _permissionDomainId The domainId in which the extension has the arbitration permission
     * @param _punish Whether the staker should be punished by losing an amount of reputation equal to the stake
     */
    cancelAndPunish(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _callerPermissionDomainId: BigNumberish,
      _callerChildSkillIndex: BigNumberish,
      _expenditureId: BigNumberish,
      _punish: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get the stake fraction
     */
    getStakeFraction(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the stake for an expenditure
     * @param _expenditureId The id of the expenditure to get the stake for
     */
    getStake(
      _expenditureId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getColony(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDeprecated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMetatransactionNonce(
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    multicall(
      data: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialise the extension
     * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
     */
    initialise(
      _stakeFraction: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the stake fraction
     * @param _stakeFraction WAD-denominated fraction, used to determine stake as fraction of rep in domain
     */
    setStakeFraction(
      _stakeFraction: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Make an expenditure by putting up a stake
     * @param _branchMask The branchmask of the proof
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`,
     * @param _domainId The domain where the expenditure belongs
     * @param _key A reputation hash tree key, of the total reputation in _domainId
     * @param _permissionDomainId The domainId in which the extension has the administration permission
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the total reputation in _domainId
     */
    makeExpenditureWithStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _key: BytesLike,
      _value: BytesLike,
      _branchMask: BigNumberish,
      _siblings: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Reclaims the stake if the expenditure is finalized or cancelled
     * @param _expenditureId The id of the expenditure
     */
    reclaimStake(
      _expenditureId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Cancel the expenditure and reclaim the stake in one transactionCan only be called by expenditure owner while expenditure is in draft state
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _expenditureId The id of the expenditure
     * @param _permissionDomainId The domainId in which the extension has the arbitration permission
     */
    cancelAndReclaimStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _expenditureId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Cancel the expenditure and punish the stakerCan only be called by an arbitration user
     * @param _callerChildSkillIndex The index that the `_domainId` is relative to `_callerPermissionDomainId`
     * @param _callerPermissionDomainId The domainId in which the caller has the arbitration permission
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _expenditureId The id of the expenditure
     * @param _permissionDomainId The domainId in which the extension has the arbitration permission
     * @param _punish Whether the staker should be punished by losing an amount of reputation equal to the stake
     */
    cancelAndPunish(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _callerPermissionDomainId: BigNumberish,
      _callerChildSkillIndex: BigNumberish,
      _expenditureId: BigNumberish,
      _punish: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the stake fraction
     */
    getStakeFraction(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the stake for an expenditure
     * @param _expenditureId The id of the expenditure to get the stake for
     */
    getStake(
      _expenditureId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
