/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace ColonyDataTypes {
  export type DomainStruct = {
    skillId: BigNumberish;
    fundingPotId: BigNumberish;
  };

  export type DomainStructOutput = [BigNumber, BigNumber] & {
    skillId: BigNumber;
    fundingPotId: BigNumber;
  };

  export type ExpenditureStruct = {
    status: BigNumberish;
    owner: string;
    fundingPotId: BigNumberish;
    domainId: BigNumberish;
    finalizedTimestamp: BigNumberish;
    globalClaimDelay: BigNumberish;
  };

  export type ExpenditureStructOutput = [
    number,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    status: number;
    owner: string;
    fundingPotId: BigNumber;
    domainId: BigNumber;
    finalizedTimestamp: BigNumber;
    globalClaimDelay: BigNumber;
  };

  export type ExpenditureSlotStruct = {
    recipient: string;
    claimDelay: BigNumberish;
    payoutModifier: BigNumberish;
    skills: BigNumberish[];
  };

  export type ExpenditureSlotStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber[]
  ] & {
    recipient: string;
    claimDelay: BigNumber;
    payoutModifier: BigNumber;
    skills: BigNumber[];
  };

  export type PaymentStruct = {
    recipient: string;
    finalized: boolean;
    fundingPotId: BigNumberish;
    domainId: BigNumberish;
    skills: BigNumberish[];
  };

  export type PaymentStructOutput = [
    string,
    boolean,
    BigNumber,
    BigNumber,
    BigNumber[]
  ] & {
    recipient: string;
    finalized: boolean;
    fundingPotId: BigNumber;
    domainId: BigNumber;
    skills: BigNumber[];
  };

  export type RoleStruct = {
    user: string;
    rateFail: boolean;
    rating: BigNumberish;
  };

  export type RoleStructOutput = [string, boolean, number] & {
    user: string;
    rateFail: boolean;
    rating: number;
  };

  export type RewardPayoutCycleStruct = {
    reputationState: BytesLike;
    colonyWideReputation: BigNumberish;
    totalTokens: BigNumberish;
    amount: BigNumberish;
    tokenAddress: string;
    blockTimestamp: BigNumberish;
    amountRemaining: BigNumberish;
    finalized: boolean;
  };

  export type RewardPayoutCycleStructOutput = [
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    boolean
  ] & {
    reputationState: string;
    colonyWideReputation: BigNumber;
    totalTokens: BigNumber;
    amount: BigNumber;
    tokenAddress: string;
    blockTimestamp: BigNumber;
    amountRemaining: BigNumber;
    finalized: boolean;
  };
}

export interface IColonyInterface extends utils.Interface {
  functions: {
    "approveExitRecovery()": FunctionFragment;
    "checkNotAdditionalProtectedVariable(uint256)": FunctionFragment;
    "enterRecoveryMode()": FunctionFragment;
    "exitRecoveryMode()": FunctionFragment;
    "isInRecoveryMode()": FunctionFragment;
    "numRecoveryRoles()": FunctionFragment;
    "removeRecoveryRole(address)": FunctionFragment;
    "setRecoveryRole(address)": FunctionFragment;
    "setStorageSlotRecovery(uint256,bytes32)": FunctionFragment;
    "authority()": FunctionFragment;
    "owner()": FunctionFragment;
    "version()": FunctionFragment;
    "upgrade(uint256)": FunctionFragment;
    "finishUpgrade()": FunctionFragment;
    "getColonyNetwork()": FunctionFragment;
    "getToken()": FunctionFragment;
    "makeArbitraryTransaction(address,bytes)": FunctionFragment;
    "annotateTransaction(bytes32,string)": FunctionFragment;
    "setRootRole(address,bool)": FunctionFragment;
    "setArbitrationRole(uint256,uint256,address,uint256,bool)": FunctionFragment;
    "setArchitectureRole(uint256,uint256,address,uint256,bool)": FunctionFragment;
    "setFundingRole(uint256,uint256,address,uint256,bool)": FunctionFragment;
    "setAdministrationRole(uint256,uint256,address,uint256,bool)": FunctionFragment;
    "setUserRoles(uint256,uint256,address,uint256,bytes32)": FunctionFragment;
    "hasUserRole(address,uint256,uint8)": FunctionFragment;
    "hasInheritedUserRole(address,uint256,uint8,uint256,uint256)": FunctionFragment;
    "userCanSetRoles(address,uint256,uint256,uint256)": FunctionFragment;
    "getUserRoles(address,uint256)": FunctionFragment;
    "getCapabilityRoles(bytes4)": FunctionFragment;
    "emitDomainReputationReward(uint256,address,int256)": FunctionFragment;
    "emitSkillReputationReward(uint256,address,int256)": FunctionFragment;
    "emitDomainReputationPenalty(uint256,uint256,uint256,address,int256)": FunctionFragment;
    "emitSkillReputationPenalty(uint256,address,int256)": FunctionFragment;
    "initialiseColony(address,address)": FunctionFragment;
    "editColony(string)": FunctionFragment;
    "bootstrapColony(address[],int256[])": FunctionFragment;
    "mintTokens(uint256)": FunctionFragment;
    "mintTokensFor(address,uint256)": FunctionFragment;
    "lockToken()": FunctionFragment;
    "unlockTokenForUser(address,uint256)": FunctionFragment;
    "registerColonyLabel(string,string)": FunctionFragment;
    "updateColonyOrbitDB(string)": FunctionFragment;
    "installExtension(bytes32,uint256)": FunctionFragment;
    "upgradeExtension(bytes32,uint256)": FunctionFragment;
    "deprecateExtension(bytes32,bool)": FunctionFragment;
    "uninstallExtension(bytes32)": FunctionFragment;
    "addDomain(uint256,uint256,uint256)": FunctionFragment;
    "addDomain(uint256,uint256,uint256,string)": FunctionFragment;
    "editDomain(uint256,uint256,uint256,string)": FunctionFragment;
    "getDomain(uint256)": FunctionFragment;
    "getDomainCount()": FunctionFragment;
    "verifyReputationProof(bytes,bytes,uint256,bytes32[])": FunctionFragment;
    "makeExpenditure(uint256,uint256,uint256)": FunctionFragment;
    "transferExpenditure(uint256,address)": FunctionFragment;
    "transferExpenditureViaArbitration(uint256,uint256,uint256,address)": FunctionFragment;
    "cancelExpenditure(uint256)": FunctionFragment;
    "finalizeExpenditure(uint256)": FunctionFragment;
    "setExpenditureRecipient(uint256,uint256,address)": FunctionFragment;
    "setExpenditurePayout(uint256,uint256,address,uint256)": FunctionFragment;
    "setExpenditureSkill(uint256,uint256,uint256)": FunctionFragment;
    "setExpenditurePayoutModifier(uint256,uint256,uint256,uint256,int256)": FunctionFragment;
    "setExpenditureClaimDelay(uint256,uint256,uint256,uint256,uint256)": FunctionFragment;
    "setExpenditureState(uint256,uint256,uint256,uint256,bool[],bytes32[],bytes32)": FunctionFragment;
    "claimExpenditurePayout(uint256,uint256,address)": FunctionFragment;
    "getExpenditureCount()": FunctionFragment;
    "getExpenditure(uint256)": FunctionFragment;
    "getExpenditureSlot(uint256,uint256)": FunctionFragment;
    "getExpenditureSlotPayout(uint256,uint256,address)": FunctionFragment;
    "addPayment(uint256,uint256,address,address,uint256,uint256,uint256)": FunctionFragment;
    "finalizePayment(uint256,uint256,uint256)": FunctionFragment;
    "setPaymentRecipient(uint256,uint256,uint256,address)": FunctionFragment;
    "setPaymentSkill(uint256,uint256,uint256,uint256)": FunctionFragment;
    "setPaymentPayout(uint256,uint256,uint256,address,uint256)": FunctionFragment;
    "getPayment(uint256)": FunctionFragment;
    "claimPayment(uint256,address)": FunctionFragment;
    "getPaymentCount()": FunctionFragment;
    "makeTask(uint256,uint256,bytes32,uint256,uint256,uint256)": FunctionFragment;
    "getTaskCount()": FunctionFragment;
    "getTaskChangeNonce(uint256)": FunctionFragment;
    "executeTaskChange(uint8[],bytes32[],bytes32[],uint8[],uint256,bytes)": FunctionFragment;
    "executeTaskRoleAssignment(uint8[],bytes32[],bytes32[],uint8[],uint256,bytes)": FunctionFragment;
    "submitTaskWorkRating(uint256,uint8,bytes32)": FunctionFragment;
    "revealTaskWorkRating(uint256,uint8,uint8,bytes32)": FunctionFragment;
    "generateSecret(bytes32,uint256)": FunctionFragment;
    "getTaskWorkRatingSecretsInfo(uint256)": FunctionFragment;
    "getTaskWorkRatingSecret(uint256,uint8)": FunctionFragment;
    "setTaskManagerRole(uint256,address,uint256,uint256)": FunctionFragment;
    "setTaskEvaluatorRole(uint256,address)": FunctionFragment;
    "setTaskWorkerRole(uint256,address)": FunctionFragment;
    "removeTaskEvaluatorRole(uint256)": FunctionFragment;
    "removeTaskWorkerRole(uint256)": FunctionFragment;
    "setTaskSkill(uint256,uint256)": FunctionFragment;
    "setTaskBrief(uint256,bytes32)": FunctionFragment;
    "setTaskDueDate(uint256,uint256)": FunctionFragment;
    "submitTaskDeliverable(uint256,bytes32)": FunctionFragment;
    "submitTaskDeliverableAndRating(uint256,bytes32,bytes32)": FunctionFragment;
    "finalizeTask(uint256)": FunctionFragment;
    "cancelTask(uint256)": FunctionFragment;
    "completeTask(uint256)": FunctionFragment;
    "getTask(uint256)": FunctionFragment;
    "getTaskRole(uint256,uint8)": FunctionFragment;
    "setRewardInverse(uint256)": FunctionFragment;
    "getRewardInverse()": FunctionFragment;
    "getTaskPayout(uint256,uint8,address)": FunctionFragment;
    "setTaskManagerPayout(uint256,address,uint256)": FunctionFragment;
    "setTaskEvaluatorPayout(uint256,address,uint256)": FunctionFragment;
    "setTaskWorkerPayout(uint256,address,uint256)": FunctionFragment;
    "setAllTaskPayouts(uint256,address,uint256,uint256,uint256)": FunctionFragment;
    "claimTaskPayout(uint256,uint8,address)": FunctionFragment;
    "startNextRewardPayout(address,bytes,bytes,uint256,bytes32[])": FunctionFragment;
    "claimRewardPayout(uint256,uint256[7],bytes,bytes,uint256,bytes32[])": FunctionFragment;
    "getRewardPayoutInfo(uint256)": FunctionFragment;
    "finalizeRewardPayout(uint256)": FunctionFragment;
    "getFundingPot(uint256)": FunctionFragment;
    "getFundingPotCount()": FunctionFragment;
    "getFundingPotBalance(uint256,address)": FunctionFragment;
    "getFundingPotPayout(uint256,address)": FunctionFragment;
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)": FunctionFragment;
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,address)": FunctionFragment;
    "claimColonyFunds(address)": FunctionFragment;
    "getNonRewardPotsTotal(address)": FunctionFragment;
    "approveStake(address,uint256,uint256)": FunctionFragment;
    "obligateStake(address,uint256,uint256)": FunctionFragment;
    "deobligateStake(address,uint256,uint256)": FunctionFragment;
    "transferStake(uint256,uint256,address,address,uint256,uint256,address)": FunctionFragment;
    "getApproval(address,address,uint256)": FunctionFragment;
    "getObligation(address,address,uint256)": FunctionFragment;
    "getDomainFromFundingPot(uint256)": FunctionFragment;
    "burnTokens(address,uint256)": FunctionFragment;
    "unlockToken()": FunctionFragment;
    "updateApprovalAmount(address,address)": FunctionFragment;
    "getTokenApproval(address,address)": FunctionFragment;
    "getTotalTokenApproval(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "approveExitRecovery"
      | "checkNotAdditionalProtectedVariable"
      | "enterRecoveryMode"
      | "exitRecoveryMode"
      | "isInRecoveryMode"
      | "numRecoveryRoles"
      | "removeRecoveryRole"
      | "setRecoveryRole"
      | "setStorageSlotRecovery"
      | "authority"
      | "owner"
      | "version"
      | "upgrade"
      | "finishUpgrade"
      | "getColonyNetwork"
      | "getToken"
      | "makeArbitraryTransaction"
      | "annotateTransaction"
      | "setRootRole"
      | "setArbitrationRole"
      | "setArchitectureRole"
      | "setFundingRole"
      | "setAdministrationRole"
      | "setUserRoles"
      | "hasUserRole"
      | "hasInheritedUserRole"
      | "userCanSetRoles"
      | "getUserRoles"
      | "getCapabilityRoles"
      | "emitDomainReputationReward"
      | "emitSkillReputationReward"
      | "emitDomainReputationPenalty"
      | "emitSkillReputationPenalty"
      | "initialiseColony"
      | "editColony"
      | "bootstrapColony"
      | "mintTokens"
      | "mintTokensFor"
      | "lockToken"
      | "unlockTokenForUser"
      | "registerColonyLabel"
      | "updateColonyOrbitDB"
      | "installExtension"
      | "upgradeExtension"
      | "deprecateExtension"
      | "uninstallExtension"
      | "addDomain(uint256,uint256,uint256)"
      | "addDomain(uint256,uint256,uint256,string)"
      | "editDomain"
      | "getDomain"
      | "getDomainCount"
      | "verifyReputationProof"
      | "makeExpenditure"
      | "transferExpenditure"
      | "transferExpenditureViaArbitration"
      | "cancelExpenditure"
      | "finalizeExpenditure"
      | "setExpenditureRecipient"
      | "setExpenditurePayout"
      | "setExpenditureSkill"
      | "setExpenditurePayoutModifier"
      | "setExpenditureClaimDelay"
      | "setExpenditureState"
      | "claimExpenditurePayout"
      | "getExpenditureCount"
      | "getExpenditure"
      | "getExpenditureSlot"
      | "getExpenditureSlotPayout"
      | "addPayment"
      | "finalizePayment"
      | "setPaymentRecipient"
      | "setPaymentSkill"
      | "setPaymentPayout"
      | "getPayment"
      | "claimPayment"
      | "getPaymentCount"
      | "makeTask"
      | "getTaskCount"
      | "getTaskChangeNonce"
      | "executeTaskChange"
      | "executeTaskRoleAssignment"
      | "submitTaskWorkRating"
      | "revealTaskWorkRating"
      | "generateSecret"
      | "getTaskWorkRatingSecretsInfo"
      | "getTaskWorkRatingSecret"
      | "setTaskManagerRole"
      | "setTaskEvaluatorRole"
      | "setTaskWorkerRole"
      | "removeTaskEvaluatorRole"
      | "removeTaskWorkerRole"
      | "setTaskSkill"
      | "setTaskBrief"
      | "setTaskDueDate"
      | "submitTaskDeliverable"
      | "submitTaskDeliverableAndRating"
      | "finalizeTask"
      | "cancelTask"
      | "completeTask"
      | "getTask"
      | "getTaskRole"
      | "setRewardInverse"
      | "getRewardInverse"
      | "getTaskPayout"
      | "setTaskManagerPayout"
      | "setTaskEvaluatorPayout"
      | "setTaskWorkerPayout"
      | "setAllTaskPayouts"
      | "claimTaskPayout"
      | "startNextRewardPayout"
      | "claimRewardPayout"
      | "getRewardPayoutInfo"
      | "finalizeRewardPayout"
      | "getFundingPot"
      | "getFundingPotCount"
      | "getFundingPotBalance"
      | "getFundingPotPayout"
      | "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)"
      | "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,address)"
      | "claimColonyFunds"
      | "getNonRewardPotsTotal"
      | "approveStake"
      | "obligateStake"
      | "deobligateStake"
      | "transferStake"
      | "getApproval"
      | "getObligation"
      | "getDomainFromFundingPot"
      | "burnTokens"
      | "unlockToken"
      | "updateApprovalAmount"
      | "getTokenApproval"
      | "getTotalTokenApproval"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "approveExitRecovery",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "checkNotAdditionalProtectedVariable",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "enterRecoveryMode",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "exitRecoveryMode",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "isInRecoveryMode",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "numRecoveryRoles",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "removeRecoveryRole",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setRecoveryRole",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setStorageSlotRecovery",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "upgrade",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "finishUpgrade",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getColonyNetwork",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "makeArbitraryTransaction",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "annotateTransaction",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setRootRole",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setArbitrationRole",
    values: [BigNumberish, BigNumberish, string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setArchitectureRole",
    values: [BigNumberish, BigNumberish, string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setFundingRole",
    values: [BigNumberish, BigNumberish, string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setAdministrationRole",
    values: [BigNumberish, BigNumberish, string, BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "setUserRoles",
    values: [BigNumberish, BigNumberish, string, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "hasUserRole",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "hasInheritedUserRole",
    values: [string, BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "userCanSetRoles",
    values: [string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getUserRoles",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCapabilityRoles",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "emitDomainReputationReward",
    values: [BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "emitSkillReputationReward",
    values: [BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "emitDomainReputationPenalty",
    values: [BigNumberish, BigNumberish, BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "emitSkillReputationPenalty",
    values: [BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "initialiseColony",
    values: [string, string]
  ): string;
  encodeFunctionData(functionFragment: "editColony", values: [string]): string;
  encodeFunctionData(
    functionFragment: "bootstrapColony",
    values: [string[], BigNumberish[]]
  ): string;
  encodeFunctionData(
    functionFragment: "mintTokens",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "mintTokensFor",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(functionFragment: "lockToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "unlockTokenForUser",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "registerColonyLabel",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateColonyOrbitDB",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "installExtension",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeExtension",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deprecateExtension",
    values: [BytesLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "uninstallExtension",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "addDomain(uint256,uint256,uint256)",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "addDomain(uint256,uint256,uint256,string)",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "editDomain",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getDomain",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getDomainCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "verifyReputationProof",
    values: [BytesLike, BytesLike, BigNumberish, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "makeExpenditure",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferExpenditure",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "transferExpenditureViaArbitration",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelExpenditure",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeExpenditure",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpenditureRecipient",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpenditurePayout",
    values: [BigNumberish, BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpenditureSkill",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpenditurePayoutModifier",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpenditureClaimDelay",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setExpenditureState",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      boolean[],
      BytesLike[],
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "claimExpenditurePayout",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getExpenditureCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getExpenditure",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getExpenditureSlot",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getExpenditureSlotPayout",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addPayment",
    values: [
      BigNumberish,
      BigNumberish,
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizePayment",
    values: [BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setPaymentRecipient",
    values: [BigNumberish, BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setPaymentSkill",
    values: [BigNumberish, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setPaymentPayout",
    values: [BigNumberish, BigNumberish, BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPayment",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimPayment",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getPaymentCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "makeTask",
    values: [
      BigNumberish,
      BigNumberish,
      BytesLike,
      BigNumberish,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getTaskCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTaskChangeNonce",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "executeTaskChange",
    values: [
      BigNumberish[],
      BytesLike[],
      BytesLike[],
      BigNumberish[],
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "executeTaskRoleAssignment",
    values: [
      BigNumberish[],
      BytesLike[],
      BytesLike[],
      BigNumberish[],
      BigNumberish,
      BytesLike
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "submitTaskWorkRating",
    values: [BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "revealTaskWorkRating",
    values: [BigNumberish, BigNumberish, BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "generateSecret",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTaskWorkRatingSecretsInfo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTaskWorkRatingSecret",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTaskManagerRole",
    values: [BigNumberish, string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTaskEvaluatorRole",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setTaskWorkerRole",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "removeTaskEvaluatorRole",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "removeTaskWorkerRole",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTaskSkill",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTaskBrief",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setTaskDueDate",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "submitTaskDeliverable",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "submitTaskDeliverableAndRating",
    values: [BigNumberish, BytesLike, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeTask",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelTask",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "completeTask",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTask",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getTaskRole",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setRewardInverse",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getRewardInverse",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTaskPayout",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "setTaskManagerPayout",
    values: [BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTaskEvaluatorPayout",
    values: [BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setTaskWorkerPayout",
    values: [BigNumberish, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setAllTaskPayouts",
    values: [BigNumberish, string, BigNumberish, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimTaskPayout",
    values: [BigNumberish, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "startNextRewardPayout",
    values: [string, BytesLike, BytesLike, BigNumberish, BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "claimRewardPayout",
    values: [
      BigNumberish,
      BigNumberish[],
      BytesLike,
      BytesLike,
      BigNumberish,
      BytesLike[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getRewardPayoutInfo",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "finalizeRewardPayout",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getFundingPot",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getFundingPotCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getFundingPotBalance",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getFundingPotPayout",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,address)",
    values: [
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "claimColonyFunds",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getNonRewardPotsTotal",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "approveStake",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "obligateStake",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deobligateStake",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferStake",
    values: [
      BigNumberish,
      BigNumberish,
      string,
      string,
      BigNumberish,
      BigNumberish,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getApproval",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getObligation",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getDomainFromFundingPot",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "burnTokens",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "unlockToken",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateApprovalAmount",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenApproval",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalTokenApproval",
    values: [string]
  ): string;

  decodeFunctionResult(
    functionFragment: "approveExitRecovery",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkNotAdditionalProtectedVariable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enterRecoveryMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "exitRecoveryMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isInRecoveryMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "numRecoveryRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeRecoveryRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRecoveryRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStorageSlotRecovery",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "upgrade", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finishUpgrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getColonyNetwork",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "makeArbitraryTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "annotateTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRootRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setArbitrationRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setArchitectureRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFundingRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAdministrationRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setUserRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasUserRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "hasInheritedUserRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "userCanSetRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCapabilityRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emitDomainReputationReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emitSkillReputationReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emitDomainReputationPenalty",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "emitSkillReputationPenalty",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initialiseColony",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "editColony", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "bootstrapColony",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "mintTokens", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "mintTokensFor",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "lockToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unlockTokenForUser",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerColonyLabel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateColonyOrbitDB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "installExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deprecateExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uninstallExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addDomain(uint256,uint256,uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addDomain(uint256,uint256,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "editDomain", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getDomain", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDomainCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "verifyReputationProof",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "makeExpenditure",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferExpenditure",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferExpenditureViaArbitration",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelExpenditure",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeExpenditure",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExpenditureRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExpenditurePayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExpenditureSkill",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExpenditurePayoutModifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExpenditureClaimDelay",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setExpenditureState",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimExpenditurePayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExpenditureCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExpenditure",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExpenditureSlot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExpenditureSlotPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addPayment", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finalizePayment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPaymentRecipient",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPaymentSkill",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPaymentPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getPayment", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "claimPayment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPaymentCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "makeTask", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getTaskCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTaskChangeNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTaskChange",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeTaskRoleAssignment",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitTaskWorkRating",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "revealTaskWorkRating",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "generateSecret",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTaskWorkRatingSecretsInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTaskWorkRatingSecret",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTaskManagerRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTaskEvaluatorRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTaskWorkerRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeTaskEvaluatorRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeTaskWorkerRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTaskSkill",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTaskBrief",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTaskDueDate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitTaskDeliverable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "submitTaskDeliverableAndRating",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeTask",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "cancelTask", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "completeTask",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getTask", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getTaskRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRewardInverse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRewardInverse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTaskPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTaskManagerPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTaskEvaluatorPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTaskWorkerPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setAllTaskPayouts",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimTaskPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startNextRewardPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimRewardPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getRewardPayoutInfo",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "finalizeRewardPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFundingPot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFundingPotCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFundingPotBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFundingPotPayout",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimColonyFunds",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getNonRewardPotsTotal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "approveStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "obligateStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deobligateStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getObligation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDomainFromFundingPot",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "burnTokens", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "unlockToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateApprovalAmount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenApproval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalTokenApproval",
    data: BytesLike
  ): Result;

  events: {
    "Annotation(address,bytes32,string)": EventFragment;
    "ColonyBootstrapped(address,address[],int256[])": EventFragment;
    "ColonyFundsClaimed(address,address,uint256,uint256)": EventFragment;
    "ColonyFundsMovedBetweenFundingPots(address,uint256,uint256,uint256,address)": EventFragment;
    "ColonyInitialised(address,address,address)": EventFragment;
    "ColonyMetadata(address,string)": EventFragment;
    "ColonyRewardInverseSet(address,uint256)": EventFragment;
    "ColonyRoleSet(address,address,uint256,uint8,bool)": EventFragment;
    "ColonyUpgraded(address,uint256,uint256)": EventFragment;
    "DomainAdded(address,uint256)": EventFragment;
    "DomainMetadata(address,uint256,string)": EventFragment;
    "ExpenditureAdded(address,uint256)": EventFragment;
    "ExpenditureCancelled(address,uint256)": EventFragment;
    "ExpenditureFinalized(address,uint256)": EventFragment;
    "ExpenditurePayoutSet(address,uint256,uint256,address,uint256)": EventFragment;
    "ExpenditureRecipientSet(address,uint256,uint256,address)": EventFragment;
    "ExpenditureSkillSet(address,uint256,uint256,uint256)": EventFragment;
    "ExpenditureTransferred(address,uint256,address)": EventFragment;
    "FundingPotAdded(uint256)": EventFragment;
    "PaymentAdded(address,uint256)": EventFragment;
    "PaymentFinalized(address,uint256)": EventFragment;
    "PaymentPayoutSet(address,uint256,address,uint256)": EventFragment;
    "PaymentRecipientSet(address,uint256,address)": EventFragment;
    "PaymentSkillSet(address,uint256,uint256)": EventFragment;
    "PayoutClaimed(address,uint256,address,uint256)": EventFragment;
    "RecoveryModeEntered(address)": EventFragment;
    "RecoveryModeExitApproved(address)": EventFragment;
    "RecoveryModeExited(address)": EventFragment;
    "RecoveryRoleSet(address,bool)": EventFragment;
    "RecoveryStorageSlotSet(address,uint256,bytes32,bytes32)": EventFragment;
    "RewardPayoutClaimed(uint256,address,uint256,uint256)": EventFragment;
    "RewardPayoutCycleEnded(address,uint256)": EventFragment;
    "RewardPayoutCycleStarted(address,uint256)": EventFragment;
    "TaskAdded(address,uint256)": EventFragment;
    "TaskBriefSet(uint256,bytes32)": EventFragment;
    "TaskCanceled(uint256)": EventFragment;
    "TaskChangedViaSignatures(address[])": EventFragment;
    "TaskCompleted(address,uint256)": EventFragment;
    "TaskDeliverableSubmitted(address,uint256,bytes32)": EventFragment;
    "TaskDueDateSet(uint256,uint256)": EventFragment;
    "TaskFinalized(address,uint256)": EventFragment;
    "TaskPayoutSet(uint256,uint8,address,uint256)": EventFragment;
    "TaskRoleUserSet(uint256,uint8,address)": EventFragment;
    "TaskSkillSet(uint256,uint256)": EventFragment;
    "TaskWorkRatingRevealed(address,uint256,uint8,uint8)": EventFragment;
    "TokenUnlocked()": EventFragment;
    "TokensBurned(address,address,uint256)": EventFragment;
    "TokensMinted(address,address,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "Annotation"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyBootstrapped"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyFundsClaimed"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ColonyFundsMovedBetweenFundingPots"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyInitialised"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyMetadata"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyRewardInverseSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyRoleSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DomainAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "DomainMetadata"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExpenditureAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExpenditureCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExpenditureFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExpenditurePayoutSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExpenditureRecipientSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExpenditureSkillSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExpenditureTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "FundingPotAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PaymentAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PaymentFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PaymentPayoutSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PaymentRecipientSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PaymentSkillSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PayoutClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryModeEntered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryModeExitApproved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryModeExited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryRoleSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryStorageSlotSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RewardPayoutClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RewardPayoutCycleEnded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RewardPayoutCycleStarted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskBriefSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskCanceled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskChangedViaSignatures"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskCompleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskDeliverableSubmitted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskDueDateSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskFinalized"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskPayoutSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskRoleUserSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskSkillSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TaskWorkRatingRevealed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenUnlocked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensBurned"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensMinted"): EventFragment;
}

export interface AnnotationEventObject {
  agent: string;
  txHash: string;
  metadata: string;
}
export type AnnotationEvent = TypedEvent<
  [string, string, string],
  AnnotationEventObject
>;

export type AnnotationEventFilter = TypedEventFilter<AnnotationEvent>;

export interface ColonyBootstrappedEventObject {
  agent: string;
  users: string[];
  amounts: BigNumber[];
}
export type ColonyBootstrappedEvent = TypedEvent<
  [string, string[], BigNumber[]],
  ColonyBootstrappedEventObject
>;

export type ColonyBootstrappedEventFilter =
  TypedEventFilter<ColonyBootstrappedEvent>;

export interface ColonyFundsClaimedEventObject {
  agent: string;
  token: string;
  fee: BigNumber;
  payoutRemainder: BigNumber;
}
export type ColonyFundsClaimedEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  ColonyFundsClaimedEventObject
>;

export type ColonyFundsClaimedEventFilter =
  TypedEventFilter<ColonyFundsClaimedEvent>;

export interface ColonyFundsMovedBetweenFundingPotsEventObject {
  agent: string;
  fromPot: BigNumber;
  toPot: BigNumber;
  amount: BigNumber;
  token: string;
}
export type ColonyFundsMovedBetweenFundingPotsEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber, string],
  ColonyFundsMovedBetweenFundingPotsEventObject
>;

export type ColonyFundsMovedBetweenFundingPotsEventFilter =
  TypedEventFilter<ColonyFundsMovedBetweenFundingPotsEvent>;

export interface ColonyInitialisedEventObject {
  agent: string;
  colonyNetwork: string;
  token: string;
}
export type ColonyInitialisedEvent = TypedEvent<
  [string, string, string],
  ColonyInitialisedEventObject
>;

export type ColonyInitialisedEventFilter =
  TypedEventFilter<ColonyInitialisedEvent>;

export interface ColonyMetadataEventObject {
  agent: string;
  metadata: string;
}
export type ColonyMetadataEvent = TypedEvent<
  [string, string],
  ColonyMetadataEventObject
>;

export type ColonyMetadataEventFilter = TypedEventFilter<ColonyMetadataEvent>;

export interface ColonyRewardInverseSetEventObject {
  agent: string;
  rewardInverse: BigNumber;
}
export type ColonyRewardInverseSetEvent = TypedEvent<
  [string, BigNumber],
  ColonyRewardInverseSetEventObject
>;

export type ColonyRewardInverseSetEventFilter =
  TypedEventFilter<ColonyRewardInverseSetEvent>;

export interface ColonyRoleSetEventObject {
  agent: string;
  user: string;
  domainId: BigNumber;
  role: number;
  setTo: boolean;
}
export type ColonyRoleSetEvent = TypedEvent<
  [string, string, BigNumber, number, boolean],
  ColonyRoleSetEventObject
>;

export type ColonyRoleSetEventFilter = TypedEventFilter<ColonyRoleSetEvent>;

export interface ColonyUpgradedEventObject {
  agent: string;
  oldVersion: BigNumber;
  newVersion: BigNumber;
}
export type ColonyUpgradedEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  ColonyUpgradedEventObject
>;

export type ColonyUpgradedEventFilter = TypedEventFilter<ColonyUpgradedEvent>;

export interface DomainAddedEventObject {
  agent: string;
  domainId: BigNumber;
}
export type DomainAddedEvent = TypedEvent<
  [string, BigNumber],
  DomainAddedEventObject
>;

export type DomainAddedEventFilter = TypedEventFilter<DomainAddedEvent>;

export interface DomainMetadataEventObject {
  agent: string;
  domainId: BigNumber;
  metadata: string;
}
export type DomainMetadataEvent = TypedEvent<
  [string, BigNumber, string],
  DomainMetadataEventObject
>;

export type DomainMetadataEventFilter = TypedEventFilter<DomainMetadataEvent>;

export interface ExpenditureAddedEventObject {
  agent: string;
  expenditureId: BigNumber;
}
export type ExpenditureAddedEvent = TypedEvent<
  [string, BigNumber],
  ExpenditureAddedEventObject
>;

export type ExpenditureAddedEventFilter =
  TypedEventFilter<ExpenditureAddedEvent>;

export interface ExpenditureCancelledEventObject {
  agent: string;
  expenditureId: BigNumber;
}
export type ExpenditureCancelledEvent = TypedEvent<
  [string, BigNumber],
  ExpenditureCancelledEventObject
>;

export type ExpenditureCancelledEventFilter =
  TypedEventFilter<ExpenditureCancelledEvent>;

export interface ExpenditureFinalizedEventObject {
  agent: string;
  expenditureId: BigNumber;
}
export type ExpenditureFinalizedEvent = TypedEvent<
  [string, BigNumber],
  ExpenditureFinalizedEventObject
>;

export type ExpenditureFinalizedEventFilter =
  TypedEventFilter<ExpenditureFinalizedEvent>;

export interface ExpenditurePayoutSetEventObject {
  agent: string;
  expenditureId: BigNumber;
  slot: BigNumber;
  token: string;
  amount: BigNumber;
}
export type ExpenditurePayoutSetEvent = TypedEvent<
  [string, BigNumber, BigNumber, string, BigNumber],
  ExpenditurePayoutSetEventObject
>;

export type ExpenditurePayoutSetEventFilter =
  TypedEventFilter<ExpenditurePayoutSetEvent>;

export interface ExpenditureRecipientSetEventObject {
  agent: string;
  expenditureId: BigNumber;
  slot: BigNumber;
  recipient: string;
}
export type ExpenditureRecipientSetEvent = TypedEvent<
  [string, BigNumber, BigNumber, string],
  ExpenditureRecipientSetEventObject
>;

export type ExpenditureRecipientSetEventFilter =
  TypedEventFilter<ExpenditureRecipientSetEvent>;

export interface ExpenditureSkillSetEventObject {
  agent: string;
  expenditureId: BigNumber;
  slot: BigNumber;
  skillId: BigNumber;
}
export type ExpenditureSkillSetEvent = TypedEvent<
  [string, BigNumber, BigNumber, BigNumber],
  ExpenditureSkillSetEventObject
>;

export type ExpenditureSkillSetEventFilter =
  TypedEventFilter<ExpenditureSkillSetEvent>;

export interface ExpenditureTransferredEventObject {
  agent: string;
  expenditureId: BigNumber;
  owner: string;
}
export type ExpenditureTransferredEvent = TypedEvent<
  [string, BigNumber, string],
  ExpenditureTransferredEventObject
>;

export type ExpenditureTransferredEventFilter =
  TypedEventFilter<ExpenditureTransferredEvent>;

export interface FundingPotAddedEventObject {
  fundingPotId: BigNumber;
}
export type FundingPotAddedEvent = TypedEvent<
  [BigNumber],
  FundingPotAddedEventObject
>;

export type FundingPotAddedEventFilter = TypedEventFilter<FundingPotAddedEvent>;

export interface PaymentAddedEventObject {
  agent: string;
  paymentId: BigNumber;
}
export type PaymentAddedEvent = TypedEvent<
  [string, BigNumber],
  PaymentAddedEventObject
>;

export type PaymentAddedEventFilter = TypedEventFilter<PaymentAddedEvent>;

export interface PaymentFinalizedEventObject {
  agent: string;
  paymentId: BigNumber;
}
export type PaymentFinalizedEvent = TypedEvent<
  [string, BigNumber],
  PaymentFinalizedEventObject
>;

export type PaymentFinalizedEventFilter =
  TypedEventFilter<PaymentFinalizedEvent>;

export interface PaymentPayoutSetEventObject {
  agent: string;
  paymentId: BigNumber;
  token: string;
  amount: BigNumber;
}
export type PaymentPayoutSetEvent = TypedEvent<
  [string, BigNumber, string, BigNumber],
  PaymentPayoutSetEventObject
>;

export type PaymentPayoutSetEventFilter =
  TypedEventFilter<PaymentPayoutSetEvent>;

export interface PaymentRecipientSetEventObject {
  agent: string;
  paymentId: BigNumber;
  recipient: string;
}
export type PaymentRecipientSetEvent = TypedEvent<
  [string, BigNumber, string],
  PaymentRecipientSetEventObject
>;

export type PaymentRecipientSetEventFilter =
  TypedEventFilter<PaymentRecipientSetEvent>;

export interface PaymentSkillSetEventObject {
  agent: string;
  paymentId: BigNumber;
  skillId: BigNumber;
}
export type PaymentSkillSetEvent = TypedEvent<
  [string, BigNumber, BigNumber],
  PaymentSkillSetEventObject
>;

export type PaymentSkillSetEventFilter = TypedEventFilter<PaymentSkillSetEvent>;

export interface PayoutClaimedEventObject {
  agent: string;
  fundingPotId: BigNumber;
  token: string;
  amount: BigNumber;
}
export type PayoutClaimedEvent = TypedEvent<
  [string, BigNumber, string, BigNumber],
  PayoutClaimedEventObject
>;

export type PayoutClaimedEventFilter = TypedEventFilter<PayoutClaimedEvent>;

export interface RecoveryModeEnteredEventObject {
  user: string;
}
export type RecoveryModeEnteredEvent = TypedEvent<
  [string],
  RecoveryModeEnteredEventObject
>;

export type RecoveryModeEnteredEventFilter =
  TypedEventFilter<RecoveryModeEnteredEvent>;

export interface RecoveryModeExitApprovedEventObject {
  user: string;
}
export type RecoveryModeExitApprovedEvent = TypedEvent<
  [string],
  RecoveryModeExitApprovedEventObject
>;

export type RecoveryModeExitApprovedEventFilter =
  TypedEventFilter<RecoveryModeExitApprovedEvent>;

export interface RecoveryModeExitedEventObject {
  user: string;
}
export type RecoveryModeExitedEvent = TypedEvent<
  [string],
  RecoveryModeExitedEventObject
>;

export type RecoveryModeExitedEventFilter =
  TypedEventFilter<RecoveryModeExitedEvent>;

export interface RecoveryRoleSetEventObject {
  user: string;
  setTo: boolean;
}
export type RecoveryRoleSetEvent = TypedEvent<
  [string, boolean],
  RecoveryRoleSetEventObject
>;

export type RecoveryRoleSetEventFilter = TypedEventFilter<RecoveryRoleSetEvent>;

export interface RecoveryStorageSlotSetEventObject {
  user: string;
  slot: BigNumber;
  fromValue: string;
  toValue: string;
}
export type RecoveryStorageSlotSetEvent = TypedEvent<
  [string, BigNumber, string, string],
  RecoveryStorageSlotSetEventObject
>;

export type RecoveryStorageSlotSetEventFilter =
  TypedEventFilter<RecoveryStorageSlotSetEvent>;

export interface RewardPayoutClaimedEventObject {
  rewardPayoutId: BigNumber;
  user: string;
  fee: BigNumber;
  rewardRemainder: BigNumber;
}
export type RewardPayoutClaimedEvent = TypedEvent<
  [BigNumber, string, BigNumber, BigNumber],
  RewardPayoutClaimedEventObject
>;

export type RewardPayoutClaimedEventFilter =
  TypedEventFilter<RewardPayoutClaimedEvent>;

export interface RewardPayoutCycleEndedEventObject {
  agent: string;
  rewardPayoutId: BigNumber;
}
export type RewardPayoutCycleEndedEvent = TypedEvent<
  [string, BigNumber],
  RewardPayoutCycleEndedEventObject
>;

export type RewardPayoutCycleEndedEventFilter =
  TypedEventFilter<RewardPayoutCycleEndedEvent>;

export interface RewardPayoutCycleStartedEventObject {
  agent: string;
  rewardPayoutId: BigNumber;
}
export type RewardPayoutCycleStartedEvent = TypedEvent<
  [string, BigNumber],
  RewardPayoutCycleStartedEventObject
>;

export type RewardPayoutCycleStartedEventFilter =
  TypedEventFilter<RewardPayoutCycleStartedEvent>;

export interface TaskAddedEventObject {
  agent: string;
  taskId: BigNumber;
}
export type TaskAddedEvent = TypedEvent<
  [string, BigNumber],
  TaskAddedEventObject
>;

export type TaskAddedEventFilter = TypedEventFilter<TaskAddedEvent>;

export interface TaskBriefSetEventObject {
  taskId: BigNumber;
  specificationHash: string;
}
export type TaskBriefSetEvent = TypedEvent<
  [BigNumber, string],
  TaskBriefSetEventObject
>;

export type TaskBriefSetEventFilter = TypedEventFilter<TaskBriefSetEvent>;

export interface TaskCanceledEventObject {
  taskId: BigNumber;
}
export type TaskCanceledEvent = TypedEvent<
  [BigNumber],
  TaskCanceledEventObject
>;

export type TaskCanceledEventFilter = TypedEventFilter<TaskCanceledEvent>;

export interface TaskChangedViaSignaturesEventObject {
  reviewerAddresses: string[];
}
export type TaskChangedViaSignaturesEvent = TypedEvent<
  [string[]],
  TaskChangedViaSignaturesEventObject
>;

export type TaskChangedViaSignaturesEventFilter =
  TypedEventFilter<TaskChangedViaSignaturesEvent>;

export interface TaskCompletedEventObject {
  agent: string;
  taskId: BigNumber;
}
export type TaskCompletedEvent = TypedEvent<
  [string, BigNumber],
  TaskCompletedEventObject
>;

export type TaskCompletedEventFilter = TypedEventFilter<TaskCompletedEvent>;

export interface TaskDeliverableSubmittedEventObject {
  agent: string;
  taskId: BigNumber;
  deliverableHash: string;
}
export type TaskDeliverableSubmittedEvent = TypedEvent<
  [string, BigNumber, string],
  TaskDeliverableSubmittedEventObject
>;

export type TaskDeliverableSubmittedEventFilter =
  TypedEventFilter<TaskDeliverableSubmittedEvent>;

export interface TaskDueDateSetEventObject {
  taskId: BigNumber;
  dueDate: BigNumber;
}
export type TaskDueDateSetEvent = TypedEvent<
  [BigNumber, BigNumber],
  TaskDueDateSetEventObject
>;

export type TaskDueDateSetEventFilter = TypedEventFilter<TaskDueDateSetEvent>;

export interface TaskFinalizedEventObject {
  agent: string;
  taskId: BigNumber;
}
export type TaskFinalizedEvent = TypedEvent<
  [string, BigNumber],
  TaskFinalizedEventObject
>;

export type TaskFinalizedEventFilter = TypedEventFilter<TaskFinalizedEvent>;

export interface TaskPayoutSetEventObject {
  taskId: BigNumber;
  role: number;
  token: string;
  amount: BigNumber;
}
export type TaskPayoutSetEvent = TypedEvent<
  [BigNumber, number, string, BigNumber],
  TaskPayoutSetEventObject
>;

export type TaskPayoutSetEventFilter = TypedEventFilter<TaskPayoutSetEvent>;

export interface TaskRoleUserSetEventObject {
  taskId: BigNumber;
  role: number;
  user: string;
}
export type TaskRoleUserSetEvent = TypedEvent<
  [BigNumber, number, string],
  TaskRoleUserSetEventObject
>;

export type TaskRoleUserSetEventFilter = TypedEventFilter<TaskRoleUserSetEvent>;

export interface TaskSkillSetEventObject {
  taskId: BigNumber;
  skillId: BigNumber;
}
export type TaskSkillSetEvent = TypedEvent<
  [BigNumber, BigNumber],
  TaskSkillSetEventObject
>;

export type TaskSkillSetEventFilter = TypedEventFilter<TaskSkillSetEvent>;

export interface TaskWorkRatingRevealedEventObject {
  agent: string;
  taskId: BigNumber;
  role: number;
  rating: number;
}
export type TaskWorkRatingRevealedEvent = TypedEvent<
  [string, BigNumber, number, number],
  TaskWorkRatingRevealedEventObject
>;

export type TaskWorkRatingRevealedEventFilter =
  TypedEventFilter<TaskWorkRatingRevealedEvent>;

export interface TokenUnlockedEventObject {}
export type TokenUnlockedEvent = TypedEvent<[], TokenUnlockedEventObject>;

export type TokenUnlockedEventFilter = TypedEventFilter<TokenUnlockedEvent>;

export interface TokensBurnedEventObject {
  agent: string;
  token: string;
  amount: BigNumber;
}
export type TokensBurnedEvent = TypedEvent<
  [string, string, BigNumber],
  TokensBurnedEventObject
>;

export type TokensBurnedEventFilter = TypedEventFilter<TokensBurnedEvent>;

export interface TokensMintedEventObject {
  agent: string;
  who: string;
  amount: BigNumber;
}
export type TokensMintedEvent = TypedEvent<
  [string, string, BigNumber],
  TokensMintedEventObject
>;

export type TokensMintedEventFilter = TypedEventFilter<TokensMintedEvent>;

export interface IColony extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IColonyInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(
      overrides?: CallOverrides
    ): Promise<[boolean] & { inRecoveryMode: boolean }>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { numRoles: BigNumber }>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the `ColonyAuthority` for the colony.
     */
    authority(
      overrides?: CallOverrides
    ): Promise<[string] & { colonyAuthority: string }>;

    /**
     * Used for testing.
     * Get the colony `owner` address. This should be address(0x0) at all times.
     */
    owner(
      overrides?: CallOverrides
    ): Promise<[string] & { colonyOwner: string }>;

    /**
     * Get the Colony contract version. Starts from 1 and is incremented with every deployed contract change.
     */
    version(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { colonyVersion: BigNumber }>;

    /**
     * Downgrades are not allowed, i.e. `_newVersion` should be higher than the currect colony version.
     * Upgrades a colony to a new Colony contract version `_newVersion`.
     * @param _newVersion The target version for the upgrade
     */
    upgrade(
      _newVersion: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Can only be called by the colony itself, and only expected to be called as part of the `upgrade()` call. Required to be external so it can be an external call.
     * A function to be called after an upgrade has been done from v2 to v3.
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * The colonyNetworkAddress we read here is set once, during `initialiseColony`.
     * Returns the colony network address set on the Colony.
     */
    getColonyNetwork(
      overrides?: CallOverrides
    ): Promise<[string] & { colonyNetwork: string }>;

    /**
     * Get the colony token.
     */
    getToken(
      overrides?: CallOverrides
    ): Promise<[string] & { tokenAddress: string }>;

    /**
     * Execute arbitrary transaction on behalf of the Colony
     * @param _action Bytes array encoding the function call and arguments
     * @param _to Contract to receive the function call (cannot be network or token locking)
     */
    makeArbitraryTransaction(
      _to: string,
      _action: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Emit a metadata string for a transaction
     * @param _metadata String of metadata for tx
     * @param _txHash Hash of transaction being annotated (0x0 for current tx)
     */
    annotateTransaction(
      _txHash: BytesLike,
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set new colony root role. Can be called by root role only.
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an root role to
     */
    setRootRole(
      _user: string,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set new colony arbitration role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an arbitration role to
     */
    setArbitrationRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set new colony architecture role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an architecture role to
     */
    setArchitectureRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set new colony funding role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an funding role to
     */
    setFundingRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set new colony admin role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an admin role to
     */
    setAdministrationRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set several roles in one transaction. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _roles Byte array representing the desired role setting (1 for on, 0 for off)
     * @param _user User we want to give a role to
     */
    setUserRoles(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _roles: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Check whether a given user has a given role for the colony. Calls the function of the same name on the colony's authority contract.
     * @param _domainId The domain where we want to check for the role
     * @param _role The role we want to check for
     * @param _user The user whose role we want to check
     */
    hasUserRole(
      _user: string,
      _domainId: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { hasRole: boolean }>;

    /**
     * Check whether a given user has a given role for the colony, in a child domain. Calls the function of the same name on the colony's authority contract and an internal inheritence validator function
     * @param _childDomainId The domain where we want to use the role
     * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
     * @param _domainId Domain in which the caller has the role
     * @param _role The role we want to check for
     * @param _user The user whose role we want to check
     */
    hasInheritedUserRole(
      _user: string,
      _domainId: BigNumberish,
      _role: BigNumberish,
      _childSkillIndex: BigNumberish,
      _childDomainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { hasRole: boolean }>;

    /**
     * Check whether a given user can modify roles in the target domain `_childDomainId`. Mostly a convenience function to provide a uniform interface for extension contracts validating permissions
     * @param _childDomainId The domain where we want to edit roles
     * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
     * @param _domainId Domain in which the caller has the role (currently Root or Architecture)
     * @param _user The user whose permissions we want to check
     */
    userCanSetRoles(
      _user: string,
      _domainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _childDomainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean] & { canSet: boolean }>;

    /**
     * Gets the bytes32 representation of the roles for a user in a given domain
     * @param _domain The domain we want to get roles in
     * @param _user The user whose roles we want to get
     */
    getUserRoles(
      _user: string,
      _domain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { roles: string }>;

    /**
     * Gets the bytes32 representation of the roles authorized to call a function
     * @param _sig The function signature
     */
    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { roles: string }>;

    /**
     * Emit a positive domain reputation update. Available only to Root role holders
     * @param _amount The (positive) amount of reputation to gain
     * @param _domainId The domain where the user will gain reputation
     * @param _user The user who will gain reputation
     */
    emitDomainReputationReward(
      _domainId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Emit a positive skill reputation update. Available only to Root role holders
     * @param _amount The (positive) amount of reputation to gain
     * @param _skillId The skill where the user will gain reputation
     * @param _user The user who will gain reputation
     */
    emitSkillReputationReward(
      _skillId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Emit a negative domain reputation update. Available only to Arbitration role holders
     * @param _amount The (negative) amount of reputation to lose
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId The domain where the user will lose reputation
     * @param _permissionDomainId The domainId in which I hold the Arbitration role
     * @param _user The user who will lose reputation
     */
    emitDomainReputationPenalty(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Emit a negative skill reputation update. Available only to Arbitration role holders in the root domain
     * @param _amount The (negative) amount of reputation to lose
     * @param _skillId The skill where the user will lose reputation
     * @param _user The user who will lose reputation
     */
    emitSkillReputationPenalty(
      _skillId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets the reward inverse to the uint max 2**256 - 1.
     * Called once when the colony is created to initialise certain storage slot values.
     * @param _colonyNetworkAddress Address of the colony network
     * @param _token Address of the colony ERC20 Token
     */
    initialiseColony(
      _colonyNetworkAddress: string,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called to change the metadata associated with a colony. Expected to be a IPFS hash of a JSON blob, but not enforced to any degree by the contracts
     * @param _metadata IPFS hash of the metadata
     */
    editColony(
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Only allowed to be called when `taskCount` is `0` by authorized addresses.
     * Allows the colony to bootstrap itself by having initial reputation and token `_amount` assigned to `_users`. This reputation is assigned in the colony-wide domain. Secured function to authorised members.
     * @param _amount Amount of reputation/tokens for every address
     * @param _users Array of address to bootstrap with reputation
     */
    bootstrapColony(
      _users: string[],
      _amount: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Mint `_wad` amount of colony tokens. Secured function to authorised members.
     * @param _wad Amount to mint
     */
    mintTokens(
      _wad: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Mint `_wad` amount of colony tokens and send to `_guy`. Secured function to authorised members.
     * @param _guy Recipient of new tokens
     * @param _wad Amount to mint
     */
    mintTokensFor(
      _guy: string,
      _wad: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Lock the colony's token. Can only be called by a network-managed extension.
     */
    lockToken(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Unlock the colony's token for a user. Can only be called by a network-managed extension.
     * @param lockId The specific lock to unlock
     * @param user The user to unlock
     */
    unlockTokenForUser(
      user: string,
      lockId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Register colony's ENS label.
     * @param colonyName The label to register.
     * @param orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      colonyName: string,
      orbitdb: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      orbitdb: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Install an extension to the colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version The new extension version to install
     */
    installExtension(
      extensionId: BytesLike,
      version: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade an extension in a colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param newVersion The version to upgrade to (must be one larger than the current version)
     */
    upgradeExtension(
      extensionId: BytesLike,
      newVersion: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set the deprecation of an extension in a colony. Secured function to authorised members.
     * @param deprecated Whether to deprecate the extension or not
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      extensionId: BytesLike,
      deprecated: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * This is a permanent action -- re-installing the extension will deploy a new contractIt is recommended to deprecate an extension before uninstalling to allow active objects to be resolved
     * Uninstall an extension from a colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      extensionId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _parentDomainId Id of the domain under which the new one will be added
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    "addDomain(uint256,uint256,uint256)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _parentDomainId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.We expect this function to only be used by the dapp
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
     * @param _parentDomainId Id of the domain under which the new one will be added
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    "addDomain(uint256,uint256,uint256,string)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _parentDomainId: BigNumberish,
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Id of the domain being edited
     * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    editDomain(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get a domain by id.
     * @param _id Id of the domain which details to get
     */
    getDomain(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [ColonyDataTypes.DomainStructOutput] & {
        domain: ColonyDataTypes.DomainStructOutput;
      }
    >;

    /**
     * Get the number of domains in the colony.
     */
    getDomainCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count: BigNumber }>;

    /**
     * For more detail about branchMask and siblings, examine the PatriciaTree implementation. While external, likely only to be used by the Colony contracts, as it checks that the user is proving their own reputation in the current colony. The `verifyProof` function can be used to verify any proof, though this function is not currently exposed on the Colony's EtherRouter.
     * Helper function that can be used by a client to verify the correctness of a patricia proof they have been supplied with.
     * @param branchMask The branchmask of the proof
     * @param key The key of the element the proof is for.
     * @param siblings The siblings of the proof
     * @param value The value of the element that the proof is for.
     */
    verifyReputationProof(
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<[boolean] & { isValid: boolean }>;

    /**
     * Add a new expenditure in the colony. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _domainId The domain where the expenditure belongs
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    makeExpenditure(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Updates the expenditure owner. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     * @param _newOwner New owner of expenditure
     */
    transferExpenditure(
      _id: BigNumberish,
      _newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future version
     * DEPRECATED Updates the expenditure owner. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _newOwner New owner of expenditure
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    transferExpenditureViaArbitration(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Cancels the expenditure and prevents further editing. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     */
    cancelExpenditure(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Finalizes the expenditure and prevents further editing. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     */
    finalizeExpenditure(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets the recipient on an expenditure slot. Can only be called by expenditure owner.
     * @param _id Id of the expenditure
     * @param _recipient Address of the recipient
     * @param _slot Slot for the recipient address
     */
    setExpenditureRecipient(
      _id: BigNumberish,
      _slot: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set the token payout on an expenditure slot. Can only be called by expenditure owner.
     * @param _amount Payout amount
     * @param _id Id of the expenditure
     * @param _slot Number of the slot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setExpenditurePayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets the skill on an expenditure slot. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     * @param _skillId Id of the new skill to set
     * @param _slot Number of the slot
     */
    setExpenditureSkill(
      _id: BigNumberish,
      _slot: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionNote that when determining payouts the payoutModifier is incremented by WAD and converted into payoutScalar
     * DEPRECATED Set the payout modifier on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _payoutModifier Modifier to their payout (between -1 and 1, denominated in WADs, 0 means no modification)
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _slot Number of the slot
     */
    setExpenditurePayoutModifier(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _slot: BigNumberish,
      _payoutModifier: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future version
     * DEPRECATED Set the claim delay on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _claimDelay Time (in seconds) to delay claiming payout after finalization
     * @param _id Expenditure identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _slot Number of the slot
     */
    setExpenditureClaimDelay(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _slot: BigNumberish,
      _claimDelay: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set arbitrary state on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _keys Array of additional keys (for mappings & arrays)
     * @param _mask Array of booleans indicated whether a key is a mapping (F) or an array index (T).
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _storageSlot Number of the top-level storage slot (25, 26, or 27)
     * @param _value Value to set at location
     */
    setExpenditureState(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _storageSlot: BigNumberish,
      _mask: boolean[],
      _keys: BytesLike[],
      _value: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Claim the payout for an expenditure slot. Here the network receives a fee from each payout.
     * @param _id Expenditure identifier
     * @param _slot Number of the slot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimExpenditurePayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the number of expenditures in the colony.
     */
    getExpenditureCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count: BigNumber }>;

    /**
     * Returns an existing expenditure.
     * @param _id Expenditure identifier
     */
    getExpenditure(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [ColonyDataTypes.ExpenditureStructOutput] & {
        expenditure: ColonyDataTypes.ExpenditureStructOutput;
      }
    >;

    /**
     * Returns an existing expenditure slot.
     * @param _id Expenditure identifier
     * @param _slot Expenditure slot
     */
    getExpenditureSlot(
      _id: BigNumberish,
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [ColonyDataTypes.ExpenditureSlotStructOutput] & {
        expenditureSlot: ColonyDataTypes.ExpenditureSlotStructOutput;
      }
    >;

    /**
     * Returns an existing expenditure slot's payout for a token.
     * @param _id Expenditure identifier
     * @param _slot Expenditure slot
     * @param _token Token address
     */
    getExpenditureSlotPayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    /**
     * Add a new payment in the colony. Secured function to authorised members.
     * @param _amount Payout amount
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _domainId The domain where the payment belongs
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _recipient Address of the payment recipient
     * @param _skillId The skill associated with the payment
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    addPayment(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _recipient: string,
      _token: string,
      _amount: BigNumberish,
      _domainId: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Finalizes the payment and logs the reputation log updates. Allowed to be called once after payment is fully funded. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    finalizePayment(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets the recipient on an existing payment. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _recipient Address of the payment recipient
     */
    setPaymentRecipient(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets the skill on an existing payment. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _skillId Id of the new skill to set
     */
    setPaymentSkill(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Sets the payout for a given token on an existing payment. Secured function to authorised members.
     * @param _amount Payout amount
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setPaymentPayout(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Returns an exiting payment.
     * @param _id Payment identifier
     */
    getPayment(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [ColonyDataTypes.PaymentStructOutput] & {
        payment: ColonyDataTypes.PaymentStructOutput;
      }
    >;

    /**
     * Claim the payout in `_token` denomination for payment `_id`. Here the network receives its fee from each payout. Same as for tasks, ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
     * @param _id Payment identifier
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimPayment(
      _id: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the number of payments in the colony.
     */
    getPaymentCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count: BigNumber }>;

    /**
     * Make a new task in the colony. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId The domain where the task belongs
     * @param _dueDate The due date of the task, can set to `0` for no-op
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _skillId The skill associated with the task, can set to `0` for no-op
     * @param _specificationHash Database identifier where the task specification is stored
     */
    makeTask(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _specificationHash: BytesLike,
      _domainId: BigNumberish,
      _skillId: BigNumberish,
      _dueDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the number of tasks in the colony.
     */
    getTaskCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count: BigNumber }>;

    /**
     * Starts from 0 and is incremented on every co-reviewed task change via `executeTaskChange` call.
     * @param _id Id of the task
     */
    getTaskChangeNonce(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    /**
     * The Colony functions which require approval and the task roles to review these are set in `IColony.initialiseColony` at colony creation. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
     * Executes a task update transaction `_data` which is approved and signed by two of its roles (e.g. manager and worker) using the detached signatures for these users.
     * @param _data The transaction data
     * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
     * @param _sigR r output of the ECDSA signature of the transaction
     * @param _sigS s output of the ECDSA signature of the transaction
     * @param _sigV recovery id
     * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
     */
    executeTaskChange(
      _sigV: BigNumberish[],
      _sigR: BytesLike[],
      _sigS: BytesLike[],
      _mode: BigNumberish[],
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Executes a task role update transaction `_data` which is approved and signed by two of addresses. depending of which function we are calling. Allowed functions are `setTaskManagerRole`, `setTaskEvaluatorRole` and `setTaskWorkerRole`. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
     * @param _data The transaction data
     * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
     * @param _sigR r output of the ECDSA signature of the transaction
     * @param _sigS s output of the ECDSA signature of the transaction
     * @param _sigV recovery id
     * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
     */
    executeTaskRoleAssignment(
      _sigV: BigNumberish[],
      _sigR: BytesLike[],
      _sigS: BytesLike[],
      _mode: BigNumberish[],
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Submit a hashed secret of the rating for work in task `_id` which was performed by user with task role id `_role`. Allowed within 5 days period starting which whichever is first from either the deliverable being submitted or the dueDate been reached. Allowed only for evaluator to rate worker and for worker to rate manager performance. Once submitted ratings can not be changed or overwritten.
     * @param _id Id of the task
     * @param _ratingSecret `keccak256` hash of a salt and 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50). Can be generated via `IColony.generateSecret` helper function.
     * @param _role Id of the role, as defined in TaskRole enum
     */
    submitTaskWorkRating(
      _id: BigNumberish,
      _role: BigNumberish,
      _ratingSecret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Compares the `keccak256(_salt, _rating)` output with the previously submitted rating secret and if they match, sets the task role properties `rated` to `true` and `rating` to `_rating`.
     * Reveal the secret rating submitted in `IColony.submitTaskWorkRating` for task `_id` and task role with id `_role`. Allowed within 5 days period starting which whichever is first from either both rating secrets being submitted (via `IColony.submitTaskWorkRating`) or the 5 day rating period expiring.
     * @param _id Id of the task
     * @param _rating 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50)
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _salt Salt value used to generate the rating secret
     */
    revealTaskWorkRating(
      _id: BigNumberish,
      _role: BigNumberish,
      _rating: BigNumberish,
      _salt: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Helper function used to generage consistently the rating secret using salt value `_salt` and value to hide `_value`
     * @param _salt Salt value
     * @param _value Value to hide
     */
    generateSecret(
      _salt: BytesLike,
      _value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { secret: string }>;

    /**
     * Get the `ColonyStorage.RatingSecrets` information for task `_id`.
     * @param _id Id of the task
     */
    getTaskWorkRatingSecretsInfo(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        nSecrets: BigNumber;
        lastSubmittedAt: BigNumber;
      }
    >;

    /**
     * Get the rating secret submitted for role `_role` in task `_id`
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     */
    getTaskWorkRatingSecret(
      _id: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { secret: string }>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning manager role. Current manager and user we want to assign role to both need to agree. User we want to set here also needs to be an admin. Note that the domain proof data comes at the end here to not interfere with the assembly argument unpacking.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Id of the task
     * @param _permissionDomainId The domain ID in which _user has the Administration permission
     * @param _user Address of the user we want to give a manager role to
     */
    setTaskManagerRole(
      _id: BigNumberish,
      _user: string,
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning evaluator role. Can only be set if there is no one currently assigned to be an evaluator. Manager of the task and user we want to assign role to both need to agree. Managers can assign themselves to this role, if there is no one currently assigned to it.
     * @param _id Id of the task
     * @param _user Address of the user we want to give a evaluator role to
     */
    setTaskEvaluatorRole(
      _id: BigNumberish,
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning worker role. Can only be set if there is no one currently assigned to be a worker. Manager of the task and user we want to assign role to both need to agree.
     * @param _id Id of the task
     * @param _user Address of the user we want to give a worker role to
     */
    setTaskWorkerRole(
      _id: BigNumberish,
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Removing evaluator role. Agreed between manager and currently assigned evaluator.
     * @param _id Id of the task
     */
    removeTaskEvaluatorRole(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Removing worker role. Agreed between manager and currently assigned worker.
     * @param _id Id of the task
     */
    removeTaskWorkerRole(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Currently we only allow one skill per task although we have provisioned for an array of skills in `Task` struct. Allowed before a task is finalized.
     * Set the skill for task `_id`.
     * @param _id Id of the task
     * @param _skillId Id of the skill which has to be a global skill
     */
    setTaskSkill(
      _id: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set the hash for the task brief, aka task work specification, which identifies the task brief content in ddb. Allowed before a task is finalized.
     * @param _id Id of the task
     * @param _specificationHash Unique hash of the task brief in ddb
     */
    setTaskBrief(
      _id: BigNumberish,
      _specificationHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set the due date on task `_id`. Allowed before a task is finalized.
     * @param _dueDate Due date as seconds since unix epoch
     * @param _id Id of the task
     */
    setTaskDueDate(
      _id: BigNumberish,
      _dueDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set the `task.deliverableHash` and `task.completionTimestamp` properties.
     * Submit the task deliverable, i.e. the output of the work performed for task `_id`. Submission is allowed only to the assigned worker before the task due date. Submissions cannot be overwritten.
     * @param _deliverableHash Unique hash of the task deliverable content in ddb
     * @param _id Id of the task
     */
    submitTaskDeliverable(
      _id: BigNumberish,
      _deliverableHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Internally call `submitTaskDeliverable` and `submitTaskWorkRating` in sequence.
     * Submit the task deliverable for Worker and rating for Manager.
     * @param _deliverableHash Unique hash of the task deliverable content in ddb
     * @param _id Id of the task
     * @param _ratingSecret Rating secret for manager
     */
    submitTaskDeliverableAndRating(
      _id: BigNumberish,
      _deliverableHash: BytesLike,
      _ratingSecret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set the `task.finalized` property to true
     * Called after task work rating is complete which closes the task and logs the respective reputation log updates. Allowed to be called once per task. Secured function to authorised members.
     * @param _id Id of the task
     */
    finalizeTask(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set the `task.status` property to `1`.
     * Cancel a task at any point before it is finalized. Secured function to authorised members. Any funds assigned to its funding pot can be moved back to the domain via `IColony.moveFundsBetweenPots`.
     * @param _id Id of the task
     */
    cancelTask(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Mark a task as complete after the due date has passed. This allows the task to be rated and finalized (and funds recovered) even in the presence of a worker who has disappeared. Note that if the due date was not set, then this function will throw.
     * @param _id Id of the task
     */
    completeTask(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get a task with id `_id`
     * @param _id Id of the task
     */
    getTask(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber[]
      ] & {
        specificationHash: string;
        deliverableHash: string;
        status: number;
        dueDate: BigNumber;
        fundingPotId: BigNumber;
        completionTimestamp: BigNumber;
        domainId: BigNumber;
        skillIds: BigNumber[];
      }
    >;

    /**
     * Get the `Role` properties back for role `_role` in task `_id`.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     */
    getTaskRole(
      _id: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [ColonyDataTypes.RoleStructOutput] & {
        role: ColonyDataTypes.RoleStructOutput;
      }
    >;

    /**
     * Set the reward inverse to pay out from revenue. e.g. if the fee is 1% (or 0.01), set 100.
     * @param _rewardInverse The inverse of the reward
     */
    setRewardInverse(
      _rewardInverse: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Return 1 / the reward to pay out from revenue. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getRewardInverse(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { rewardInverse: BigNumber }>;

    /**
     * Get payout amount in `_token` denomination for role `_role` in task `_id`.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getTaskPayout(
      _id: BigNumberish,
      _role: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    /**
     * Set `_token` payout for manager in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskManagerPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set `_token` payout for evaluator in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskEvaluatorPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set `_token` payout for worker in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskWorkerPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Can only call if evaluator and worker are unassigned or manager, otherwise need signature.
     * Set `_token` payout for all roles in task `_id` to the respective amounts.
     * @param _evaluatorAmount Payout amount for evaluator
     * @param _id Id of the task
     * @param _managerAmount Payout amount for manager
     * @param _token Address of the token, `0x0` value indicates Ether
     * @param _workerAmount Payout amount for worker
     */
    setAllTaskPayouts(
      _id: BigNumberish,
      _token: string,
      _managerAmount: BigNumberish,
      _evaluatorAmount: BigNumberish,
      _workerAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Claim the payout in `_token` denomination for work completed in task `_id` by contributor with role `_role`. Allowed only after task is finalized. Here the network receives its fee from each payout. Ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimTaskPayout(
      _id: BigNumberish,
      _role: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Start next reward payout for `_token`. All funds in the reward pot for `_token` will become unavailable.Add a new payment in the colony. Can only be called by users with root permission. All tokens will be locked, and can be unlocked by calling `waiveRewardPayout` or `claimRewardPayout`.
     * @param _token Address of the token used for reward payout
     * @param branchMask The branchmask of the proof
     * @param key Some Reputation hash tree key
     * @param siblings The siblings of the proof
     * @param value Reputation value
     */
    startNextRewardPayout(
      _token: string,
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Claim the reward payout at `_payoutId`. User needs to provide their reputation and colony-wide reputation which will be proven via Merkle proof inside this function. Can only be called if payout is active, i.e if 60 days have not passed from its creation. Can only be called if next in queue.
     * @param _payoutId Id of the reward payout
     * @param _squareRoots Square roots of values used in equation: `_squareRoots[0]` - square root of user reputation, `_squareRoots[1]` - square root of user tokens (deposited in TokenLocking), `_squareRoots[2]` - square root of total reputation, `_squareRoots[3]` - square root of total tokens, `_squareRoots[4]` - square root of numerator (user reputation * user tokens), `_squareRoots[5]` - square root of denominator (total reputation * total tokens), `_squareRoots[6]` - square root of payout amount.
     * @param branchMask The branchmask of the proof
     * @param key Some Reputation hash tree key
     * @param siblings The siblings of the proof
     * @param value Reputation value
     */
    claimRewardPayout(
      _payoutId: BigNumberish,
      _squareRoots: BigNumberish[],
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get useful information about specific reward payout.
     * @param _payoutId Id of the reward payout
     */
    getRewardPayoutInfo(
      _payoutId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [ColonyDataTypes.RewardPayoutCycleStructOutput] & {
        rewardPayoutCycle: ColonyDataTypes.RewardPayoutCycleStructOutput;
      }
    >;

    /**
     * Finalises the reward payout. Allows creation of next reward payouts for token that has been used in `_payoutId`. Can only be called when reward payout cycle is finished i.e when 60 days have passed from its creation.
     * @param _payoutId Id of the reward payout
     */
    finalizeRewardPayout(
      _payoutId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * For the reward funding pot (e.g. id: 0) this returns (0, 0, 0).
     * Get the non-mapping properties of a pot by id.
     * @param _id Id of the pot which details to get
     */
    getFundingPot(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber] & {
        associatedType: number;
        associatedTypeId: BigNumber;
        payoutsWeCannotMake: BigNumber;
      }
    >;

    /**
     * Get the number of funding pots in the colony.
     */
    getFundingPotCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count: BigNumber }>;

    /**
     * Get the `_token` balance of pot with id `_potId`.
     * @param _potId Id of the funding pot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getFundingPotBalance(
      _potId: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { balance: BigNumber }>;

    /**
     * Get the assigned `_token` payouts of pot with id `_potId`.
     * @param _potId Id of the funding pot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getFundingPotPayout(
      _potId: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { payout: BigNumber }>;

    /**
     * Move a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
     * @param _amount Amount of funds
     * @param _childSkillIndex The child index in _permissionDomainId where I will be taking this action
     * @param _domainId The domain where I am taking this action, pointed to by _permissionDomainId and _childSkillIndex
     * @param _fromChildSkillIndex In the array of child skills for the skill associated with the domain pointed to by _permissionDomainId + _childSkillIndex,         the index of the skill associated with the domain that contains _fromPot
     * @param _fromPot Funding pot id providing the funds
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _toChildSkillIndex The same, but for the _toPot which the funds are being moved to
     * @param _toPot Funding pot id receiving the funds
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _fromChildSkillIndex: BigNumberish,
      _toChildSkillIndex: BigNumberish,
      _fromPot: BigNumberish,
      _toPot: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * DEPRECATEDMove a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
     * @param _amount Amount of funds
     * @param _fromChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_fromPotId`
     * @param _fromPot Funding pot id providing the funds
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _toChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_toPotId`
     * @param _toPot Funding pot id receiving the funds
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,address)"(
      _permissionDomainId: BigNumberish,
      _fromChildSkillIndex: BigNumberish,
      _toChildSkillIndex: BigNumberish,
      _fromPot: BigNumberish,
      _toPot: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Move any funds received by the colony in `_token` denomination to the top-level domain pot, siphoning off a small amount to the reward pot. If called against a colony's own token, no fee is taken.
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimColonyFunds(
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the total amount of tokens `_token` minus amount reserved to be paid to the reputation and token holders as rewards.
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getNonRewardPotsTotal(
      _token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    /**
     * Allow the _approvee to obligate some amount of tokens as a stake.
     * @param _amount Amount of internal token up to which we are willing to be obligated.
     * @param _approvee Address of the account we are willing to let obligate us.
     * @param _domainId Domain in which we are willing to be obligated.
     */
    approveStake(
      _approvee: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Obligate the user some amount of tokens as a stake.
     * @param _amount Amount of internal token we are obligating.
     * @param _domainId Domain in which we are obligating the user.
     * @param _user Address of the account we are obligating.
     */
    obligateStake(
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Deobligate the user some amount of tokens, releasing the stake.
     * @param _amount Amount of internal token we are deobligating.
     * @param _domainId Domain in which we are deobligating the user.
     * @param _user Address of the account we are deobligating.
     */
    deobligateStake(
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Transfer some amount of obligated tokens. Can be called by the arbitration role.
     * @param _amount Amount of internal token we are transferring.
     * @param _childSkillIndex The child index in `_permissionDomainId` where we can find `_domainId`.
     * @param _domainId Domain in which we are transferring the tokens.
     * @param _obligator Address of the account who set the obligation.
     * @param _permissionDomainId The domainId in which I have the permission to take this action.
     * @param _recipient Recipient of the transferred tokens.
     * @param _user Address of the account we are transferring.
     */
    transferStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _obligator: string,
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * View an approval to obligate tokens.
     * @param _domainId Domain in which we are willing to be obligated.
     * @param _obligator Address of the account we are willing to let obligate us.
     * @param _user User allowing their tokens to be obligated.
     */
    getApproval(
      _user: string,
      _obligator: string,
      _domainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { approval: BigNumber }>;

    /**
     * View an obligation of tokens.
     * @param _domainId Domain in which we are obligated.
     * @param _obligator Address of the account who obligated us.
     * @param _user User whose tokens are obligated.
     */
    getObligation(
      _user: string,
      _obligator: string,
      _domainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { obligation: BigNumber }>;

    /**
     * Get the domain corresponding to a funding pot
     * @param _fundingPotId Id of the funding pot
     */
    getDomainFromFundingPot(
      _fundingPotId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { domainId: BigNumber }>;

    /**
     * Burn tokens held by the colony. Can only burn tokens held in the root funding pot.
     * @param amount The amount of tokens to burn
     * @param token The address of the token to burn
     */
    burnTokens(
      token: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * unlock the native colony token, if possible
     */
    unlockToken(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Update the internal bookkeeping around external ERC20 approvals
     * @param spender The account we have approved
     * @param token The address of the token which was approved
     */
    updateApprovalAmount(
      token: string,
      spender: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the current approval amount
     * @param spender The account we have approved
     * @param token The address of the token which was approved
     */
    getTokenApproval(
      token: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;

    /**
     * Get the current total approval amount across all spenders
     * @param token The address of the token which was approved
     */
    getTotalTokenApproval(
      token: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { amount: BigNumber }>;
  };

  /**
   * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
   */
  approveExitRecovery(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
   * Check whether the supplied slot is a protected variable specific to this contract
   * @param _slot The storage slot number to check.
   */
  checkNotAdditionalProtectedVariable(
    _slot: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Put colony network mining into recovery mode. Can only be called by user with recovery role.
   */
  enterRecoveryMode(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
   */
  exitRecoveryMode(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Is colony network in recovery mode.
   */
  isInRecoveryMode(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Return number of recovery roles.
   */
  numRecoveryRoles(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Remove colony recovery role. Can only be called by root role.
   * @param _user User we want to remove recovery role from
   */
  removeRecoveryRole(
    _user: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set new colony recovery role. Can be called by root.
   * @param _user User we want to give a recovery role to
   */
  setRecoveryRole(
    _user: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * certain critical variables are protected from editing in this function
   * Update value of arbitrary storage variable. Can only be called by user with recovery role.
   * @param _slot Uint address of storage slot to be updated
   * @param _value word of data to be set
   */
  setStorageSlotRecovery(
    _slot: BigNumberish,
    _value: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the `ColonyAuthority` for the colony.
   */
  authority(overrides?: CallOverrides): Promise<string>;

  /**
   * Used for testing.
   * Get the colony `owner` address. This should be address(0x0) at all times.
   */
  owner(overrides?: CallOverrides): Promise<string>;

  /**
   * Get the Colony contract version. Starts from 1 and is incremented with every deployed contract change.
   */
  version(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Downgrades are not allowed, i.e. `_newVersion` should be higher than the currect colony version.
   * Upgrades a colony to a new Colony contract version `_newVersion`.
   * @param _newVersion The target version for the upgrade
   */
  upgrade(
    _newVersion: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Can only be called by the colony itself, and only expected to be called as part of the `upgrade()` call. Required to be external so it can be an external call.
   * A function to be called after an upgrade has been done from v2 to v3.
   */
  finishUpgrade(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * The colonyNetworkAddress we read here is set once, during `initialiseColony`.
   * Returns the colony network address set on the Colony.
   */
  getColonyNetwork(overrides?: CallOverrides): Promise<string>;

  /**
   * Get the colony token.
   */
  getToken(overrides?: CallOverrides): Promise<string>;

  /**
   * Execute arbitrary transaction on behalf of the Colony
   * @param _action Bytes array encoding the function call and arguments
   * @param _to Contract to receive the function call (cannot be network or token locking)
   */
  makeArbitraryTransaction(
    _to: string,
    _action: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Emit a metadata string for a transaction
   * @param _metadata String of metadata for tx
   * @param _txHash Hash of transaction being annotated (0x0 for current tx)
   */
  annotateTransaction(
    _txHash: BytesLike,
    _metadata: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set new colony root role. Can be called by root role only.
   * @param _setTo The state of the role permission (true assign the permission, false revokes it)
   * @param _user User we want to give an root role to
   */
  setRootRole(
    _user: string,
    _setTo: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set new colony arbitration role. Can be called by root role or architecture role.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _domainId Domain in which we are giving user the role
   * @param _permissionDomainId Domain in which the caller has root role
   * @param _setTo The state of the role permission (true assign the permission, false revokes it)
   * @param _user User we want to give an arbitration role to
   */
  setArbitrationRole(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _user: string,
    _domainId: BigNumberish,
    _setTo: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set new colony architecture role. Can be called by root role or architecture role.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _domainId Domain in which we are giving user the role
   * @param _permissionDomainId Domain in which the caller has root/architecture role
   * @param _setTo The state of the role permission (true assign the permission, false revokes it)
   * @param _user User we want to give an architecture role to
   */
  setArchitectureRole(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _user: string,
    _domainId: BigNumberish,
    _setTo: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set new colony funding role. Can be called by root role or architecture role.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _domainId Domain in which we are giving user the role
   * @param _permissionDomainId Domain in which the caller has root/architecture role
   * @param _setTo The state of the role permission (true assign the permission, false revokes it)
   * @param _user User we want to give an funding role to
   */
  setFundingRole(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _user: string,
    _domainId: BigNumberish,
    _setTo: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set new colony admin role. Can be called by root role or architecture role.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _domainId Domain in which we are giving user the role
   * @param _permissionDomainId Domain in which the caller has root/architecture role
   * @param _setTo The state of the role permission (true assign the permission, false revokes it)
   * @param _user User we want to give an admin role to
   */
  setAdministrationRole(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _user: string,
    _domainId: BigNumberish,
    _setTo: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set several roles in one transaction. Can be called by root role or architecture role.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _domainId Domain in which we are giving user the role
   * @param _permissionDomainId Domain in which the caller has root/architecture role
   * @param _roles Byte array representing the desired role setting (1 for on, 0 for off)
   * @param _user User we want to give a role to
   */
  setUserRoles(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _user: string,
    _domainId: BigNumberish,
    _roles: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Check whether a given user has a given role for the colony. Calls the function of the same name on the colony's authority contract.
   * @param _domainId The domain where we want to check for the role
   * @param _role The role we want to check for
   * @param _user The user whose role we want to check
   */
  hasUserRole(
    _user: string,
    _domainId: BigNumberish,
    _role: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Check whether a given user has a given role for the colony, in a child domain. Calls the function of the same name on the colony's authority contract and an internal inheritence validator function
   * @param _childDomainId The domain where we want to use the role
   * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
   * @param _domainId Domain in which the caller has the role
   * @param _role The role we want to check for
   * @param _user The user whose role we want to check
   */
  hasInheritedUserRole(
    _user: string,
    _domainId: BigNumberish,
    _role: BigNumberish,
    _childSkillIndex: BigNumberish,
    _childDomainId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Check whether a given user can modify roles in the target domain `_childDomainId`. Mostly a convenience function to provide a uniform interface for extension contracts validating permissions
   * @param _childDomainId The domain where we want to edit roles
   * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
   * @param _domainId Domain in which the caller has the role (currently Root or Architecture)
   * @param _user The user whose permissions we want to check
   */
  userCanSetRoles(
    _user: string,
    _domainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _childDomainId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Gets the bytes32 representation of the roles for a user in a given domain
   * @param _domain The domain we want to get roles in
   * @param _user The user whose roles we want to get
   */
  getUserRoles(
    _user: string,
    _domain: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Gets the bytes32 representation of the roles authorized to call a function
   * @param _sig The function signature
   */
  getCapabilityRoles(
    _sig: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Emit a positive domain reputation update. Available only to Root role holders
   * @param _amount The (positive) amount of reputation to gain
   * @param _domainId The domain where the user will gain reputation
   * @param _user The user who will gain reputation
   */
  emitDomainReputationReward(
    _domainId: BigNumberish,
    _user: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Emit a positive skill reputation update. Available only to Root role holders
   * @param _amount The (positive) amount of reputation to gain
   * @param _skillId The skill where the user will gain reputation
   * @param _user The user who will gain reputation
   */
  emitSkillReputationReward(
    _skillId: BigNumberish,
    _user: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Emit a negative domain reputation update. Available only to Arbitration role holders
   * @param _amount The (negative) amount of reputation to lose
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _domainId The domain where the user will lose reputation
   * @param _permissionDomainId The domainId in which I hold the Arbitration role
   * @param _user The user who will lose reputation
   */
  emitDomainReputationPenalty(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _domainId: BigNumberish,
    _user: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Emit a negative skill reputation update. Available only to Arbitration role holders in the root domain
   * @param _amount The (negative) amount of reputation to lose
   * @param _skillId The skill where the user will lose reputation
   * @param _user The user who will lose reputation
   */
  emitSkillReputationPenalty(
    _skillId: BigNumberish,
    _user: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets the reward inverse to the uint max 2**256 - 1.
   * Called once when the colony is created to initialise certain storage slot values.
   * @param _colonyNetworkAddress Address of the colony network
   * @param _token Address of the colony ERC20 Token
   */
  initialiseColony(
    _colonyNetworkAddress: string,
    _token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called to change the metadata associated with a colony. Expected to be a IPFS hash of a JSON blob, but not enforced to any degree by the contracts
   * @param _metadata IPFS hash of the metadata
   */
  editColony(
    _metadata: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Only allowed to be called when `taskCount` is `0` by authorized addresses.
   * Allows the colony to bootstrap itself by having initial reputation and token `_amount` assigned to `_users`. This reputation is assigned in the colony-wide domain. Secured function to authorised members.
   * @param _amount Amount of reputation/tokens for every address
   * @param _users Array of address to bootstrap with reputation
   */
  bootstrapColony(
    _users: string[],
    _amount: BigNumberish[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Mint `_wad` amount of colony tokens. Secured function to authorised members.
   * @param _wad Amount to mint
   */
  mintTokens(
    _wad: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Mint `_wad` amount of colony tokens and send to `_guy`. Secured function to authorised members.
   * @param _guy Recipient of new tokens
   * @param _wad Amount to mint
   */
  mintTokensFor(
    _guy: string,
    _wad: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Lock the colony's token. Can only be called by a network-managed extension.
   */
  lockToken(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Unlock the colony's token for a user. Can only be called by a network-managed extension.
   * @param lockId The specific lock to unlock
   * @param user The user to unlock
   */
  unlockTokenForUser(
    user: string,
    lockId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Register colony's ENS label.
   * @param colonyName The label to register.
   * @param orbitdb The path of the orbitDB database associated with the colony name
   */
  registerColonyLabel(
    colonyName: string,
    orbitdb: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
   * @param orbitdb The path of the orbitDB database to be associated with the colony
   */
  updateColonyOrbitDB(
    orbitdb: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Install an extension to the colony. Secured function to authorised members.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param version The new extension version to install
   */
  installExtension(
    extensionId: BytesLike,
    version: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade an extension in a colony. Secured function to authorised members.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param newVersion The version to upgrade to (must be one larger than the current version)
   */
  upgradeExtension(
    extensionId: BytesLike,
    newVersion: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set the deprecation of an extension in a colony. Secured function to authorised members.
   * @param deprecated Whether to deprecate the extension or not
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  deprecateExtension(
    extensionId: BytesLike,
    deprecated: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * This is a permanent action -- re-installing the extension will deploy a new contractIt is recommended to deprecate an extension before uninstalling to allow active objects to be resolved
   * Uninstall an extension from a colony. Secured function to authorised members.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  uninstallExtension(
    extensionId: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.
   * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _parentDomainId Id of the domain under which the new one will be added
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   */
  "addDomain(uint256,uint256,uint256)"(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _parentDomainId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.We expect this function to only be used by the dapp
   * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
   * @param _parentDomainId Id of the domain under which the new one will be added
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   */
  "addDomain(uint256,uint256,uint256,string)"(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _parentDomainId: BigNumberish,
    _metadata: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _domainId Id of the domain being edited
   * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   */
  editDomain(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _domainId: BigNumberish,
    _metadata: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get a domain by id.
   * @param _id Id of the domain which details to get
   */
  getDomain(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<ColonyDataTypes.DomainStructOutput>;

  /**
   * Get the number of domains in the colony.
   */
  getDomainCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * For more detail about branchMask and siblings, examine the PatriciaTree implementation. While external, likely only to be used by the Colony contracts, as it checks that the user is proving their own reputation in the current colony. The `verifyProof` function can be used to verify any proof, though this function is not currently exposed on the Colony's EtherRouter.
   * Helper function that can be used by a client to verify the correctness of a patricia proof they have been supplied with.
   * @param branchMask The branchmask of the proof
   * @param key The key of the element the proof is for.
   * @param siblings The siblings of the proof
   * @param value The value of the element that the proof is for.
   */
  verifyReputationProof(
    key: BytesLike,
    value: BytesLike,
    branchMask: BigNumberish,
    siblings: BytesLike[],
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Add a new expenditure in the colony. Secured function to authorised members.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
   * @param _domainId The domain where the expenditure belongs
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   */
  makeExpenditure(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _domainId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Updates the expenditure owner. Can only be called by expenditure owner.
   * @param _id Expenditure identifier
   * @param _newOwner New owner of expenditure
   */
  transferExpenditure(
    _id: BigNumberish,
    _newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future version
   * DEPRECATED Updates the expenditure owner. Can only be called by Arbitration role.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
   * @param _id Expenditure identifier
   * @param _newOwner New owner of expenditure
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   */
  transferExpenditureViaArbitration(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _id: BigNumberish,
    _newOwner: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Cancels the expenditure and prevents further editing. Can only be called by expenditure owner.
   * @param _id Expenditure identifier
   */
  cancelExpenditure(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Finalizes the expenditure and prevents further editing. Can only be called by expenditure owner.
   * @param _id Expenditure identifier
   */
  finalizeExpenditure(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets the recipient on an expenditure slot. Can only be called by expenditure owner.
   * @param _id Id of the expenditure
   * @param _recipient Address of the recipient
   * @param _slot Slot for the recipient address
   */
  setExpenditureRecipient(
    _id: BigNumberish,
    _slot: BigNumberish,
    _recipient: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set the token payout on an expenditure slot. Can only be called by expenditure owner.
   * @param _amount Payout amount
   * @param _id Id of the expenditure
   * @param _slot Number of the slot
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  setExpenditurePayout(
    _id: BigNumberish,
    _slot: BigNumberish,
    _token: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets the skill on an expenditure slot. Can only be called by expenditure owner.
   * @param _id Expenditure identifier
   * @param _skillId Id of the new skill to set
   * @param _slot Number of the slot
   */
  setExpenditureSkill(
    _id: BigNumberish,
    _slot: BigNumberish,
    _skillId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future versionNote that when determining payouts the payoutModifier is incremented by WAD and converted into payoutScalar
   * DEPRECATED Set the payout modifier on an expenditure slot. Can only be called by Arbitration role.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
   * @param _id Expenditure identifier
   * @param _payoutModifier Modifier to their payout (between -1 and 1, denominated in WADs, 0 means no modification)
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _slot Number of the slot
   */
  setExpenditurePayoutModifier(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _id: BigNumberish,
    _slot: BigNumberish,
    _payoutModifier: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future version
   * DEPRECATED Set the claim delay on an expenditure slot. Can only be called by Arbitration role.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
   * @param _claimDelay Time (in seconds) to delay claiming payout after finalization
   * @param _id Expenditure identifier
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _slot Number of the slot
   */
  setExpenditureClaimDelay(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _id: BigNumberish,
    _slot: BigNumberish,
    _claimDelay: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set arbitrary state on an expenditure slot. Can only be called by Arbitration role.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
   * @param _id Expenditure identifier
   * @param _keys Array of additional keys (for mappings & arrays)
   * @param _mask Array of booleans indicated whether a key is a mapping (F) or an array index (T).
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _storageSlot Number of the top-level storage slot (25, 26, or 27)
   * @param _value Value to set at location
   */
  setExpenditureState(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _id: BigNumberish,
    _storageSlot: BigNumberish,
    _mask: boolean[],
    _keys: BytesLike[],
    _value: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Claim the payout for an expenditure slot. Here the network receives a fee from each payout.
   * @param _id Expenditure identifier
   * @param _slot Number of the slot
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  claimExpenditurePayout(
    _id: BigNumberish,
    _slot: BigNumberish,
    _token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the number of expenditures in the colony.
   */
  getExpenditureCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Returns an existing expenditure.
   * @param _id Expenditure identifier
   */
  getExpenditure(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<ColonyDataTypes.ExpenditureStructOutput>;

  /**
   * Returns an existing expenditure slot.
   * @param _id Expenditure identifier
   * @param _slot Expenditure slot
   */
  getExpenditureSlot(
    _id: BigNumberish,
    _slot: BigNumberish,
    overrides?: CallOverrides
  ): Promise<ColonyDataTypes.ExpenditureSlotStructOutput>;

  /**
   * Returns an existing expenditure slot's payout for a token.
   * @param _id Expenditure identifier
   * @param _slot Expenditure slot
   * @param _token Token address
   */
  getExpenditureSlotPayout(
    _id: BigNumberish,
    _slot: BigNumberish,
    _token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Add a new payment in the colony. Secured function to authorised members.
   * @param _amount Payout amount
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
   * @param _domainId The domain where the payment belongs
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _recipient Address of the payment recipient
   * @param _skillId The skill associated with the payment
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  addPayment(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _recipient: string,
    _token: string,
    _amount: BigNumberish,
    _domainId: BigNumberish,
    _skillId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Finalizes the payment and logs the reputation log updates. Allowed to be called once after payment is fully funded. Secured function to authorised members.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _id Payment identifier
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   */
  finalizePayment(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets the recipient on an existing payment. Secured function to authorised members.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _id Payment identifier
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _recipient Address of the payment recipient
   */
  setPaymentRecipient(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _id: BigNumberish,
    _recipient: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets the skill on an existing payment. Secured function to authorised members.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _id Payment identifier
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _skillId Id of the new skill to set
   */
  setPaymentSkill(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _id: BigNumberish,
    _skillId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Sets the payout for a given token on an existing payment. Secured function to authorised members.
   * @param _amount Payout amount
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _id Payment identifier
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  setPaymentPayout(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _id: BigNumberish,
    _token: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Returns an exiting payment.
   * @param _id Payment identifier
   */
  getPayment(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<ColonyDataTypes.PaymentStructOutput>;

  /**
   * Claim the payout in `_token` denomination for payment `_id`. Here the network receives its fee from each payout. Same as for tasks, ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
   * @param _id Payment identifier
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  claimPayment(
    _id: BigNumberish,
    _token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the number of payments in the colony.
   */
  getPaymentCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Make a new task in the colony. Secured function to authorised members.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _domainId The domain where the task belongs
   * @param _dueDate The due date of the task, can set to `0` for no-op
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _skillId The skill associated with the task, can set to `0` for no-op
   * @param _specificationHash Database identifier where the task specification is stored
   */
  makeTask(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _specificationHash: BytesLike,
    _domainId: BigNumberish,
    _skillId: BigNumberish,
    _dueDate: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the number of tasks in the colony.
   */
  getTaskCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Starts from 0 and is incremented on every co-reviewed task change via `executeTaskChange` call.
   * @param _id Id of the task
   */
  getTaskChangeNonce(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * The Colony functions which require approval and the task roles to review these are set in `IColony.initialiseColony` at colony creation. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
   * Executes a task update transaction `_data` which is approved and signed by two of its roles (e.g. manager and worker) using the detached signatures for these users.
   * @param _data The transaction data
   * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
   * @param _sigR r output of the ECDSA signature of the transaction
   * @param _sigS s output of the ECDSA signature of the transaction
   * @param _sigV recovery id
   * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
   */
  executeTaskChange(
    _sigV: BigNumberish[],
    _sigR: BytesLike[],
    _sigS: BytesLike[],
    _mode: BigNumberish[],
    _value: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Executes a task role update transaction `_data` which is approved and signed by two of addresses. depending of which function we are calling. Allowed functions are `setTaskManagerRole`, `setTaskEvaluatorRole` and `setTaskWorkerRole`. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
   * @param _data The transaction data
   * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
   * @param _sigR r output of the ECDSA signature of the transaction
   * @param _sigS s output of the ECDSA signature of the transaction
   * @param _sigV recovery id
   * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
   */
  executeTaskRoleAssignment(
    _sigV: BigNumberish[],
    _sigR: BytesLike[],
    _sigS: BytesLike[],
    _mode: BigNumberish[],
    _value: BigNumberish,
    _data: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Submit a hashed secret of the rating for work in task `_id` which was performed by user with task role id `_role`. Allowed within 5 days period starting which whichever is first from either the deliverable being submitted or the dueDate been reached. Allowed only for evaluator to rate worker and for worker to rate manager performance. Once submitted ratings can not be changed or overwritten.
   * @param _id Id of the task
   * @param _ratingSecret `keccak256` hash of a salt and 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50). Can be generated via `IColony.generateSecret` helper function.
   * @param _role Id of the role, as defined in TaskRole enum
   */
  submitTaskWorkRating(
    _id: BigNumberish,
    _role: BigNumberish,
    _ratingSecret: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Compares the `keccak256(_salt, _rating)` output with the previously submitted rating secret and if they match, sets the task role properties `rated` to `true` and `rating` to `_rating`.
   * Reveal the secret rating submitted in `IColony.submitTaskWorkRating` for task `_id` and task role with id `_role`. Allowed within 5 days period starting which whichever is first from either both rating secrets being submitted (via `IColony.submitTaskWorkRating`) or the 5 day rating period expiring.
   * @param _id Id of the task
   * @param _rating 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50)
   * @param _role Id of the role, as defined in TaskRole enum
   * @param _salt Salt value used to generate the rating secret
   */
  revealTaskWorkRating(
    _id: BigNumberish,
    _role: BigNumberish,
    _rating: BigNumberish,
    _salt: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Helper function used to generage consistently the rating secret using salt value `_salt` and value to hide `_value`
   * @param _salt Salt value
   * @param _value Value to hide
   */
  generateSecret(
    _salt: BytesLike,
    _value: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Get the `ColonyStorage.RatingSecrets` information for task `_id`.
   * @param _id Id of the task
   */
  getTaskWorkRatingSecretsInfo(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [BigNumber, BigNumber] & { nSecrets: BigNumber; lastSubmittedAt: BigNumber }
  >;

  /**
   * Get the rating secret submitted for role `_role` in task `_id`
   * @param _id Id of the task
   * @param _role Id of the role, as defined in TaskRole enum
   */
  getTaskWorkRatingSecret(
    _id: BigNumberish,
    _role: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * This function can only be called through `executeTaskRoleAssignment`.
   * Assigning manager role. Current manager and user we want to assign role to both need to agree. User we want to set here also needs to be an admin. Note that the domain proof data comes at the end here to not interfere with the assembly argument unpacking.
   * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
   * @param _id Id of the task
   * @param _permissionDomainId The domain ID in which _user has the Administration permission
   * @param _user Address of the user we want to give a manager role to
   */
  setTaskManagerRole(
    _id: BigNumberish,
    _user: string,
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * This function can only be called through `executeTaskRoleAssignment`.
   * Assigning evaluator role. Can only be set if there is no one currently assigned to be an evaluator. Manager of the task and user we want to assign role to both need to agree. Managers can assign themselves to this role, if there is no one currently assigned to it.
   * @param _id Id of the task
   * @param _user Address of the user we want to give a evaluator role to
   */
  setTaskEvaluatorRole(
    _id: BigNumberish,
    _user: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * This function can only be called through `executeTaskRoleAssignment`.
   * Assigning worker role. Can only be set if there is no one currently assigned to be a worker. Manager of the task and user we want to assign role to both need to agree.
   * @param _id Id of the task
   * @param _user Address of the user we want to give a worker role to
   */
  setTaskWorkerRole(
    _id: BigNumberish,
    _user: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Removing evaluator role. Agreed between manager and currently assigned evaluator.
   * @param _id Id of the task
   */
  removeTaskEvaluatorRole(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Removing worker role. Agreed between manager and currently assigned worker.
   * @param _id Id of the task
   */
  removeTaskWorkerRole(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Currently we only allow one skill per task although we have provisioned for an array of skills in `Task` struct. Allowed before a task is finalized.
   * Set the skill for task `_id`.
   * @param _id Id of the task
   * @param _skillId Id of the skill which has to be a global skill
   */
  setTaskSkill(
    _id: BigNumberish,
    _skillId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set the hash for the task brief, aka task work specification, which identifies the task brief content in ddb. Allowed before a task is finalized.
   * @param _id Id of the task
   * @param _specificationHash Unique hash of the task brief in ddb
   */
  setTaskBrief(
    _id: BigNumberish,
    _specificationHash: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set the due date on task `_id`. Allowed before a task is finalized.
   * @param _dueDate Due date as seconds since unix epoch
   * @param _id Id of the task
   */
  setTaskDueDate(
    _id: BigNumberish,
    _dueDate: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set the `task.deliverableHash` and `task.completionTimestamp` properties.
   * Submit the task deliverable, i.e. the output of the work performed for task `_id`. Submission is allowed only to the assigned worker before the task due date. Submissions cannot be overwritten.
   * @param _deliverableHash Unique hash of the task deliverable content in ddb
   * @param _id Id of the task
   */
  submitTaskDeliverable(
    _id: BigNumberish,
    _deliverableHash: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Internally call `submitTaskDeliverable` and `submitTaskWorkRating` in sequence.
   * Submit the task deliverable for Worker and rating for Manager.
   * @param _deliverableHash Unique hash of the task deliverable content in ddb
   * @param _id Id of the task
   * @param _ratingSecret Rating secret for manager
   */
  submitTaskDeliverableAndRating(
    _id: BigNumberish,
    _deliverableHash: BytesLike,
    _ratingSecret: BytesLike,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set the `task.finalized` property to true
   * Called after task work rating is complete which closes the task and logs the respective reputation log updates. Allowed to be called once per task. Secured function to authorised members.
   * @param _id Id of the task
   */
  finalizeTask(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set the `task.status` property to `1`.
   * Cancel a task at any point before it is finalized. Secured function to authorised members. Any funds assigned to its funding pot can be moved back to the domain via `IColony.moveFundsBetweenPots`.
   * @param _id Id of the task
   */
  cancelTask(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Mark a task as complete after the due date has passed. This allows the task to be rated and finalized (and funds recovered) even in the presence of a worker who has disappeared. Note that if the due date was not set, then this function will throw.
   * @param _id Id of the task
   */
  completeTask(
    _id: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get a task with id `_id`
   * @param _id Id of the task
   */
  getTask(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [
      string,
      string,
      number,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber,
      BigNumber[]
    ] & {
      specificationHash: string;
      deliverableHash: string;
      status: number;
      dueDate: BigNumber;
      fundingPotId: BigNumber;
      completionTimestamp: BigNumber;
      domainId: BigNumber;
      skillIds: BigNumber[];
    }
  >;

  /**
   * Get the `Role` properties back for role `_role` in task `_id`.
   * @param _id Id of the task
   * @param _role Id of the role, as defined in TaskRole enum
   */
  getTaskRole(
    _id: BigNumberish,
    _role: BigNumberish,
    overrides?: CallOverrides
  ): Promise<ColonyDataTypes.RoleStructOutput>;

  /**
   * Set the reward inverse to pay out from revenue. e.g. if the fee is 1% (or 0.01), set 100.
   * @param _rewardInverse The inverse of the reward
   */
  setRewardInverse(
    _rewardInverse: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Return 1 / the reward to pay out from revenue. e.g. if the fee is 1% (or 0.01), return 100.
   */
  getRewardInverse(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get payout amount in `_token` denomination for role `_role` in task `_id`.
   * @param _id Id of the task
   * @param _role Id of the role, as defined in TaskRole enum
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  getTaskPayout(
    _id: BigNumberish,
    _role: BigNumberish,
    _token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Set `_token` payout for manager in task `_id` to `_amount`.
   * @param _amount Payout amount
   * @param _id Id of the task
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  setTaskManagerPayout(
    _id: BigNumberish,
    _token: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set `_token` payout for evaluator in task `_id` to `_amount`.
   * @param _amount Payout amount
   * @param _id Id of the task
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  setTaskEvaluatorPayout(
    _id: BigNumberish,
    _token: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set `_token` payout for worker in task `_id` to `_amount`.
   * @param _amount Payout amount
   * @param _id Id of the task
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  setTaskWorkerPayout(
    _id: BigNumberish,
    _token: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Can only call if evaluator and worker are unassigned or manager, otherwise need signature.
   * Set `_token` payout for all roles in task `_id` to the respective amounts.
   * @param _evaluatorAmount Payout amount for evaluator
   * @param _id Id of the task
   * @param _managerAmount Payout amount for manager
   * @param _token Address of the token, `0x0` value indicates Ether
   * @param _workerAmount Payout amount for worker
   */
  setAllTaskPayouts(
    _id: BigNumberish,
    _token: string,
    _managerAmount: BigNumberish,
    _evaluatorAmount: BigNumberish,
    _workerAmount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Claim the payout in `_token` denomination for work completed in task `_id` by contributor with role `_role`. Allowed only after task is finalized. Here the network receives its fee from each payout. Ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
   * @param _id Id of the task
   * @param _role Id of the role, as defined in TaskRole enum
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  claimTaskPayout(
    _id: BigNumberish,
    _role: BigNumberish,
    _token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Start next reward payout for `_token`. All funds in the reward pot for `_token` will become unavailable.Add a new payment in the colony. Can only be called by users with root permission. All tokens will be locked, and can be unlocked by calling `waiveRewardPayout` or `claimRewardPayout`.
   * @param _token Address of the token used for reward payout
   * @param branchMask The branchmask of the proof
   * @param key Some Reputation hash tree key
   * @param siblings The siblings of the proof
   * @param value Reputation value
   */
  startNextRewardPayout(
    _token: string,
    key: BytesLike,
    value: BytesLike,
    branchMask: BigNumberish,
    siblings: BytesLike[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Claim the reward payout at `_payoutId`. User needs to provide their reputation and colony-wide reputation which will be proven via Merkle proof inside this function. Can only be called if payout is active, i.e if 60 days have not passed from its creation. Can only be called if next in queue.
   * @param _payoutId Id of the reward payout
   * @param _squareRoots Square roots of values used in equation: `_squareRoots[0]` - square root of user reputation, `_squareRoots[1]` - square root of user tokens (deposited in TokenLocking), `_squareRoots[2]` - square root of total reputation, `_squareRoots[3]` - square root of total tokens, `_squareRoots[4]` - square root of numerator (user reputation * user tokens), `_squareRoots[5]` - square root of denominator (total reputation * total tokens), `_squareRoots[6]` - square root of payout amount.
   * @param branchMask The branchmask of the proof
   * @param key Some Reputation hash tree key
   * @param siblings The siblings of the proof
   * @param value Reputation value
   */
  claimRewardPayout(
    _payoutId: BigNumberish,
    _squareRoots: BigNumberish[],
    key: BytesLike,
    value: BytesLike,
    branchMask: BigNumberish,
    siblings: BytesLike[],
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get useful information about specific reward payout.
   * @param _payoutId Id of the reward payout
   */
  getRewardPayoutInfo(
    _payoutId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<ColonyDataTypes.RewardPayoutCycleStructOutput>;

  /**
   * Finalises the reward payout. Allows creation of next reward payouts for token that has been used in `_payoutId`. Can only be called when reward payout cycle is finished i.e when 60 days have passed from its creation.
   * @param _payoutId Id of the reward payout
   */
  finalizeRewardPayout(
    _payoutId: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * For the reward funding pot (e.g. id: 0) this returns (0, 0, 0).
   * Get the non-mapping properties of a pot by id.
   * @param _id Id of the pot which details to get
   */
  getFundingPot(
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber] & {
      associatedType: number;
      associatedTypeId: BigNumber;
      payoutsWeCannotMake: BigNumber;
    }
  >;

  /**
   * Get the number of funding pots in the colony.
   */
  getFundingPotCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the `_token` balance of pot with id `_potId`.
   * @param _potId Id of the funding pot
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  getFundingPotBalance(
    _potId: BigNumberish,
    _token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the assigned `_token` payouts of pot with id `_potId`.
   * @param _potId Id of the funding pot
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  getFundingPotPayout(
    _potId: BigNumberish,
    _token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Move a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
   * @param _amount Amount of funds
   * @param _childSkillIndex The child index in _permissionDomainId where I will be taking this action
   * @param _domainId The domain where I am taking this action, pointed to by _permissionDomainId and _childSkillIndex
   * @param _fromChildSkillIndex In the array of child skills for the skill associated with the domain pointed to by _permissionDomainId + _childSkillIndex,         the index of the skill associated with the domain that contains _fromPot
   * @param _fromPot Funding pot id providing the funds
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _toChildSkillIndex The same, but for the _toPot which the funds are being moved to
   * @param _toPot Funding pot id receiving the funds
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)"(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _domainId: BigNumberish,
    _fromChildSkillIndex: BigNumberish,
    _toChildSkillIndex: BigNumberish,
    _fromPot: BigNumberish,
    _toPot: BigNumberish,
    _amount: BigNumberish,
    _token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * DEPRECATEDMove a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
   * @param _amount Amount of funds
   * @param _fromChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_fromPotId`
   * @param _fromPot Funding pot id providing the funds
   * @param _permissionDomainId The domainId in which I have the permission to take this action
   * @param _toChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_toPotId`
   * @param _toPot Funding pot id receiving the funds
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,address)"(
    _permissionDomainId: BigNumberish,
    _fromChildSkillIndex: BigNumberish,
    _toChildSkillIndex: BigNumberish,
    _fromPot: BigNumberish,
    _toPot: BigNumberish,
    _amount: BigNumberish,
    _token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Move any funds received by the colony in `_token` denomination to the top-level domain pot, siphoning off a small amount to the reward pot. If called against a colony's own token, no fee is taken.
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  claimColonyFunds(
    _token: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the total amount of tokens `_token` minus amount reserved to be paid to the reputation and token holders as rewards.
   * @param _token Address of the token, `0x0` value indicates Ether
   */
  getNonRewardPotsTotal(
    _token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Allow the _approvee to obligate some amount of tokens as a stake.
   * @param _amount Amount of internal token up to which we are willing to be obligated.
   * @param _approvee Address of the account we are willing to let obligate us.
   * @param _domainId Domain in which we are willing to be obligated.
   */
  approveStake(
    _approvee: string,
    _domainId: BigNumberish,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Obligate the user some amount of tokens as a stake.
   * @param _amount Amount of internal token we are obligating.
   * @param _domainId Domain in which we are obligating the user.
   * @param _user Address of the account we are obligating.
   */
  obligateStake(
    _user: string,
    _domainId: BigNumberish,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Deobligate the user some amount of tokens, releasing the stake.
   * @param _amount Amount of internal token we are deobligating.
   * @param _domainId Domain in which we are deobligating the user.
   * @param _user Address of the account we are deobligating.
   */
  deobligateStake(
    _user: string,
    _domainId: BigNumberish,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Transfer some amount of obligated tokens. Can be called by the arbitration role.
   * @param _amount Amount of internal token we are transferring.
   * @param _childSkillIndex The child index in `_permissionDomainId` where we can find `_domainId`.
   * @param _domainId Domain in which we are transferring the tokens.
   * @param _obligator Address of the account who set the obligation.
   * @param _permissionDomainId The domainId in which I have the permission to take this action.
   * @param _recipient Recipient of the transferred tokens.
   * @param _user Address of the account we are transferring.
   */
  transferStake(
    _permissionDomainId: BigNumberish,
    _childSkillIndex: BigNumberish,
    _obligator: string,
    _user: string,
    _domainId: BigNumberish,
    _amount: BigNumberish,
    _recipient: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * View an approval to obligate tokens.
   * @param _domainId Domain in which we are willing to be obligated.
   * @param _obligator Address of the account we are willing to let obligate us.
   * @param _user User allowing their tokens to be obligated.
   */
  getApproval(
    _user: string,
    _obligator: string,
    _domainId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * View an obligation of tokens.
   * @param _domainId Domain in which we are obligated.
   * @param _obligator Address of the account who obligated us.
   * @param _user User whose tokens are obligated.
   */
  getObligation(
    _user: string,
    _obligator: string,
    _domainId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the domain corresponding to a funding pot
   * @param _fundingPotId Id of the funding pot
   */
  getDomainFromFundingPot(
    _fundingPotId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Burn tokens held by the colony. Can only burn tokens held in the root funding pot.
   * @param amount The amount of tokens to burn
   * @param token The address of the token to burn
   */
  burnTokens(
    token: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * unlock the native colony token, if possible
   */
  unlockToken(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Update the internal bookkeeping around external ERC20 approvals
   * @param spender The account we have approved
   * @param token The address of the token which was approved
   */
  updateApprovalAmount(
    token: string,
    spender: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the current approval amount
   * @param spender The account we have approved
   * @param token The address of the token which was approved
   */
  getTokenApproval(
    token: string,
    spender: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the current total approval amount across all spenders
   * @param token The address of the token which was approved
   */
  getTotalTokenApproval(
    token: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(overrides?: CallOverrides): Promise<void>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(overrides?: CallOverrides): Promise<void>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(overrides?: CallOverrides): Promise<void>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(_user: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(_user: string, overrides?: CallOverrides): Promise<void>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the `ColonyAuthority` for the colony.
     */
    authority(overrides?: CallOverrides): Promise<string>;

    /**
     * Used for testing.
     * Get the colony `owner` address. This should be address(0x0) at all times.
     */
    owner(overrides?: CallOverrides): Promise<string>;

    /**
     * Get the Colony contract version. Starts from 1 and is incremented with every deployed contract change.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Downgrades are not allowed, i.e. `_newVersion` should be higher than the currect colony version.
     * Upgrades a colony to a new Colony contract version `_newVersion`.
     * @param _newVersion The target version for the upgrade
     */
    upgrade(
      _newVersion: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Can only be called by the colony itself, and only expected to be called as part of the `upgrade()` call. Required to be external so it can be an external call.
     * A function to be called after an upgrade has been done from v2 to v3.
     */
    finishUpgrade(overrides?: CallOverrides): Promise<void>;

    /**
     * The colonyNetworkAddress we read here is set once, during `initialiseColony`.
     * Returns the colony network address set on the Colony.
     */
    getColonyNetwork(overrides?: CallOverrides): Promise<string>;

    /**
     * Get the colony token.
     */
    getToken(overrides?: CallOverrides): Promise<string>;

    /**
     * Execute arbitrary transaction on behalf of the Colony
     * @param _action Bytes array encoding the function call and arguments
     * @param _to Contract to receive the function call (cannot be network or token locking)
     */
    makeArbitraryTransaction(
      _to: string,
      _action: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Emit a metadata string for a transaction
     * @param _metadata String of metadata for tx
     * @param _txHash Hash of transaction being annotated (0x0 for current tx)
     */
    annotateTransaction(
      _txHash: BytesLike,
      _metadata: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set new colony root role. Can be called by root role only.
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an root role to
     */
    setRootRole(
      _user: string,
      _setTo: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set new colony arbitration role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an arbitration role to
     */
    setArbitrationRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set new colony architecture role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an architecture role to
     */
    setArchitectureRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set new colony funding role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an funding role to
     */
    setFundingRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set new colony admin role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an admin role to
     */
    setAdministrationRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set several roles in one transaction. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _roles Byte array representing the desired role setting (1 for on, 0 for off)
     * @param _user User we want to give a role to
     */
    setUserRoles(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _roles: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Check whether a given user has a given role for the colony. Calls the function of the same name on the colony's authority contract.
     * @param _domainId The domain where we want to check for the role
     * @param _role The role we want to check for
     * @param _user The user whose role we want to check
     */
    hasUserRole(
      _user: string,
      _domainId: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Check whether a given user has a given role for the colony, in a child domain. Calls the function of the same name on the colony's authority contract and an internal inheritence validator function
     * @param _childDomainId The domain where we want to use the role
     * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
     * @param _domainId Domain in which the caller has the role
     * @param _role The role we want to check for
     * @param _user The user whose role we want to check
     */
    hasInheritedUserRole(
      _user: string,
      _domainId: BigNumberish,
      _role: BigNumberish,
      _childSkillIndex: BigNumberish,
      _childDomainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Check whether a given user can modify roles in the target domain `_childDomainId`. Mostly a convenience function to provide a uniform interface for extension contracts validating permissions
     * @param _childDomainId The domain where we want to edit roles
     * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
     * @param _domainId Domain in which the caller has the role (currently Root or Architecture)
     * @param _user The user whose permissions we want to check
     */
    userCanSetRoles(
      _user: string,
      _domainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _childDomainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Gets the bytes32 representation of the roles for a user in a given domain
     * @param _domain The domain we want to get roles in
     * @param _user The user whose roles we want to get
     */
    getUserRoles(
      _user: string,
      _domain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Gets the bytes32 representation of the roles authorized to call a function
     * @param _sig The function signature
     */
    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Emit a positive domain reputation update. Available only to Root role holders
     * @param _amount The (positive) amount of reputation to gain
     * @param _domainId The domain where the user will gain reputation
     * @param _user The user who will gain reputation
     */
    emitDomainReputationReward(
      _domainId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Emit a positive skill reputation update. Available only to Root role holders
     * @param _amount The (positive) amount of reputation to gain
     * @param _skillId The skill where the user will gain reputation
     * @param _user The user who will gain reputation
     */
    emitSkillReputationReward(
      _skillId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Emit a negative domain reputation update. Available only to Arbitration role holders
     * @param _amount The (negative) amount of reputation to lose
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId The domain where the user will lose reputation
     * @param _permissionDomainId The domainId in which I hold the Arbitration role
     * @param _user The user who will lose reputation
     */
    emitDomainReputationPenalty(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Emit a negative skill reputation update. Available only to Arbitration role holders in the root domain
     * @param _amount The (negative) amount of reputation to lose
     * @param _skillId The skill where the user will lose reputation
     * @param _user The user who will lose reputation
     */
    emitSkillReputationPenalty(
      _skillId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the reward inverse to the uint max 2**256 - 1.
     * Called once when the colony is created to initialise certain storage slot values.
     * @param _colonyNetworkAddress Address of the colony network
     * @param _token Address of the colony ERC20 Token
     */
    initialiseColony(
      _colonyNetworkAddress: string,
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Called to change the metadata associated with a colony. Expected to be a IPFS hash of a JSON blob, but not enforced to any degree by the contracts
     * @param _metadata IPFS hash of the metadata
     */
    editColony(_metadata: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Only allowed to be called when `taskCount` is `0` by authorized addresses.
     * Allows the colony to bootstrap itself by having initial reputation and token `_amount` assigned to `_users`. This reputation is assigned in the colony-wide domain. Secured function to authorised members.
     * @param _amount Amount of reputation/tokens for every address
     * @param _users Array of address to bootstrap with reputation
     */
    bootstrapColony(
      _users: string[],
      _amount: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Mint `_wad` amount of colony tokens. Secured function to authorised members.
     * @param _wad Amount to mint
     */
    mintTokens(_wad: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Mint `_wad` amount of colony tokens and send to `_guy`. Secured function to authorised members.
     * @param _guy Recipient of new tokens
     * @param _wad Amount to mint
     */
    mintTokensFor(
      _guy: string,
      _wad: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Lock the colony's token. Can only be called by a network-managed extension.
     */
    lockToken(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Unlock the colony's token for a user. Can only be called by a network-managed extension.
     * @param lockId The specific lock to unlock
     * @param user The user to unlock
     */
    unlockTokenForUser(
      user: string,
      lockId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Register colony's ENS label.
     * @param colonyName The label to register.
     * @param orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      colonyName: string,
      orbitdb: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      orbitdb: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Install an extension to the colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version The new extension version to install
     */
    installExtension(
      extensionId: BytesLike,
      version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade an extension in a colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param newVersion The version to upgrade to (must be one larger than the current version)
     */
    upgradeExtension(
      extensionId: BytesLike,
      newVersion: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set the deprecation of an extension in a colony. Secured function to authorised members.
     * @param deprecated Whether to deprecate the extension or not
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      extensionId: BytesLike,
      deprecated: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This is a permanent action -- re-installing the extension will deploy a new contractIt is recommended to deprecate an extension before uninstalling to allow active objects to be resolved
     * Uninstall an extension from a colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      extensionId: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _parentDomainId Id of the domain under which the new one will be added
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    "addDomain(uint256,uint256,uint256)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _parentDomainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.We expect this function to only be used by the dapp
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
     * @param _parentDomainId Id of the domain under which the new one will be added
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    "addDomain(uint256,uint256,uint256,string)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _parentDomainId: BigNumberish,
      _metadata: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Id of the domain being edited
     * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    editDomain(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _metadata: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get a domain by id.
     * @param _id Id of the domain which details to get
     */
    getDomain(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ColonyDataTypes.DomainStructOutput>;

    /**
     * Get the number of domains in the colony.
     */
    getDomainCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * For more detail about branchMask and siblings, examine the PatriciaTree implementation. While external, likely only to be used by the Colony contracts, as it checks that the user is proving their own reputation in the current colony. The `verifyProof` function can be used to verify any proof, though this function is not currently exposed on the Colony's EtherRouter.
     * Helper function that can be used by a client to verify the correctness of a patricia proof they have been supplied with.
     * @param branchMask The branchmask of the proof
     * @param key The key of the element the proof is for.
     * @param siblings The siblings of the proof
     * @param value The value of the element that the proof is for.
     */
    verifyReputationProof(
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Add a new expenditure in the colony. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _domainId The domain where the expenditure belongs
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    makeExpenditure(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Updates the expenditure owner. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     * @param _newOwner New owner of expenditure
     */
    transferExpenditure(
      _id: BigNumberish,
      _newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This is now deprecated and will be removed in a future version
     * DEPRECATED Updates the expenditure owner. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _newOwner New owner of expenditure
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    transferExpenditureViaArbitration(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Cancels the expenditure and prevents further editing. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     */
    cancelExpenditure(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Finalizes the expenditure and prevents further editing. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     */
    finalizeExpenditure(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the recipient on an expenditure slot. Can only be called by expenditure owner.
     * @param _id Id of the expenditure
     * @param _recipient Address of the recipient
     * @param _slot Slot for the recipient address
     */
    setExpenditureRecipient(
      _id: BigNumberish,
      _slot: BigNumberish,
      _recipient: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set the token payout on an expenditure slot. Can only be called by expenditure owner.
     * @param _amount Payout amount
     * @param _id Id of the expenditure
     * @param _slot Number of the slot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setExpenditurePayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the skill on an expenditure slot. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     * @param _skillId Id of the new skill to set
     * @param _slot Number of the slot
     */
    setExpenditureSkill(
      _id: BigNumberish,
      _slot: BigNumberish,
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This is now deprecated and will be removed in a future versionNote that when determining payouts the payoutModifier is incremented by WAD and converted into payoutScalar
     * DEPRECATED Set the payout modifier on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _payoutModifier Modifier to their payout (between -1 and 1, denominated in WADs, 0 means no modification)
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _slot Number of the slot
     */
    setExpenditurePayoutModifier(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _slot: BigNumberish,
      _payoutModifier: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This is now deprecated and will be removed in a future version
     * DEPRECATED Set the claim delay on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _claimDelay Time (in seconds) to delay claiming payout after finalization
     * @param _id Expenditure identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _slot Number of the slot
     */
    setExpenditureClaimDelay(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _slot: BigNumberish,
      _claimDelay: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set arbitrary state on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _keys Array of additional keys (for mappings & arrays)
     * @param _mask Array of booleans indicated whether a key is a mapping (F) or an array index (T).
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _storageSlot Number of the top-level storage slot (25, 26, or 27)
     * @param _value Value to set at location
     */
    setExpenditureState(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _storageSlot: BigNumberish,
      _mask: boolean[],
      _keys: BytesLike[],
      _value: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Claim the payout for an expenditure slot. Here the network receives a fee from each payout.
     * @param _id Expenditure identifier
     * @param _slot Number of the slot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimExpenditurePayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the number of expenditures in the colony.
     */
    getExpenditureCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns an existing expenditure.
     * @param _id Expenditure identifier
     */
    getExpenditure(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ColonyDataTypes.ExpenditureStructOutput>;

    /**
     * Returns an existing expenditure slot.
     * @param _id Expenditure identifier
     * @param _slot Expenditure slot
     */
    getExpenditureSlot(
      _id: BigNumberish,
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ColonyDataTypes.ExpenditureSlotStructOutput>;

    /**
     * Returns an existing expenditure slot's payout for a token.
     * @param _id Expenditure identifier
     * @param _slot Expenditure slot
     * @param _token Token address
     */
    getExpenditureSlotPayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Add a new payment in the colony. Secured function to authorised members.
     * @param _amount Payout amount
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _domainId The domain where the payment belongs
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _recipient Address of the payment recipient
     * @param _skillId The skill associated with the payment
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    addPayment(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _recipient: string,
      _token: string,
      _amount: BigNumberish,
      _domainId: BigNumberish,
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Finalizes the payment and logs the reputation log updates. Allowed to be called once after payment is fully funded. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    finalizePayment(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the recipient on an existing payment. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _recipient Address of the payment recipient
     */
    setPaymentRecipient(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _recipient: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the skill on an existing payment. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _skillId Id of the new skill to set
     */
    setPaymentSkill(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets the payout for a given token on an existing payment. Secured function to authorised members.
     * @param _amount Payout amount
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setPaymentPayout(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Returns an exiting payment.
     * @param _id Payment identifier
     */
    getPayment(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ColonyDataTypes.PaymentStructOutput>;

    /**
     * Claim the payout in `_token` denomination for payment `_id`. Here the network receives its fee from each payout. Same as for tasks, ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
     * @param _id Payment identifier
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimPayment(
      _id: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the number of payments in the colony.
     */
    getPaymentCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Make a new task in the colony. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId The domain where the task belongs
     * @param _dueDate The due date of the task, can set to `0` for no-op
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _skillId The skill associated with the task, can set to `0` for no-op
     * @param _specificationHash Database identifier where the task specification is stored
     */
    makeTask(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _specificationHash: BytesLike,
      _domainId: BigNumberish,
      _skillId: BigNumberish,
      _dueDate: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the number of tasks in the colony.
     */
    getTaskCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Starts from 0 and is incremented on every co-reviewed task change via `executeTaskChange` call.
     * @param _id Id of the task
     */
    getTaskChangeNonce(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The Colony functions which require approval and the task roles to review these are set in `IColony.initialiseColony` at colony creation. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
     * Executes a task update transaction `_data` which is approved and signed by two of its roles (e.g. manager and worker) using the detached signatures for these users.
     * @param _data The transaction data
     * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
     * @param _sigR r output of the ECDSA signature of the transaction
     * @param _sigS s output of the ECDSA signature of the transaction
     * @param _sigV recovery id
     * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
     */
    executeTaskChange(
      _sigV: BigNumberish[],
      _sigR: BytesLike[],
      _sigS: BytesLike[],
      _mode: BigNumberish[],
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Executes a task role update transaction `_data` which is approved and signed by two of addresses. depending of which function we are calling. Allowed functions are `setTaskManagerRole`, `setTaskEvaluatorRole` and `setTaskWorkerRole`. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
     * @param _data The transaction data
     * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
     * @param _sigR r output of the ECDSA signature of the transaction
     * @param _sigS s output of the ECDSA signature of the transaction
     * @param _sigV recovery id
     * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
     */
    executeTaskRoleAssignment(
      _sigV: BigNumberish[],
      _sigR: BytesLike[],
      _sigS: BytesLike[],
      _mode: BigNumberish[],
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Submit a hashed secret of the rating for work in task `_id` which was performed by user with task role id `_role`. Allowed within 5 days period starting which whichever is first from either the deliverable being submitted or the dueDate been reached. Allowed only for evaluator to rate worker and for worker to rate manager performance. Once submitted ratings can not be changed or overwritten.
     * @param _id Id of the task
     * @param _ratingSecret `keccak256` hash of a salt and 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50). Can be generated via `IColony.generateSecret` helper function.
     * @param _role Id of the role, as defined in TaskRole enum
     */
    submitTaskWorkRating(
      _id: BigNumberish,
      _role: BigNumberish,
      _ratingSecret: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Compares the `keccak256(_salt, _rating)` output with the previously submitted rating secret and if they match, sets the task role properties `rated` to `true` and `rating` to `_rating`.
     * Reveal the secret rating submitted in `IColony.submitTaskWorkRating` for task `_id` and task role with id `_role`. Allowed within 5 days period starting which whichever is first from either both rating secrets being submitted (via `IColony.submitTaskWorkRating`) or the 5 day rating period expiring.
     * @param _id Id of the task
     * @param _rating 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50)
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _salt Salt value used to generate the rating secret
     */
    revealTaskWorkRating(
      _id: BigNumberish,
      _role: BigNumberish,
      _rating: BigNumberish,
      _salt: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Helper function used to generage consistently the rating secret using salt value `_salt` and value to hide `_value`
     * @param _salt Salt value
     * @param _value Value to hide
     */
    generateSecret(
      _salt: BytesLike,
      _value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Get the `ColonyStorage.RatingSecrets` information for task `_id`.
     * @param _id Id of the task
     */
    getTaskWorkRatingSecretsInfo(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, BigNumber] & {
        nSecrets: BigNumber;
        lastSubmittedAt: BigNumber;
      }
    >;

    /**
     * Get the rating secret submitted for role `_role` in task `_id`
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     */
    getTaskWorkRatingSecret(
      _id: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning manager role. Current manager and user we want to assign role to both need to agree. User we want to set here also needs to be an admin. Note that the domain proof data comes at the end here to not interfere with the assembly argument unpacking.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Id of the task
     * @param _permissionDomainId The domain ID in which _user has the Administration permission
     * @param _user Address of the user we want to give a manager role to
     */
    setTaskManagerRole(
      _id: BigNumberish,
      _user: string,
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning evaluator role. Can only be set if there is no one currently assigned to be an evaluator. Manager of the task and user we want to assign role to both need to agree. Managers can assign themselves to this role, if there is no one currently assigned to it.
     * @param _id Id of the task
     * @param _user Address of the user we want to give a evaluator role to
     */
    setTaskEvaluatorRole(
      _id: BigNumberish,
      _user: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning worker role. Can only be set if there is no one currently assigned to be a worker. Manager of the task and user we want to assign role to both need to agree.
     * @param _id Id of the task
     * @param _user Address of the user we want to give a worker role to
     */
    setTaskWorkerRole(
      _id: BigNumberish,
      _user: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Removing evaluator role. Agreed between manager and currently assigned evaluator.
     * @param _id Id of the task
     */
    removeTaskEvaluatorRole(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Removing worker role. Agreed between manager and currently assigned worker.
     * @param _id Id of the task
     */
    removeTaskWorkerRole(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Currently we only allow one skill per task although we have provisioned for an array of skills in `Task` struct. Allowed before a task is finalized.
     * Set the skill for task `_id`.
     * @param _id Id of the task
     * @param _skillId Id of the skill which has to be a global skill
     */
    setTaskSkill(
      _id: BigNumberish,
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set the hash for the task brief, aka task work specification, which identifies the task brief content in ddb. Allowed before a task is finalized.
     * @param _id Id of the task
     * @param _specificationHash Unique hash of the task brief in ddb
     */
    setTaskBrief(
      _id: BigNumberish,
      _specificationHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set the due date on task `_id`. Allowed before a task is finalized.
     * @param _dueDate Due date as seconds since unix epoch
     * @param _id Id of the task
     */
    setTaskDueDate(
      _id: BigNumberish,
      _dueDate: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set the `task.deliverableHash` and `task.completionTimestamp` properties.
     * Submit the task deliverable, i.e. the output of the work performed for task `_id`. Submission is allowed only to the assigned worker before the task due date. Submissions cannot be overwritten.
     * @param _deliverableHash Unique hash of the task deliverable content in ddb
     * @param _id Id of the task
     */
    submitTaskDeliverable(
      _id: BigNumberish,
      _deliverableHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Internally call `submitTaskDeliverable` and `submitTaskWorkRating` in sequence.
     * Submit the task deliverable for Worker and rating for Manager.
     * @param _deliverableHash Unique hash of the task deliverable content in ddb
     * @param _id Id of the task
     * @param _ratingSecret Rating secret for manager
     */
    submitTaskDeliverableAndRating(
      _id: BigNumberish,
      _deliverableHash: BytesLike,
      _ratingSecret: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set the `task.finalized` property to true
     * Called after task work rating is complete which closes the task and logs the respective reputation log updates. Allowed to be called once per task. Secured function to authorised members.
     * @param _id Id of the task
     */
    finalizeTask(_id: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Set the `task.status` property to `1`.
     * Cancel a task at any point before it is finalized. Secured function to authorised members. Any funds assigned to its funding pot can be moved back to the domain via `IColony.moveFundsBetweenPots`.
     * @param _id Id of the task
     */
    cancelTask(_id: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Mark a task as complete after the due date has passed. This allows the task to be rated and finalized (and funds recovered) even in the presence of a worker who has disappeared. Note that if the due date was not set, then this function will throw.
     * @param _id Id of the task
     */
    completeTask(_id: BigNumberish, overrides?: CallOverrides): Promise<void>;

    /**
     * Get a task with id `_id`
     * @param _id Id of the task
     */
    getTask(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [
        string,
        string,
        number,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber[]
      ] & {
        specificationHash: string;
        deliverableHash: string;
        status: number;
        dueDate: BigNumber;
        fundingPotId: BigNumber;
        completionTimestamp: BigNumber;
        domainId: BigNumber;
        skillIds: BigNumber[];
      }
    >;

    /**
     * Get the `Role` properties back for role `_role` in task `_id`.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     */
    getTaskRole(
      _id: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ColonyDataTypes.RoleStructOutput>;

    /**
     * Set the reward inverse to pay out from revenue. e.g. if the fee is 1% (or 0.01), set 100.
     * @param _rewardInverse The inverse of the reward
     */
    setRewardInverse(
      _rewardInverse: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Return 1 / the reward to pay out from revenue. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getRewardInverse(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get payout amount in `_token` denomination for role `_role` in task `_id`.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getTaskPayout(
      _id: BigNumberish,
      _role: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set `_token` payout for manager in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskManagerPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set `_token` payout for evaluator in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskEvaluatorPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set `_token` payout for worker in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskWorkerPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Can only call if evaluator and worker are unassigned or manager, otherwise need signature.
     * Set `_token` payout for all roles in task `_id` to the respective amounts.
     * @param _evaluatorAmount Payout amount for evaluator
     * @param _id Id of the task
     * @param _managerAmount Payout amount for manager
     * @param _token Address of the token, `0x0` value indicates Ether
     * @param _workerAmount Payout amount for worker
     */
    setAllTaskPayouts(
      _id: BigNumberish,
      _token: string,
      _managerAmount: BigNumberish,
      _evaluatorAmount: BigNumberish,
      _workerAmount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Claim the payout in `_token` denomination for work completed in task `_id` by contributor with role `_role`. Allowed only after task is finalized. Here the network receives its fee from each payout. Ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimTaskPayout(
      _id: BigNumberish,
      _role: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Start next reward payout for `_token`. All funds in the reward pot for `_token` will become unavailable.Add a new payment in the colony. Can only be called by users with root permission. All tokens will be locked, and can be unlocked by calling `waiveRewardPayout` or `claimRewardPayout`.
     * @param _token Address of the token used for reward payout
     * @param branchMask The branchmask of the proof
     * @param key Some Reputation hash tree key
     * @param siblings The siblings of the proof
     * @param value Reputation value
     */
    startNextRewardPayout(
      _token: string,
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Claim the reward payout at `_payoutId`. User needs to provide their reputation and colony-wide reputation which will be proven via Merkle proof inside this function. Can only be called if payout is active, i.e if 60 days have not passed from its creation. Can only be called if next in queue.
     * @param _payoutId Id of the reward payout
     * @param _squareRoots Square roots of values used in equation: `_squareRoots[0]` - square root of user reputation, `_squareRoots[1]` - square root of user tokens (deposited in TokenLocking), `_squareRoots[2]` - square root of total reputation, `_squareRoots[3]` - square root of total tokens, `_squareRoots[4]` - square root of numerator (user reputation * user tokens), `_squareRoots[5]` - square root of denominator (total reputation * total tokens), `_squareRoots[6]` - square root of payout amount.
     * @param branchMask The branchmask of the proof
     * @param key Some Reputation hash tree key
     * @param siblings The siblings of the proof
     * @param value Reputation value
     */
    claimRewardPayout(
      _payoutId: BigNumberish,
      _squareRoots: BigNumberish[],
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get useful information about specific reward payout.
     * @param _payoutId Id of the reward payout
     */
    getRewardPayoutInfo(
      _payoutId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ColonyDataTypes.RewardPayoutCycleStructOutput>;

    /**
     * Finalises the reward payout. Allows creation of next reward payouts for token that has been used in `_payoutId`. Can only be called when reward payout cycle is finished i.e when 60 days have passed from its creation.
     * @param _payoutId Id of the reward payout
     */
    finalizeRewardPayout(
      _payoutId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * For the reward funding pot (e.g. id: 0) this returns (0, 0, 0).
     * Get the non-mapping properties of a pot by id.
     * @param _id Id of the pot which details to get
     */
    getFundingPot(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber] & {
        associatedType: number;
        associatedTypeId: BigNumber;
        payoutsWeCannotMake: BigNumber;
      }
    >;

    /**
     * Get the number of funding pots in the colony.
     */
    getFundingPotCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the `_token` balance of pot with id `_potId`.
     * @param _potId Id of the funding pot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getFundingPotBalance(
      _potId: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the assigned `_token` payouts of pot with id `_potId`.
     * @param _potId Id of the funding pot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getFundingPotPayout(
      _potId: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Move a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
     * @param _amount Amount of funds
     * @param _childSkillIndex The child index in _permissionDomainId where I will be taking this action
     * @param _domainId The domain where I am taking this action, pointed to by _permissionDomainId and _childSkillIndex
     * @param _fromChildSkillIndex In the array of child skills for the skill associated with the domain pointed to by _permissionDomainId + _childSkillIndex,         the index of the skill associated with the domain that contains _fromPot
     * @param _fromPot Funding pot id providing the funds
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _toChildSkillIndex The same, but for the _toPot which the funds are being moved to
     * @param _toPot Funding pot id receiving the funds
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _fromChildSkillIndex: BigNumberish,
      _toChildSkillIndex: BigNumberish,
      _fromPot: BigNumberish,
      _toPot: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * DEPRECATEDMove a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
     * @param _amount Amount of funds
     * @param _fromChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_fromPotId`
     * @param _fromPot Funding pot id providing the funds
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _toChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_toPotId`
     * @param _toPot Funding pot id receiving the funds
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,address)"(
      _permissionDomainId: BigNumberish,
      _fromChildSkillIndex: BigNumberish,
      _toChildSkillIndex: BigNumberish,
      _fromPot: BigNumberish,
      _toPot: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Move any funds received by the colony in `_token` denomination to the top-level domain pot, siphoning off a small amount to the reward pot. If called against a colony's own token, no fee is taken.
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimColonyFunds(_token: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Get the total amount of tokens `_token` minus amount reserved to be paid to the reputation and token holders as rewards.
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getNonRewardPotsTotal(
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Allow the _approvee to obligate some amount of tokens as a stake.
     * @param _amount Amount of internal token up to which we are willing to be obligated.
     * @param _approvee Address of the account we are willing to let obligate us.
     * @param _domainId Domain in which we are willing to be obligated.
     */
    approveStake(
      _approvee: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Obligate the user some amount of tokens as a stake.
     * @param _amount Amount of internal token we are obligating.
     * @param _domainId Domain in which we are obligating the user.
     * @param _user Address of the account we are obligating.
     */
    obligateStake(
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Deobligate the user some amount of tokens, releasing the stake.
     * @param _amount Amount of internal token we are deobligating.
     * @param _domainId Domain in which we are deobligating the user.
     * @param _user Address of the account we are deobligating.
     */
    deobligateStake(
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfer some amount of obligated tokens. Can be called by the arbitration role.
     * @param _amount Amount of internal token we are transferring.
     * @param _childSkillIndex The child index in `_permissionDomainId` where we can find `_domainId`.
     * @param _domainId Domain in which we are transferring the tokens.
     * @param _obligator Address of the account who set the obligation.
     * @param _permissionDomainId The domainId in which I have the permission to take this action.
     * @param _recipient Recipient of the transferred tokens.
     * @param _user Address of the account we are transferring.
     */
    transferStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _obligator: string,
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      _recipient: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * View an approval to obligate tokens.
     * @param _domainId Domain in which we are willing to be obligated.
     * @param _obligator Address of the account we are willing to let obligate us.
     * @param _user User allowing their tokens to be obligated.
     */
    getApproval(
      _user: string,
      _obligator: string,
      _domainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * View an obligation of tokens.
     * @param _domainId Domain in which we are obligated.
     * @param _obligator Address of the account who obligated us.
     * @param _user User whose tokens are obligated.
     */
    getObligation(
      _user: string,
      _obligator: string,
      _domainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the domain corresponding to a funding pot
     * @param _fundingPotId Id of the funding pot
     */
    getDomainFromFundingPot(
      _fundingPotId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Burn tokens held by the colony. Can only burn tokens held in the root funding pot.
     * @param amount The amount of tokens to burn
     * @param token The address of the token to burn
     */
    burnTokens(
      token: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * unlock the native colony token, if possible
     */
    unlockToken(overrides?: CallOverrides): Promise<void>;

    /**
     * Update the internal bookkeeping around external ERC20 approvals
     * @param spender The account we have approved
     * @param token The address of the token which was approved
     */
    updateApprovalAmount(
      token: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the current approval amount
     * @param spender The account we have approved
     * @param token The address of the token which was approved
     */
    getTokenApproval(
      token: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the current total approval amount across all spenders
     * @param token The address of the token which was approved
     */
    getTotalTokenApproval(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "Annotation(address,bytes32,string)"(
      agent?: string | null,
      txHash?: BytesLike | null,
      metadata?: null
    ): AnnotationEventFilter;
    Annotation(
      agent?: string | null,
      txHash?: BytesLike | null,
      metadata?: null
    ): AnnotationEventFilter;

    "ColonyBootstrapped(address,address[],int256[])"(
      agent?: null,
      users?: null,
      amounts?: null
    ): ColonyBootstrappedEventFilter;
    ColonyBootstrapped(
      agent?: null,
      users?: null,
      amounts?: null
    ): ColonyBootstrappedEventFilter;

    "ColonyFundsClaimed(address,address,uint256,uint256)"(
      agent?: null,
      token?: null,
      fee?: null,
      payoutRemainder?: null
    ): ColonyFundsClaimedEventFilter;
    ColonyFundsClaimed(
      agent?: null,
      token?: null,
      fee?: null,
      payoutRemainder?: null
    ): ColonyFundsClaimedEventFilter;

    "ColonyFundsMovedBetweenFundingPots(address,uint256,uint256,uint256,address)"(
      agent?: null,
      fromPot?: BigNumberish | null,
      toPot?: BigNumberish | null,
      amount?: null,
      token?: null
    ): ColonyFundsMovedBetweenFundingPotsEventFilter;
    ColonyFundsMovedBetweenFundingPots(
      agent?: null,
      fromPot?: BigNumberish | null,
      toPot?: BigNumberish | null,
      amount?: null,
      token?: null
    ): ColonyFundsMovedBetweenFundingPotsEventFilter;

    "ColonyInitialised(address,address,address)"(
      agent?: null,
      colonyNetwork?: null,
      token?: null
    ): ColonyInitialisedEventFilter;
    ColonyInitialised(
      agent?: null,
      colonyNetwork?: null,
      token?: null
    ): ColonyInitialisedEventFilter;

    "ColonyMetadata(address,string)"(
      agent?: null,
      metadata?: null
    ): ColonyMetadataEventFilter;
    ColonyMetadata(agent?: null, metadata?: null): ColonyMetadataEventFilter;

    "ColonyRewardInverseSet(address,uint256)"(
      agent?: null,
      rewardInverse?: null
    ): ColonyRewardInverseSetEventFilter;
    ColonyRewardInverseSet(
      agent?: null,
      rewardInverse?: null
    ): ColonyRewardInverseSetEventFilter;

    "ColonyRoleSet(address,address,uint256,uint8,bool)"(
      agent?: null,
      user?: string | null,
      domainId?: BigNumberish | null,
      role?: BigNumberish | null,
      setTo?: null
    ): ColonyRoleSetEventFilter;
    ColonyRoleSet(
      agent?: null,
      user?: string | null,
      domainId?: BigNumberish | null,
      role?: BigNumberish | null,
      setTo?: null
    ): ColonyRoleSetEventFilter;

    "ColonyUpgraded(address,uint256,uint256)"(
      agent?: null,
      oldVersion?: null,
      newVersion?: null
    ): ColonyUpgradedEventFilter;
    ColonyUpgraded(
      agent?: null,
      oldVersion?: null,
      newVersion?: null
    ): ColonyUpgradedEventFilter;

    "DomainAdded(address,uint256)"(
      agent?: null,
      domainId?: null
    ): DomainAddedEventFilter;
    DomainAdded(agent?: null, domainId?: null): DomainAddedEventFilter;

    "DomainMetadata(address,uint256,string)"(
      agent?: null,
      domainId?: BigNumberish | null,
      metadata?: null
    ): DomainMetadataEventFilter;
    DomainMetadata(
      agent?: null,
      domainId?: BigNumberish | null,
      metadata?: null
    ): DomainMetadataEventFilter;

    "ExpenditureAdded(address,uint256)"(
      agent?: null,
      expenditureId?: null
    ): ExpenditureAddedEventFilter;
    ExpenditureAdded(
      agent?: null,
      expenditureId?: null
    ): ExpenditureAddedEventFilter;

    "ExpenditureCancelled(address,uint256)"(
      agent?: null,
      expenditureId?: BigNumberish | null
    ): ExpenditureCancelledEventFilter;
    ExpenditureCancelled(
      agent?: null,
      expenditureId?: BigNumberish | null
    ): ExpenditureCancelledEventFilter;

    "ExpenditureFinalized(address,uint256)"(
      agent?: null,
      expenditureId?: BigNumberish | null
    ): ExpenditureFinalizedEventFilter;
    ExpenditureFinalized(
      agent?: null,
      expenditureId?: BigNumberish | null
    ): ExpenditureFinalizedEventFilter;

    "ExpenditurePayoutSet(address,uint256,uint256,address,uint256)"(
      agent?: null,
      expenditureId?: BigNumberish | null,
      slot?: BigNumberish | null,
      token?: string | null,
      amount?: null
    ): ExpenditurePayoutSetEventFilter;
    ExpenditurePayoutSet(
      agent?: null,
      expenditureId?: BigNumberish | null,
      slot?: BigNumberish | null,
      token?: string | null,
      amount?: null
    ): ExpenditurePayoutSetEventFilter;

    "ExpenditureRecipientSet(address,uint256,uint256,address)"(
      agent?: null,
      expenditureId?: BigNumberish | null,
      slot?: BigNumberish | null,
      recipient?: string | null
    ): ExpenditureRecipientSetEventFilter;
    ExpenditureRecipientSet(
      agent?: null,
      expenditureId?: BigNumberish | null,
      slot?: BigNumberish | null,
      recipient?: string | null
    ): ExpenditureRecipientSetEventFilter;

    "ExpenditureSkillSet(address,uint256,uint256,uint256)"(
      agent?: null,
      expenditureId?: BigNumberish | null,
      slot?: BigNumberish | null,
      skillId?: BigNumberish | null
    ): ExpenditureSkillSetEventFilter;
    ExpenditureSkillSet(
      agent?: null,
      expenditureId?: BigNumberish | null,
      slot?: BigNumberish | null,
      skillId?: BigNumberish | null
    ): ExpenditureSkillSetEventFilter;

    "ExpenditureTransferred(address,uint256,address)"(
      agent?: null,
      expenditureId?: BigNumberish | null,
      owner?: string | null
    ): ExpenditureTransferredEventFilter;
    ExpenditureTransferred(
      agent?: null,
      expenditureId?: BigNumberish | null,
      owner?: string | null
    ): ExpenditureTransferredEventFilter;

    "FundingPotAdded(uint256)"(fundingPotId?: null): FundingPotAddedEventFilter;
    FundingPotAdded(fundingPotId?: null): FundingPotAddedEventFilter;

    "PaymentAdded(address,uint256)"(
      agent?: null,
      paymentId?: null
    ): PaymentAddedEventFilter;
    PaymentAdded(agent?: null, paymentId?: null): PaymentAddedEventFilter;

    "PaymentFinalized(address,uint256)"(
      agent?: null,
      paymentId?: BigNumberish | null
    ): PaymentFinalizedEventFilter;
    PaymentFinalized(
      agent?: null,
      paymentId?: BigNumberish | null
    ): PaymentFinalizedEventFilter;

    "PaymentPayoutSet(address,uint256,address,uint256)"(
      agent?: null,
      paymentId?: BigNumberish | null,
      token?: null,
      amount?: null
    ): PaymentPayoutSetEventFilter;
    PaymentPayoutSet(
      agent?: null,
      paymentId?: BigNumberish | null,
      token?: null,
      amount?: null
    ): PaymentPayoutSetEventFilter;

    "PaymentRecipientSet(address,uint256,address)"(
      agent?: null,
      paymentId?: BigNumberish | null,
      recipient?: null
    ): PaymentRecipientSetEventFilter;
    PaymentRecipientSet(
      agent?: null,
      paymentId?: BigNumberish | null,
      recipient?: null
    ): PaymentRecipientSetEventFilter;

    "PaymentSkillSet(address,uint256,uint256)"(
      agent?: null,
      paymentId?: BigNumberish | null,
      skillId?: null
    ): PaymentSkillSetEventFilter;
    PaymentSkillSet(
      agent?: null,
      paymentId?: BigNumberish | null,
      skillId?: null
    ): PaymentSkillSetEventFilter;

    "PayoutClaimed(address,uint256,address,uint256)"(
      agent?: null,
      fundingPotId?: BigNumberish | null,
      token?: null,
      amount?: null
    ): PayoutClaimedEventFilter;
    PayoutClaimed(
      agent?: null,
      fundingPotId?: BigNumberish | null,
      token?: null,
      amount?: null
    ): PayoutClaimedEventFilter;

    "RecoveryModeEntered(address)"(user?: null): RecoveryModeEnteredEventFilter;
    RecoveryModeEntered(user?: null): RecoveryModeEnteredEventFilter;

    "RecoveryModeExitApproved(address)"(
      user?: null
    ): RecoveryModeExitApprovedEventFilter;
    RecoveryModeExitApproved(user?: null): RecoveryModeExitApprovedEventFilter;

    "RecoveryModeExited(address)"(user?: null): RecoveryModeExitedEventFilter;
    RecoveryModeExited(user?: null): RecoveryModeExitedEventFilter;

    "RecoveryRoleSet(address,bool)"(
      user?: string | null,
      setTo?: null
    ): RecoveryRoleSetEventFilter;
    RecoveryRoleSet(
      user?: string | null,
      setTo?: null
    ): RecoveryRoleSetEventFilter;

    "RecoveryStorageSlotSet(address,uint256,bytes32,bytes32)"(
      user?: null,
      slot?: null,
      fromValue?: null,
      toValue?: null
    ): RecoveryStorageSlotSetEventFilter;
    RecoveryStorageSlotSet(
      user?: null,
      slot?: null,
      fromValue?: null,
      toValue?: null
    ): RecoveryStorageSlotSetEventFilter;

    "RewardPayoutClaimed(uint256,address,uint256,uint256)"(
      rewardPayoutId?: null,
      user?: null,
      fee?: null,
      rewardRemainder?: null
    ): RewardPayoutClaimedEventFilter;
    RewardPayoutClaimed(
      rewardPayoutId?: null,
      user?: null,
      fee?: null,
      rewardRemainder?: null
    ): RewardPayoutClaimedEventFilter;

    "RewardPayoutCycleEnded(address,uint256)"(
      agent?: null,
      rewardPayoutId?: null
    ): RewardPayoutCycleEndedEventFilter;
    RewardPayoutCycleEnded(
      agent?: null,
      rewardPayoutId?: null
    ): RewardPayoutCycleEndedEventFilter;

    "RewardPayoutCycleStarted(address,uint256)"(
      agent?: null,
      rewardPayoutId?: null
    ): RewardPayoutCycleStartedEventFilter;
    RewardPayoutCycleStarted(
      agent?: null,
      rewardPayoutId?: null
    ): RewardPayoutCycleStartedEventFilter;

    "TaskAdded(address,uint256)"(
      agent?: null,
      taskId?: null
    ): TaskAddedEventFilter;
    TaskAdded(agent?: null, taskId?: null): TaskAddedEventFilter;

    "TaskBriefSet(uint256,bytes32)"(
      taskId?: BigNumberish | null,
      specificationHash?: null
    ): TaskBriefSetEventFilter;
    TaskBriefSet(
      taskId?: BigNumberish | null,
      specificationHash?: null
    ): TaskBriefSetEventFilter;

    "TaskCanceled(uint256)"(
      taskId?: BigNumberish | null
    ): TaskCanceledEventFilter;
    TaskCanceled(taskId?: BigNumberish | null): TaskCanceledEventFilter;

    "TaskChangedViaSignatures(address[])"(
      reviewerAddresses?: null
    ): TaskChangedViaSignaturesEventFilter;
    TaskChangedViaSignatures(
      reviewerAddresses?: null
    ): TaskChangedViaSignaturesEventFilter;

    "TaskCompleted(address,uint256)"(
      agent?: null,
      taskId?: BigNumberish | null
    ): TaskCompletedEventFilter;
    TaskCompleted(
      agent?: null,
      taskId?: BigNumberish | null
    ): TaskCompletedEventFilter;

    "TaskDeliverableSubmitted(address,uint256,bytes32)"(
      agent?: null,
      taskId?: BigNumberish | null,
      deliverableHash?: null
    ): TaskDeliverableSubmittedEventFilter;
    TaskDeliverableSubmitted(
      agent?: null,
      taskId?: BigNumberish | null,
      deliverableHash?: null
    ): TaskDeliverableSubmittedEventFilter;

    "TaskDueDateSet(uint256,uint256)"(
      taskId?: BigNumberish | null,
      dueDate?: null
    ): TaskDueDateSetEventFilter;
    TaskDueDateSet(
      taskId?: BigNumberish | null,
      dueDate?: null
    ): TaskDueDateSetEventFilter;

    "TaskFinalized(address,uint256)"(
      agent?: null,
      taskId?: BigNumberish | null
    ): TaskFinalizedEventFilter;
    TaskFinalized(
      agent?: null,
      taskId?: BigNumberish | null
    ): TaskFinalizedEventFilter;

    "TaskPayoutSet(uint256,uint8,address,uint256)"(
      taskId?: BigNumberish | null,
      role?: null,
      token?: null,
      amount?: null
    ): TaskPayoutSetEventFilter;
    TaskPayoutSet(
      taskId?: BigNumberish | null,
      role?: null,
      token?: null,
      amount?: null
    ): TaskPayoutSetEventFilter;

    "TaskRoleUserSet(uint256,uint8,address)"(
      taskId?: BigNumberish | null,
      role?: null,
      user?: string | null
    ): TaskRoleUserSetEventFilter;
    TaskRoleUserSet(
      taskId?: BigNumberish | null,
      role?: null,
      user?: string | null
    ): TaskRoleUserSetEventFilter;

    "TaskSkillSet(uint256,uint256)"(
      taskId?: BigNumberish | null,
      skillId?: BigNumberish | null
    ): TaskSkillSetEventFilter;
    TaskSkillSet(
      taskId?: BigNumberish | null,
      skillId?: BigNumberish | null
    ): TaskSkillSetEventFilter;

    "TaskWorkRatingRevealed(address,uint256,uint8,uint8)"(
      agent?: null,
      taskId?: BigNumberish | null,
      role?: null,
      rating?: null
    ): TaskWorkRatingRevealedEventFilter;
    TaskWorkRatingRevealed(
      agent?: null,
      taskId?: BigNumberish | null,
      role?: null,
      rating?: null
    ): TaskWorkRatingRevealedEventFilter;

    "TokenUnlocked()"(): TokenUnlockedEventFilter;
    TokenUnlocked(): TokenUnlockedEventFilter;

    "TokensBurned(address,address,uint256)"(
      agent?: null,
      token?: null,
      amount?: null
    ): TokensBurnedEventFilter;
    TokensBurned(
      agent?: null,
      token?: null,
      amount?: null
    ): TokensBurnedEventFilter;

    "TokensMinted(address,address,uint256)"(
      agent?: null,
      who?: null,
      amount?: null
    ): TokensMintedEventFilter;
    TokensMinted(
      agent?: null,
      who?: null,
      amount?: null
    ): TokensMintedEventFilter;
  };

  estimateGas: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the `ColonyAuthority` for the colony.
     */
    authority(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Used for testing.
     * Get the colony `owner` address. This should be address(0x0) at all times.
     */
    owner(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the Colony contract version. Starts from 1 and is incremented with every deployed contract change.
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Downgrades are not allowed, i.e. `_newVersion` should be higher than the currect colony version.
     * Upgrades a colony to a new Colony contract version `_newVersion`.
     * @param _newVersion The target version for the upgrade
     */
    upgrade(
      _newVersion: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Can only be called by the colony itself, and only expected to be called as part of the `upgrade()` call. Required to be external so it can be an external call.
     * A function to be called after an upgrade has been done from v2 to v3.
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * The colonyNetworkAddress we read here is set once, during `initialiseColony`.
     * Returns the colony network address set on the Colony.
     */
    getColonyNetwork(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the colony token.
     */
    getToken(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Execute arbitrary transaction on behalf of the Colony
     * @param _action Bytes array encoding the function call and arguments
     * @param _to Contract to receive the function call (cannot be network or token locking)
     */
    makeArbitraryTransaction(
      _to: string,
      _action: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Emit a metadata string for a transaction
     * @param _metadata String of metadata for tx
     * @param _txHash Hash of transaction being annotated (0x0 for current tx)
     */
    annotateTransaction(
      _txHash: BytesLike,
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set new colony root role. Can be called by root role only.
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an root role to
     */
    setRootRole(
      _user: string,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set new colony arbitration role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an arbitration role to
     */
    setArbitrationRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set new colony architecture role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an architecture role to
     */
    setArchitectureRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set new colony funding role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an funding role to
     */
    setFundingRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set new colony admin role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an admin role to
     */
    setAdministrationRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set several roles in one transaction. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _roles Byte array representing the desired role setting (1 for on, 0 for off)
     * @param _user User we want to give a role to
     */
    setUserRoles(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _roles: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Check whether a given user has a given role for the colony. Calls the function of the same name on the colony's authority contract.
     * @param _domainId The domain where we want to check for the role
     * @param _role The role we want to check for
     * @param _user The user whose role we want to check
     */
    hasUserRole(
      _user: string,
      _domainId: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Check whether a given user has a given role for the colony, in a child domain. Calls the function of the same name on the colony's authority contract and an internal inheritence validator function
     * @param _childDomainId The domain where we want to use the role
     * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
     * @param _domainId Domain in which the caller has the role
     * @param _role The role we want to check for
     * @param _user The user whose role we want to check
     */
    hasInheritedUserRole(
      _user: string,
      _domainId: BigNumberish,
      _role: BigNumberish,
      _childSkillIndex: BigNumberish,
      _childDomainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Check whether a given user can modify roles in the target domain `_childDomainId`. Mostly a convenience function to provide a uniform interface for extension contracts validating permissions
     * @param _childDomainId The domain where we want to edit roles
     * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
     * @param _domainId Domain in which the caller has the role (currently Root or Architecture)
     * @param _user The user whose permissions we want to check
     */
    userCanSetRoles(
      _user: string,
      _domainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _childDomainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the bytes32 representation of the roles for a user in a given domain
     * @param _domain The domain we want to get roles in
     * @param _user The user whose roles we want to get
     */
    getUserRoles(
      _user: string,
      _domain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the bytes32 representation of the roles authorized to call a function
     * @param _sig The function signature
     */
    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Emit a positive domain reputation update. Available only to Root role holders
     * @param _amount The (positive) amount of reputation to gain
     * @param _domainId The domain where the user will gain reputation
     * @param _user The user who will gain reputation
     */
    emitDomainReputationReward(
      _domainId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Emit a positive skill reputation update. Available only to Root role holders
     * @param _amount The (positive) amount of reputation to gain
     * @param _skillId The skill where the user will gain reputation
     * @param _user The user who will gain reputation
     */
    emitSkillReputationReward(
      _skillId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Emit a negative domain reputation update. Available only to Arbitration role holders
     * @param _amount The (negative) amount of reputation to lose
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId The domain where the user will lose reputation
     * @param _permissionDomainId The domainId in which I hold the Arbitration role
     * @param _user The user who will lose reputation
     */
    emitDomainReputationPenalty(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Emit a negative skill reputation update. Available only to Arbitration role holders in the root domain
     * @param _amount The (negative) amount of reputation to lose
     * @param _skillId The skill where the user will lose reputation
     * @param _user The user who will lose reputation
     */
    emitSkillReputationPenalty(
      _skillId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Sets the reward inverse to the uint max 2**256 - 1.
     * Called once when the colony is created to initialise certain storage slot values.
     * @param _colonyNetworkAddress Address of the colony network
     * @param _token Address of the colony ERC20 Token
     */
    initialiseColony(
      _colonyNetworkAddress: string,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Called to change the metadata associated with a colony. Expected to be a IPFS hash of a JSON blob, but not enforced to any degree by the contracts
     * @param _metadata IPFS hash of the metadata
     */
    editColony(
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Only allowed to be called when `taskCount` is `0` by authorized addresses.
     * Allows the colony to bootstrap itself by having initial reputation and token `_amount` assigned to `_users`. This reputation is assigned in the colony-wide domain. Secured function to authorised members.
     * @param _amount Amount of reputation/tokens for every address
     * @param _users Array of address to bootstrap with reputation
     */
    bootstrapColony(
      _users: string[],
      _amount: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Mint `_wad` amount of colony tokens. Secured function to authorised members.
     * @param _wad Amount to mint
     */
    mintTokens(
      _wad: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Mint `_wad` amount of colony tokens and send to `_guy`. Secured function to authorised members.
     * @param _guy Recipient of new tokens
     * @param _wad Amount to mint
     */
    mintTokensFor(
      _guy: string,
      _wad: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Lock the colony's token. Can only be called by a network-managed extension.
     */
    lockToken(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Unlock the colony's token for a user. Can only be called by a network-managed extension.
     * @param lockId The specific lock to unlock
     * @param user The user to unlock
     */
    unlockTokenForUser(
      user: string,
      lockId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Register colony's ENS label.
     * @param colonyName The label to register.
     * @param orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      colonyName: string,
      orbitdb: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      orbitdb: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Install an extension to the colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version The new extension version to install
     */
    installExtension(
      extensionId: BytesLike,
      version: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Upgrade an extension in a colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param newVersion The version to upgrade to (must be one larger than the current version)
     */
    upgradeExtension(
      extensionId: BytesLike,
      newVersion: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set the deprecation of an extension in a colony. Secured function to authorised members.
     * @param deprecated Whether to deprecate the extension or not
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      extensionId: BytesLike,
      deprecated: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * This is a permanent action -- re-installing the extension will deploy a new contractIt is recommended to deprecate an extension before uninstalling to allow active objects to be resolved
     * Uninstall an extension from a colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      extensionId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _parentDomainId Id of the domain under which the new one will be added
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    "addDomain(uint256,uint256,uint256)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _parentDomainId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.We expect this function to only be used by the dapp
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
     * @param _parentDomainId Id of the domain under which the new one will be added
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    "addDomain(uint256,uint256,uint256,string)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _parentDomainId: BigNumberish,
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Id of the domain being edited
     * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    editDomain(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get a domain by id.
     * @param _id Id of the domain which details to get
     */
    getDomain(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the number of domains in the colony.
     */
    getDomainCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * For more detail about branchMask and siblings, examine the PatriciaTree implementation. While external, likely only to be used by the Colony contracts, as it checks that the user is proving their own reputation in the current colony. The `verifyProof` function can be used to verify any proof, though this function is not currently exposed on the Colony's EtherRouter.
     * Helper function that can be used by a client to verify the correctness of a patricia proof they have been supplied with.
     * @param branchMask The branchmask of the proof
     * @param key The key of the element the proof is for.
     * @param siblings The siblings of the proof
     * @param value The value of the element that the proof is for.
     */
    verifyReputationProof(
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Add a new expenditure in the colony. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _domainId The domain where the expenditure belongs
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    makeExpenditure(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Updates the expenditure owner. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     * @param _newOwner New owner of expenditure
     */
    transferExpenditure(
      _id: BigNumberish,
      _newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * This is now deprecated and will be removed in a future version
     * DEPRECATED Updates the expenditure owner. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _newOwner New owner of expenditure
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    transferExpenditureViaArbitration(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Cancels the expenditure and prevents further editing. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     */
    cancelExpenditure(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Finalizes the expenditure and prevents further editing. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     */
    finalizeExpenditure(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Sets the recipient on an expenditure slot. Can only be called by expenditure owner.
     * @param _id Id of the expenditure
     * @param _recipient Address of the recipient
     * @param _slot Slot for the recipient address
     */
    setExpenditureRecipient(
      _id: BigNumberish,
      _slot: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set the token payout on an expenditure slot. Can only be called by expenditure owner.
     * @param _amount Payout amount
     * @param _id Id of the expenditure
     * @param _slot Number of the slot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setExpenditurePayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Sets the skill on an expenditure slot. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     * @param _skillId Id of the new skill to set
     * @param _slot Number of the slot
     */
    setExpenditureSkill(
      _id: BigNumberish,
      _slot: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * This is now deprecated and will be removed in a future versionNote that when determining payouts the payoutModifier is incremented by WAD and converted into payoutScalar
     * DEPRECATED Set the payout modifier on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _payoutModifier Modifier to their payout (between -1 and 1, denominated in WADs, 0 means no modification)
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _slot Number of the slot
     */
    setExpenditurePayoutModifier(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _slot: BigNumberish,
      _payoutModifier: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * This is now deprecated and will be removed in a future version
     * DEPRECATED Set the claim delay on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _claimDelay Time (in seconds) to delay claiming payout after finalization
     * @param _id Expenditure identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _slot Number of the slot
     */
    setExpenditureClaimDelay(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _slot: BigNumberish,
      _claimDelay: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set arbitrary state on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _keys Array of additional keys (for mappings & arrays)
     * @param _mask Array of booleans indicated whether a key is a mapping (F) or an array index (T).
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _storageSlot Number of the top-level storage slot (25, 26, or 27)
     * @param _value Value to set at location
     */
    setExpenditureState(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _storageSlot: BigNumberish,
      _mask: boolean[],
      _keys: BytesLike[],
      _value: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Claim the payout for an expenditure slot. Here the network receives a fee from each payout.
     * @param _id Expenditure identifier
     * @param _slot Number of the slot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimExpenditurePayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the number of expenditures in the colony.
     */
    getExpenditureCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns an existing expenditure.
     * @param _id Expenditure identifier
     */
    getExpenditure(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns an existing expenditure slot.
     * @param _id Expenditure identifier
     * @param _slot Expenditure slot
     */
    getExpenditureSlot(
      _id: BigNumberish,
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns an existing expenditure slot's payout for a token.
     * @param _id Expenditure identifier
     * @param _slot Expenditure slot
     * @param _token Token address
     */
    getExpenditureSlotPayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Add a new payment in the colony. Secured function to authorised members.
     * @param _amount Payout amount
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _domainId The domain where the payment belongs
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _recipient Address of the payment recipient
     * @param _skillId The skill associated with the payment
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    addPayment(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _recipient: string,
      _token: string,
      _amount: BigNumberish,
      _domainId: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Finalizes the payment and logs the reputation log updates. Allowed to be called once after payment is fully funded. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    finalizePayment(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Sets the recipient on an existing payment. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _recipient Address of the payment recipient
     */
    setPaymentRecipient(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Sets the skill on an existing payment. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _skillId Id of the new skill to set
     */
    setPaymentSkill(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Sets the payout for a given token on an existing payment. Secured function to authorised members.
     * @param _amount Payout amount
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setPaymentPayout(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Returns an exiting payment.
     * @param _id Payment identifier
     */
    getPayment(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Claim the payout in `_token` denomination for payment `_id`. Here the network receives its fee from each payout. Same as for tasks, ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
     * @param _id Payment identifier
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimPayment(
      _id: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the number of payments in the colony.
     */
    getPaymentCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Make a new task in the colony. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId The domain where the task belongs
     * @param _dueDate The due date of the task, can set to `0` for no-op
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _skillId The skill associated with the task, can set to `0` for no-op
     * @param _specificationHash Database identifier where the task specification is stored
     */
    makeTask(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _specificationHash: BytesLike,
      _domainId: BigNumberish,
      _skillId: BigNumberish,
      _dueDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the number of tasks in the colony.
     */
    getTaskCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Starts from 0 and is incremented on every co-reviewed task change via `executeTaskChange` call.
     * @param _id Id of the task
     */
    getTaskChangeNonce(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * The Colony functions which require approval and the task roles to review these are set in `IColony.initialiseColony` at colony creation. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
     * Executes a task update transaction `_data` which is approved and signed by two of its roles (e.g. manager and worker) using the detached signatures for these users.
     * @param _data The transaction data
     * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
     * @param _sigR r output of the ECDSA signature of the transaction
     * @param _sigS s output of the ECDSA signature of the transaction
     * @param _sigV recovery id
     * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
     */
    executeTaskChange(
      _sigV: BigNumberish[],
      _sigR: BytesLike[],
      _sigS: BytesLike[],
      _mode: BigNumberish[],
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Executes a task role update transaction `_data` which is approved and signed by two of addresses. depending of which function we are calling. Allowed functions are `setTaskManagerRole`, `setTaskEvaluatorRole` and `setTaskWorkerRole`. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
     * @param _data The transaction data
     * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
     * @param _sigR r output of the ECDSA signature of the transaction
     * @param _sigS s output of the ECDSA signature of the transaction
     * @param _sigV recovery id
     * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
     */
    executeTaskRoleAssignment(
      _sigV: BigNumberish[],
      _sigR: BytesLike[],
      _sigS: BytesLike[],
      _mode: BigNumberish[],
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Submit a hashed secret of the rating for work in task `_id` which was performed by user with task role id `_role`. Allowed within 5 days period starting which whichever is first from either the deliverable being submitted or the dueDate been reached. Allowed only for evaluator to rate worker and for worker to rate manager performance. Once submitted ratings can not be changed or overwritten.
     * @param _id Id of the task
     * @param _ratingSecret `keccak256` hash of a salt and 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50). Can be generated via `IColony.generateSecret` helper function.
     * @param _role Id of the role, as defined in TaskRole enum
     */
    submitTaskWorkRating(
      _id: BigNumberish,
      _role: BigNumberish,
      _ratingSecret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Compares the `keccak256(_salt, _rating)` output with the previously submitted rating secret and if they match, sets the task role properties `rated` to `true` and `rating` to `_rating`.
     * Reveal the secret rating submitted in `IColony.submitTaskWorkRating` for task `_id` and task role with id `_role`. Allowed within 5 days period starting which whichever is first from either both rating secrets being submitted (via `IColony.submitTaskWorkRating`) or the 5 day rating period expiring.
     * @param _id Id of the task
     * @param _rating 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50)
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _salt Salt value used to generate the rating secret
     */
    revealTaskWorkRating(
      _id: BigNumberish,
      _role: BigNumberish,
      _rating: BigNumberish,
      _salt: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Helper function used to generage consistently the rating secret using salt value `_salt` and value to hide `_value`
     * @param _salt Salt value
     * @param _value Value to hide
     */
    generateSecret(
      _salt: BytesLike,
      _value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `ColonyStorage.RatingSecrets` information for task `_id`.
     * @param _id Id of the task
     */
    getTaskWorkRatingSecretsInfo(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the rating secret submitted for role `_role` in task `_id`
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     */
    getTaskWorkRatingSecret(
      _id: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning manager role. Current manager and user we want to assign role to both need to agree. User we want to set here also needs to be an admin. Note that the domain proof data comes at the end here to not interfere with the assembly argument unpacking.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Id of the task
     * @param _permissionDomainId The domain ID in which _user has the Administration permission
     * @param _user Address of the user we want to give a manager role to
     */
    setTaskManagerRole(
      _id: BigNumberish,
      _user: string,
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning evaluator role. Can only be set if there is no one currently assigned to be an evaluator. Manager of the task and user we want to assign role to both need to agree. Managers can assign themselves to this role, if there is no one currently assigned to it.
     * @param _id Id of the task
     * @param _user Address of the user we want to give a evaluator role to
     */
    setTaskEvaluatorRole(
      _id: BigNumberish,
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning worker role. Can only be set if there is no one currently assigned to be a worker. Manager of the task and user we want to assign role to both need to agree.
     * @param _id Id of the task
     * @param _user Address of the user we want to give a worker role to
     */
    setTaskWorkerRole(
      _id: BigNumberish,
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Removing evaluator role. Agreed between manager and currently assigned evaluator.
     * @param _id Id of the task
     */
    removeTaskEvaluatorRole(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Removing worker role. Agreed between manager and currently assigned worker.
     * @param _id Id of the task
     */
    removeTaskWorkerRole(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Currently we only allow one skill per task although we have provisioned for an array of skills in `Task` struct. Allowed before a task is finalized.
     * Set the skill for task `_id`.
     * @param _id Id of the task
     * @param _skillId Id of the skill which has to be a global skill
     */
    setTaskSkill(
      _id: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set the hash for the task brief, aka task work specification, which identifies the task brief content in ddb. Allowed before a task is finalized.
     * @param _id Id of the task
     * @param _specificationHash Unique hash of the task brief in ddb
     */
    setTaskBrief(
      _id: BigNumberish,
      _specificationHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set the due date on task `_id`. Allowed before a task is finalized.
     * @param _dueDate Due date as seconds since unix epoch
     * @param _id Id of the task
     */
    setTaskDueDate(
      _id: BigNumberish,
      _dueDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set the `task.deliverableHash` and `task.completionTimestamp` properties.
     * Submit the task deliverable, i.e. the output of the work performed for task `_id`. Submission is allowed only to the assigned worker before the task due date. Submissions cannot be overwritten.
     * @param _deliverableHash Unique hash of the task deliverable content in ddb
     * @param _id Id of the task
     */
    submitTaskDeliverable(
      _id: BigNumberish,
      _deliverableHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Internally call `submitTaskDeliverable` and `submitTaskWorkRating` in sequence.
     * Submit the task deliverable for Worker and rating for Manager.
     * @param _deliverableHash Unique hash of the task deliverable content in ddb
     * @param _id Id of the task
     * @param _ratingSecret Rating secret for manager
     */
    submitTaskDeliverableAndRating(
      _id: BigNumberish,
      _deliverableHash: BytesLike,
      _ratingSecret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set the `task.finalized` property to true
     * Called after task work rating is complete which closes the task and logs the respective reputation log updates. Allowed to be called once per task. Secured function to authorised members.
     * @param _id Id of the task
     */
    finalizeTask(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set the `task.status` property to `1`.
     * Cancel a task at any point before it is finalized. Secured function to authorised members. Any funds assigned to its funding pot can be moved back to the domain via `IColony.moveFundsBetweenPots`.
     * @param _id Id of the task
     */
    cancelTask(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Mark a task as complete after the due date has passed. This allows the task to be rated and finalized (and funds recovered) even in the presence of a worker who has disappeared. Note that if the due date was not set, then this function will throw.
     * @param _id Id of the task
     */
    completeTask(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get a task with id `_id`
     * @param _id Id of the task
     */
    getTask(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the `Role` properties back for role `_role` in task `_id`.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     */
    getTaskRole(
      _id: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set the reward inverse to pay out from revenue. e.g. if the fee is 1% (or 0.01), set 100.
     * @param _rewardInverse The inverse of the reward
     */
    setRewardInverse(
      _rewardInverse: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Return 1 / the reward to pay out from revenue. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getRewardInverse(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get payout amount in `_token` denomination for role `_role` in task `_id`.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getTaskPayout(
      _id: BigNumberish,
      _role: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set `_token` payout for manager in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskManagerPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set `_token` payout for evaluator in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskEvaluatorPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set `_token` payout for worker in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskWorkerPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Can only call if evaluator and worker are unassigned or manager, otherwise need signature.
     * Set `_token` payout for all roles in task `_id` to the respective amounts.
     * @param _evaluatorAmount Payout amount for evaluator
     * @param _id Id of the task
     * @param _managerAmount Payout amount for manager
     * @param _token Address of the token, `0x0` value indicates Ether
     * @param _workerAmount Payout amount for worker
     */
    setAllTaskPayouts(
      _id: BigNumberish,
      _token: string,
      _managerAmount: BigNumberish,
      _evaluatorAmount: BigNumberish,
      _workerAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Claim the payout in `_token` denomination for work completed in task `_id` by contributor with role `_role`. Allowed only after task is finalized. Here the network receives its fee from each payout. Ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimTaskPayout(
      _id: BigNumberish,
      _role: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Start next reward payout for `_token`. All funds in the reward pot for `_token` will become unavailable.Add a new payment in the colony. Can only be called by users with root permission. All tokens will be locked, and can be unlocked by calling `waiveRewardPayout` or `claimRewardPayout`.
     * @param _token Address of the token used for reward payout
     * @param branchMask The branchmask of the proof
     * @param key Some Reputation hash tree key
     * @param siblings The siblings of the proof
     * @param value Reputation value
     */
    startNextRewardPayout(
      _token: string,
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Claim the reward payout at `_payoutId`. User needs to provide their reputation and colony-wide reputation which will be proven via Merkle proof inside this function. Can only be called if payout is active, i.e if 60 days have not passed from its creation. Can only be called if next in queue.
     * @param _payoutId Id of the reward payout
     * @param _squareRoots Square roots of values used in equation: `_squareRoots[0]` - square root of user reputation, `_squareRoots[1]` - square root of user tokens (deposited in TokenLocking), `_squareRoots[2]` - square root of total reputation, `_squareRoots[3]` - square root of total tokens, `_squareRoots[4]` - square root of numerator (user reputation * user tokens), `_squareRoots[5]` - square root of denominator (total reputation * total tokens), `_squareRoots[6]` - square root of payout amount.
     * @param branchMask The branchmask of the proof
     * @param key Some Reputation hash tree key
     * @param siblings The siblings of the proof
     * @param value Reputation value
     */
    claimRewardPayout(
      _payoutId: BigNumberish,
      _squareRoots: BigNumberish[],
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get useful information about specific reward payout.
     * @param _payoutId Id of the reward payout
     */
    getRewardPayoutInfo(
      _payoutId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Finalises the reward payout. Allows creation of next reward payouts for token that has been used in `_payoutId`. Can only be called when reward payout cycle is finished i.e when 60 days have passed from its creation.
     * @param _payoutId Id of the reward payout
     */
    finalizeRewardPayout(
      _payoutId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * For the reward funding pot (e.g. id: 0) this returns (0, 0, 0).
     * Get the non-mapping properties of a pot by id.
     * @param _id Id of the pot which details to get
     */
    getFundingPot(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the number of funding pots in the colony.
     */
    getFundingPotCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the `_token` balance of pot with id `_potId`.
     * @param _potId Id of the funding pot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getFundingPotBalance(
      _potId: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the assigned `_token` payouts of pot with id `_potId`.
     * @param _potId Id of the funding pot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getFundingPotPayout(
      _potId: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Move a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
     * @param _amount Amount of funds
     * @param _childSkillIndex The child index in _permissionDomainId where I will be taking this action
     * @param _domainId The domain where I am taking this action, pointed to by _permissionDomainId and _childSkillIndex
     * @param _fromChildSkillIndex In the array of child skills for the skill associated with the domain pointed to by _permissionDomainId + _childSkillIndex,         the index of the skill associated with the domain that contains _fromPot
     * @param _fromPot Funding pot id providing the funds
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _toChildSkillIndex The same, but for the _toPot which the funds are being moved to
     * @param _toPot Funding pot id receiving the funds
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _fromChildSkillIndex: BigNumberish,
      _toChildSkillIndex: BigNumberish,
      _fromPot: BigNumberish,
      _toPot: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * DEPRECATEDMove a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
     * @param _amount Amount of funds
     * @param _fromChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_fromPotId`
     * @param _fromPot Funding pot id providing the funds
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _toChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_toPotId`
     * @param _toPot Funding pot id receiving the funds
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,address)"(
      _permissionDomainId: BigNumberish,
      _fromChildSkillIndex: BigNumberish,
      _toChildSkillIndex: BigNumberish,
      _fromPot: BigNumberish,
      _toPot: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Move any funds received by the colony in `_token` denomination to the top-level domain pot, siphoning off a small amount to the reward pot. If called against a colony's own token, no fee is taken.
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimColonyFunds(
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the total amount of tokens `_token` minus amount reserved to be paid to the reputation and token holders as rewards.
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getNonRewardPotsTotal(
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Allow the _approvee to obligate some amount of tokens as a stake.
     * @param _amount Amount of internal token up to which we are willing to be obligated.
     * @param _approvee Address of the account we are willing to let obligate us.
     * @param _domainId Domain in which we are willing to be obligated.
     */
    approveStake(
      _approvee: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Obligate the user some amount of tokens as a stake.
     * @param _amount Amount of internal token we are obligating.
     * @param _domainId Domain in which we are obligating the user.
     * @param _user Address of the account we are obligating.
     */
    obligateStake(
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Deobligate the user some amount of tokens, releasing the stake.
     * @param _amount Amount of internal token we are deobligating.
     * @param _domainId Domain in which we are deobligating the user.
     * @param _user Address of the account we are deobligating.
     */
    deobligateStake(
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Transfer some amount of obligated tokens. Can be called by the arbitration role.
     * @param _amount Amount of internal token we are transferring.
     * @param _childSkillIndex The child index in `_permissionDomainId` where we can find `_domainId`.
     * @param _domainId Domain in which we are transferring the tokens.
     * @param _obligator Address of the account who set the obligation.
     * @param _permissionDomainId The domainId in which I have the permission to take this action.
     * @param _recipient Recipient of the transferred tokens.
     * @param _user Address of the account we are transferring.
     */
    transferStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _obligator: string,
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * View an approval to obligate tokens.
     * @param _domainId Domain in which we are willing to be obligated.
     * @param _obligator Address of the account we are willing to let obligate us.
     * @param _user User allowing their tokens to be obligated.
     */
    getApproval(
      _user: string,
      _obligator: string,
      _domainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * View an obligation of tokens.
     * @param _domainId Domain in which we are obligated.
     * @param _obligator Address of the account who obligated us.
     * @param _user User whose tokens are obligated.
     */
    getObligation(
      _user: string,
      _obligator: string,
      _domainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the domain corresponding to a funding pot
     * @param _fundingPotId Id of the funding pot
     */
    getDomainFromFundingPot(
      _fundingPotId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Burn tokens held by the colony. Can only burn tokens held in the root funding pot.
     * @param amount The amount of tokens to burn
     * @param token The address of the token to burn
     */
    burnTokens(
      token: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * unlock the native colony token, if possible
     */
    unlockToken(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Update the internal bookkeeping around external ERC20 approvals
     * @param spender The account we have approved
     * @param token The address of the token which was approved
     */
    updateApprovalAmount(
      token: string,
      spender: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the current approval amount
     * @param spender The account we have approved
     * @param token The address of the token which was approved
     */
    getTokenApproval(
      token: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the current total approval amount across all spenders
     * @param token The address of the token which was approved
     */
    getTotalTokenApproval(
      token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the `ColonyAuthority` for the colony.
     */
    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Used for testing.
     * Get the colony `owner` address. This should be address(0x0) at all times.
     */
    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the Colony contract version. Starts from 1 and is incremented with every deployed contract change.
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Downgrades are not allowed, i.e. `_newVersion` should be higher than the currect colony version.
     * Upgrades a colony to a new Colony contract version `_newVersion`.
     * @param _newVersion The target version for the upgrade
     */
    upgrade(
      _newVersion: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Can only be called by the colony itself, and only expected to be called as part of the `upgrade()` call. Required to be external so it can be an external call.
     * A function to be called after an upgrade has been done from v2 to v3.
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * The colonyNetworkAddress we read here is set once, during `initialiseColony`.
     * Returns the colony network address set on the Colony.
     */
    getColonyNetwork(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the colony token.
     */
    getToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Execute arbitrary transaction on behalf of the Colony
     * @param _action Bytes array encoding the function call and arguments
     * @param _to Contract to receive the function call (cannot be network or token locking)
     */
    makeArbitraryTransaction(
      _to: string,
      _action: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Emit a metadata string for a transaction
     * @param _metadata String of metadata for tx
     * @param _txHash Hash of transaction being annotated (0x0 for current tx)
     */
    annotateTransaction(
      _txHash: BytesLike,
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set new colony root role. Can be called by root role only.
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an root role to
     */
    setRootRole(
      _user: string,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set new colony arbitration role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an arbitration role to
     */
    setArbitrationRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set new colony architecture role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an architecture role to
     */
    setArchitectureRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set new colony funding role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an funding role to
     */
    setFundingRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set new colony admin role. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _setTo The state of the role permission (true assign the permission, false revokes it)
     * @param _user User we want to give an admin role to
     */
    setAdministrationRole(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _setTo: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set several roles in one transaction. Can be called by root role or architecture role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Domain in which we are giving user the role
     * @param _permissionDomainId Domain in which the caller has root/architecture role
     * @param _roles Byte array representing the desired role setting (1 for on, 0 for off)
     * @param _user User we want to give a role to
     */
    setUserRoles(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _user: string,
      _domainId: BigNumberish,
      _roles: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Check whether a given user has a given role for the colony. Calls the function of the same name on the colony's authority contract.
     * @param _domainId The domain where we want to check for the role
     * @param _role The role we want to check for
     * @param _user The user whose role we want to check
     */
    hasUserRole(
      _user: string,
      _domainId: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Check whether a given user has a given role for the colony, in a child domain. Calls the function of the same name on the colony's authority contract and an internal inheritence validator function
     * @param _childDomainId The domain where we want to use the role
     * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
     * @param _domainId Domain in which the caller has the role
     * @param _role The role we want to check for
     * @param _user The user whose role we want to check
     */
    hasInheritedUserRole(
      _user: string,
      _domainId: BigNumberish,
      _role: BigNumberish,
      _childSkillIndex: BigNumberish,
      _childDomainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Check whether a given user can modify roles in the target domain `_childDomainId`. Mostly a convenience function to provide a uniform interface for extension contracts validating permissions
     * @param _childDomainId The domain where we want to edit roles
     * @param _childSkillIndex The index that the `_childDomainId` is relative to `_domainId`
     * @param _domainId Domain in which the caller has the role (currently Root or Architecture)
     * @param _user The user whose permissions we want to check
     */
    userCanSetRoles(
      _user: string,
      _domainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _childDomainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the bytes32 representation of the roles for a user in a given domain
     * @param _domain The domain we want to get roles in
     * @param _user The user whose roles we want to get
     */
    getUserRoles(
      _user: string,
      _domain: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the bytes32 representation of the roles authorized to call a function
     * @param _sig The function signature
     */
    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Emit a positive domain reputation update. Available only to Root role holders
     * @param _amount The (positive) amount of reputation to gain
     * @param _domainId The domain where the user will gain reputation
     * @param _user The user who will gain reputation
     */
    emitDomainReputationReward(
      _domainId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Emit a positive skill reputation update. Available only to Root role holders
     * @param _amount The (positive) amount of reputation to gain
     * @param _skillId The skill where the user will gain reputation
     * @param _user The user who will gain reputation
     */
    emitSkillReputationReward(
      _skillId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Emit a negative domain reputation update. Available only to Arbitration role holders
     * @param _amount The (negative) amount of reputation to lose
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId The domain where the user will lose reputation
     * @param _permissionDomainId The domainId in which I hold the Arbitration role
     * @param _user The user who will lose reputation
     */
    emitDomainReputationPenalty(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Emit a negative skill reputation update. Available only to Arbitration role holders in the root domain
     * @param _amount The (negative) amount of reputation to lose
     * @param _skillId The skill where the user will lose reputation
     * @param _user The user who will lose reputation
     */
    emitSkillReputationPenalty(
      _skillId: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the reward inverse to the uint max 2**256 - 1.
     * Called once when the colony is created to initialise certain storage slot values.
     * @param _colonyNetworkAddress Address of the colony network
     * @param _token Address of the colony ERC20 Token
     */
    initialiseColony(
      _colonyNetworkAddress: string,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called to change the metadata associated with a colony. Expected to be a IPFS hash of a JSON blob, but not enforced to any degree by the contracts
     * @param _metadata IPFS hash of the metadata
     */
    editColony(
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Only allowed to be called when `taskCount` is `0` by authorized addresses.
     * Allows the colony to bootstrap itself by having initial reputation and token `_amount` assigned to `_users`. This reputation is assigned in the colony-wide domain. Secured function to authorised members.
     * @param _amount Amount of reputation/tokens for every address
     * @param _users Array of address to bootstrap with reputation
     */
    bootstrapColony(
      _users: string[],
      _amount: BigNumberish[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Mint `_wad` amount of colony tokens. Secured function to authorised members.
     * @param _wad Amount to mint
     */
    mintTokens(
      _wad: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Mint `_wad` amount of colony tokens and send to `_guy`. Secured function to authorised members.
     * @param _guy Recipient of new tokens
     * @param _wad Amount to mint
     */
    mintTokensFor(
      _guy: string,
      _wad: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Lock the colony's token. Can only be called by a network-managed extension.
     */
    lockToken(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Unlock the colony's token for a user. Can only be called by a network-managed extension.
     * @param lockId The specific lock to unlock
     * @param user The user to unlock
     */
    unlockTokenForUser(
      user: string,
      lockId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Register colony's ENS label.
     * @param colonyName The label to register.
     * @param orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      colonyName: string,
      orbitdb: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      orbitdb: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Install an extension to the colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version The new extension version to install
     */
    installExtension(
      extensionId: BytesLike,
      version: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade an extension in a colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param newVersion The version to upgrade to (must be one larger than the current version)
     */
    upgradeExtension(
      extensionId: BytesLike,
      newVersion: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the deprecation of an extension in a colony. Secured function to authorised members.
     * @param deprecated Whether to deprecate the extension or not
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      extensionId: BytesLike,
      deprecated: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This is a permanent action -- re-installing the extension will deploy a new contractIt is recommended to deprecate an extension before uninstalling to allow active objects to be resolved
     * Uninstall an extension from a colony. Secured function to authorised members.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      extensionId: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _parentDomainId Id of the domain under which the new one will be added
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    "addDomain(uint256,uint256,uint256)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _parentDomainId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Adding new domains is currently retricted to one level only, i.e. `_parentDomainId` has to be the root domain id: `1`.We expect this function to only be used by the dapp
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
     * @param _parentDomainId Id of the domain under which the new one will be added
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    "addDomain(uint256,uint256,uint256,string)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _parentDomainId: BigNumberish,
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Add a colony domain, and its respective local skill under skill with id `_parentSkillId`. New funding pot is created and associated with the domain here.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId Id of the domain being edited
     * @param _metadata Metadata relating to the domain. Expected to be the IPFS hash of a JSON blob, but not enforced by the contracts.
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    editDomain(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _metadata: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get a domain by id.
     * @param _id Id of the domain which details to get
     */
    getDomain(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the number of domains in the colony.
     */
    getDomainCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * For more detail about branchMask and siblings, examine the PatriciaTree implementation. While external, likely only to be used by the Colony contracts, as it checks that the user is proving their own reputation in the current colony. The `verifyProof` function can be used to verify any proof, though this function is not currently exposed on the Colony's EtherRouter.
     * Helper function that can be used by a client to verify the correctness of a patricia proof they have been supplied with.
     * @param branchMask The branchmask of the proof
     * @param key The key of the element the proof is for.
     * @param siblings The siblings of the proof
     * @param value The value of the element that the proof is for.
     */
    verifyReputationProof(
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Add a new expenditure in the colony. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _domainId The domain where the expenditure belongs
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    makeExpenditure(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Updates the expenditure owner. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     * @param _newOwner New owner of expenditure
     */
    transferExpenditure(
      _id: BigNumberish,
      _newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This is now deprecated and will be removed in a future version
     * DEPRECATED Updates the expenditure owner. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _newOwner New owner of expenditure
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    transferExpenditureViaArbitration(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Cancels the expenditure and prevents further editing. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     */
    cancelExpenditure(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Finalizes the expenditure and prevents further editing. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     */
    finalizeExpenditure(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the recipient on an expenditure slot. Can only be called by expenditure owner.
     * @param _id Id of the expenditure
     * @param _recipient Address of the recipient
     * @param _slot Slot for the recipient address
     */
    setExpenditureRecipient(
      _id: BigNumberish,
      _slot: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the token payout on an expenditure slot. Can only be called by expenditure owner.
     * @param _amount Payout amount
     * @param _id Id of the expenditure
     * @param _slot Number of the slot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setExpenditurePayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the skill on an expenditure slot. Can only be called by expenditure owner.
     * @param _id Expenditure identifier
     * @param _skillId Id of the new skill to set
     * @param _slot Number of the slot
     */
    setExpenditureSkill(
      _id: BigNumberish,
      _slot: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionNote that when determining payouts the payoutModifier is incremented by WAD and converted into payoutScalar
     * DEPRECATED Set the payout modifier on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _payoutModifier Modifier to their payout (between -1 and 1, denominated in WADs, 0 means no modification)
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _slot Number of the slot
     */
    setExpenditurePayoutModifier(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _slot: BigNumberish,
      _payoutModifier: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This is now deprecated and will be removed in a future version
     * DEPRECATED Set the claim delay on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _claimDelay Time (in seconds) to delay claiming payout after finalization
     * @param _id Expenditure identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _slot Number of the slot
     */
    setExpenditureClaimDelay(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _slot: BigNumberish,
      _claimDelay: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set arbitrary state on an expenditure slot. Can only be called by Arbitration role.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _id Expenditure identifier
     * @param _keys Array of additional keys (for mappings & arrays)
     * @param _mask Array of booleans indicated whether a key is a mapping (F) or an array index (T).
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _storageSlot Number of the top-level storage slot (25, 26, or 27)
     * @param _value Value to set at location
     */
    setExpenditureState(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _storageSlot: BigNumberish,
      _mask: boolean[],
      _keys: BytesLike[],
      _value: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Claim the payout for an expenditure slot. Here the network receives a fee from each payout.
     * @param _id Expenditure identifier
     * @param _slot Number of the slot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimExpenditurePayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the number of expenditures in the colony.
     */
    getExpenditureCount(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an existing expenditure.
     * @param _id Expenditure identifier
     */
    getExpenditure(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an existing expenditure slot.
     * @param _id Expenditure identifier
     * @param _slot Expenditure slot
     */
    getExpenditureSlot(
      _id: BigNumberish,
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an existing expenditure slot's payout for a token.
     * @param _id Expenditure identifier
     * @param _slot Expenditure slot
     * @param _token Token address
     */
    getExpenditureSlotPayout(
      _id: BigNumberish,
      _slot: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Add a new payment in the colony. Secured function to authorised members.
     * @param _amount Payout amount
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`, (only used if `_permissionDomainId` is different to `_domainId`)
     * @param _domainId The domain where the payment belongs
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _recipient Address of the payment recipient
     * @param _skillId The skill associated with the payment
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    addPayment(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _recipient: string,
      _token: string,
      _amount: BigNumberish,
      _domainId: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Finalizes the payment and logs the reputation log updates. Allowed to be called once after payment is fully funded. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     */
    finalizePayment(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the recipient on an existing payment. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _recipient Address of the payment recipient
     */
    setPaymentRecipient(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the skill on an existing payment. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _skillId Id of the new skill to set
     */
    setPaymentSkill(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the payout for a given token on an existing payment. Secured function to authorised members.
     * @param _amount Payout amount
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Payment identifier
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setPaymentPayout(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Returns an exiting payment.
     * @param _id Payment identifier
     */
    getPayment(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Claim the payout in `_token` denomination for payment `_id`. Here the network receives its fee from each payout. Same as for tasks, ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
     * @param _id Payment identifier
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimPayment(
      _id: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the number of payments in the colony.
     */
    getPaymentCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Make a new task in the colony. Secured function to authorised members.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _domainId The domain where the task belongs
     * @param _dueDate The due date of the task, can set to `0` for no-op
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _skillId The skill associated with the task, can set to `0` for no-op
     * @param _specificationHash Database identifier where the task specification is stored
     */
    makeTask(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _specificationHash: BytesLike,
      _domainId: BigNumberish,
      _skillId: BigNumberish,
      _dueDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the number of tasks in the colony.
     */
    getTaskCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Starts from 0 and is incremented on every co-reviewed task change via `executeTaskChange` call.
     * @param _id Id of the task
     */
    getTaskChangeNonce(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * The Colony functions which require approval and the task roles to review these are set in `IColony.initialiseColony` at colony creation. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
     * Executes a task update transaction `_data` which is approved and signed by two of its roles (e.g. manager and worker) using the detached signatures for these users.
     * @param _data The transaction data
     * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
     * @param _sigR r output of the ECDSA signature of the transaction
     * @param _sigS s output of the ECDSA signature of the transaction
     * @param _sigV recovery id
     * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
     */
    executeTaskChange(
      _sigV: BigNumberish[],
      _sigR: BytesLike[],
      _sigS: BytesLike[],
      _mode: BigNumberish[],
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Executes a task role update transaction `_data` which is approved and signed by two of addresses. depending of which function we are calling. Allowed functions are `setTaskManagerRole`, `setTaskEvaluatorRole` and `setTaskWorkerRole`. Upon successful execution the `taskChangeNonces` entry for the task is incremented.
     * @param _data The transaction data
     * @param _mode How the signature was generated - 0 for Geth-style (usual), 1 for Trezor-style (only Trezor does this)
     * @param _sigR r output of the ECDSA signature of the transaction
     * @param _sigS s output of the ECDSA signature of the transaction
     * @param _sigV recovery id
     * @param _value The transaction value, i.e. number of wei to be sent when the transaction is executed Currently we only accept 0 value transactions but this is kept as a future option
     */
    executeTaskRoleAssignment(
      _sigV: BigNumberish[],
      _sigR: BytesLike[],
      _sigS: BytesLike[],
      _mode: BigNumberish[],
      _value: BigNumberish,
      _data: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Submit a hashed secret of the rating for work in task `_id` which was performed by user with task role id `_role`. Allowed within 5 days period starting which whichever is first from either the deliverable being submitted or the dueDate been reached. Allowed only for evaluator to rate worker and for worker to rate manager performance. Once submitted ratings can not be changed or overwritten.
     * @param _id Id of the task
     * @param _ratingSecret `keccak256` hash of a salt and 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50). Can be generated via `IColony.generateSecret` helper function.
     * @param _role Id of the role, as defined in TaskRole enum
     */
    submitTaskWorkRating(
      _id: BigNumberish,
      _role: BigNumberish,
      _ratingSecret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Compares the `keccak256(_salt, _rating)` output with the previously submitted rating secret and if they match, sets the task role properties `rated` to `true` and `rating` to `_rating`.
     * Reveal the secret rating submitted in `IColony.submitTaskWorkRating` for task `_id` and task role with id `_role`. Allowed within 5 days period starting which whichever is first from either both rating secrets being submitted (via `IColony.submitTaskWorkRating`) or the 5 day rating period expiring.
     * @param _id Id of the task
     * @param _rating 0-50 rating score (in increments of 10, .e.g 0, 10, 20, 30, 40 or 50)
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _salt Salt value used to generate the rating secret
     */
    revealTaskWorkRating(
      _id: BigNumberish,
      _role: BigNumberish,
      _rating: BigNumberish,
      _salt: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Helper function used to generage consistently the rating secret using salt value `_salt` and value to hide `_value`
     * @param _salt Salt value
     * @param _value Value to hide
     */
    generateSecret(
      _salt: BytesLike,
      _value: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the `ColonyStorage.RatingSecrets` information for task `_id`.
     * @param _id Id of the task
     */
    getTaskWorkRatingSecretsInfo(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the rating secret submitted for role `_role` in task `_id`
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     */
    getTaskWorkRatingSecret(
      _id: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning manager role. Current manager and user we want to assign role to both need to agree. User we want to set here also needs to be an admin. Note that the domain proof data comes at the end here to not interfere with the assembly argument unpacking.
     * @param _childSkillIndex The index that the `_domainId` is relative to `_permissionDomainId`
     * @param _id Id of the task
     * @param _permissionDomainId The domain ID in which _user has the Administration permission
     * @param _user Address of the user we want to give a manager role to
     */
    setTaskManagerRole(
      _id: BigNumberish,
      _user: string,
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning evaluator role. Can only be set if there is no one currently assigned to be an evaluator. Manager of the task and user we want to assign role to both need to agree. Managers can assign themselves to this role, if there is no one currently assigned to it.
     * @param _id Id of the task
     * @param _user Address of the user we want to give a evaluator role to
     */
    setTaskEvaluatorRole(
      _id: BigNumberish,
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * This function can only be called through `executeTaskRoleAssignment`.
     * Assigning worker role. Can only be set if there is no one currently assigned to be a worker. Manager of the task and user we want to assign role to both need to agree.
     * @param _id Id of the task
     * @param _user Address of the user we want to give a worker role to
     */
    setTaskWorkerRole(
      _id: BigNumberish,
      _user: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Removing evaluator role. Agreed between manager and currently assigned evaluator.
     * @param _id Id of the task
     */
    removeTaskEvaluatorRole(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Removing worker role. Agreed between manager and currently assigned worker.
     * @param _id Id of the task
     */
    removeTaskWorkerRole(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Currently we only allow one skill per task although we have provisioned for an array of skills in `Task` struct. Allowed before a task is finalized.
     * Set the skill for task `_id`.
     * @param _id Id of the task
     * @param _skillId Id of the skill which has to be a global skill
     */
    setTaskSkill(
      _id: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the hash for the task brief, aka task work specification, which identifies the task brief content in ddb. Allowed before a task is finalized.
     * @param _id Id of the task
     * @param _specificationHash Unique hash of the task brief in ddb
     */
    setTaskBrief(
      _id: BigNumberish,
      _specificationHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the due date on task `_id`. Allowed before a task is finalized.
     * @param _dueDate Due date as seconds since unix epoch
     * @param _id Id of the task
     */
    setTaskDueDate(
      _id: BigNumberish,
      _dueDate: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the `task.deliverableHash` and `task.completionTimestamp` properties.
     * Submit the task deliverable, i.e. the output of the work performed for task `_id`. Submission is allowed only to the assigned worker before the task due date. Submissions cannot be overwritten.
     * @param _deliverableHash Unique hash of the task deliverable content in ddb
     * @param _id Id of the task
     */
    submitTaskDeliverable(
      _id: BigNumberish,
      _deliverableHash: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Internally call `submitTaskDeliverable` and `submitTaskWorkRating` in sequence.
     * Submit the task deliverable for Worker and rating for Manager.
     * @param _deliverableHash Unique hash of the task deliverable content in ddb
     * @param _id Id of the task
     * @param _ratingSecret Rating secret for manager
     */
    submitTaskDeliverableAndRating(
      _id: BigNumberish,
      _deliverableHash: BytesLike,
      _ratingSecret: BytesLike,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the `task.finalized` property to true
     * Called after task work rating is complete which closes the task and logs the respective reputation log updates. Allowed to be called once per task. Secured function to authorised members.
     * @param _id Id of the task
     */
    finalizeTask(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the `task.status` property to `1`.
     * Cancel a task at any point before it is finalized. Secured function to authorised members. Any funds assigned to its funding pot can be moved back to the domain via `IColony.moveFundsBetweenPots`.
     * @param _id Id of the task
     */
    cancelTask(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Mark a task as complete after the due date has passed. This allows the task to be rated and finalized (and funds recovered) even in the presence of a worker who has disappeared. Note that if the due date was not set, then this function will throw.
     * @param _id Id of the task
     */
    completeTask(
      _id: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get a task with id `_id`
     * @param _id Id of the task
     */
    getTask(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the `Role` properties back for role `_role` in task `_id`.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     */
    getTaskRole(
      _id: BigNumberish,
      _role: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set the reward inverse to pay out from revenue. e.g. if the fee is 1% (or 0.01), set 100.
     * @param _rewardInverse The inverse of the reward
     */
    setRewardInverse(
      _rewardInverse: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Return 1 / the reward to pay out from revenue. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getRewardInverse(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get payout amount in `_token` denomination for role `_role` in task `_id`.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getTaskPayout(
      _id: BigNumberish,
      _role: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set `_token` payout for manager in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskManagerPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set `_token` payout for evaluator in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskEvaluatorPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set `_token` payout for worker in task `_id` to `_amount`.
     * @param _amount Payout amount
     * @param _id Id of the task
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    setTaskWorkerPayout(
      _id: BigNumberish,
      _token: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Can only call if evaluator and worker are unassigned or manager, otherwise need signature.
     * Set `_token` payout for all roles in task `_id` to the respective amounts.
     * @param _evaluatorAmount Payout amount for evaluator
     * @param _id Id of the task
     * @param _managerAmount Payout amount for manager
     * @param _token Address of the token, `0x0` value indicates Ether
     * @param _workerAmount Payout amount for worker
     */
    setAllTaskPayouts(
      _id: BigNumberish,
      _token: string,
      _managerAmount: BigNumberish,
      _evaluatorAmount: BigNumberish,
      _workerAmount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Claim the payout in `_token` denomination for work completed in task `_id` by contributor with role `_role`. Allowed only after task is finalized. Here the network receives its fee from each payout. Ether fees go straight to the Meta Colony whereas Token fees go to the Network to be auctioned off.
     * @param _id Id of the task
     * @param _role Id of the role, as defined in TaskRole enum
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimTaskPayout(
      _id: BigNumberish,
      _role: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Start next reward payout for `_token`. All funds in the reward pot for `_token` will become unavailable.Add a new payment in the colony. Can only be called by users with root permission. All tokens will be locked, and can be unlocked by calling `waiveRewardPayout` or `claimRewardPayout`.
     * @param _token Address of the token used for reward payout
     * @param branchMask The branchmask of the proof
     * @param key Some Reputation hash tree key
     * @param siblings The siblings of the proof
     * @param value Reputation value
     */
    startNextRewardPayout(
      _token: string,
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Claim the reward payout at `_payoutId`. User needs to provide their reputation and colony-wide reputation which will be proven via Merkle proof inside this function. Can only be called if payout is active, i.e if 60 days have not passed from its creation. Can only be called if next in queue.
     * @param _payoutId Id of the reward payout
     * @param _squareRoots Square roots of values used in equation: `_squareRoots[0]` - square root of user reputation, `_squareRoots[1]` - square root of user tokens (deposited in TokenLocking), `_squareRoots[2]` - square root of total reputation, `_squareRoots[3]` - square root of total tokens, `_squareRoots[4]` - square root of numerator (user reputation * user tokens), `_squareRoots[5]` - square root of denominator (total reputation * total tokens), `_squareRoots[6]` - square root of payout amount.
     * @param branchMask The branchmask of the proof
     * @param key Some Reputation hash tree key
     * @param siblings The siblings of the proof
     * @param value Reputation value
     */
    claimRewardPayout(
      _payoutId: BigNumberish,
      _squareRoots: BigNumberish[],
      key: BytesLike,
      value: BytesLike,
      branchMask: BigNumberish,
      siblings: BytesLike[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get useful information about specific reward payout.
     * @param _payoutId Id of the reward payout
     */
    getRewardPayoutInfo(
      _payoutId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Finalises the reward payout. Allows creation of next reward payouts for token that has been used in `_payoutId`. Can only be called when reward payout cycle is finished i.e when 60 days have passed from its creation.
     * @param _payoutId Id of the reward payout
     */
    finalizeRewardPayout(
      _payoutId: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * For the reward funding pot (e.g. id: 0) this returns (0, 0, 0).
     * Get the non-mapping properties of a pot by id.
     * @param _id Id of the pot which details to get
     */
    getFundingPot(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the number of funding pots in the colony.
     */
    getFundingPotCount(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the `_token` balance of pot with id `_potId`.
     * @param _potId Id of the funding pot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getFundingPotBalance(
      _potId: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the assigned `_token` payouts of pot with id `_potId`.
     * @param _potId Id of the funding pot
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getFundingPotPayout(
      _potId: BigNumberish,
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Move a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
     * @param _amount Amount of funds
     * @param _childSkillIndex The child index in _permissionDomainId where I will be taking this action
     * @param _domainId The domain where I am taking this action, pointed to by _permissionDomainId and _childSkillIndex
     * @param _fromChildSkillIndex In the array of child skills for the skill associated with the domain pointed to by _permissionDomainId + _childSkillIndex,         the index of the skill associated with the domain that contains _fromPot
     * @param _fromPot Funding pot id providing the funds
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _toChildSkillIndex The same, but for the _toPot which the funds are being moved to
     * @param _toPot Funding pot id receiving the funds
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256,address)"(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _domainId: BigNumberish,
      _fromChildSkillIndex: BigNumberish,
      _toChildSkillIndex: BigNumberish,
      _fromPot: BigNumberish,
      _toPot: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * DEPRECATEDMove a given amount: `_amount` of `_token` funds from funding pot with id `_fromPot` to one with id `_toPot`.
     * @param _amount Amount of funds
     * @param _fromChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_fromPotId`
     * @param _fromPot Funding pot id providing the funds
     * @param _permissionDomainId The domainId in which I have the permission to take this action
     * @param _toChildSkillIndex The child index in `_permissionDomainId` where we can find the domain for `_toPotId`
     * @param _toPot Funding pot id receiving the funds
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    "moveFundsBetweenPots(uint256,uint256,uint256,uint256,uint256,uint256,address)"(
      _permissionDomainId: BigNumberish,
      _fromChildSkillIndex: BigNumberish,
      _toChildSkillIndex: BigNumberish,
      _fromPot: BigNumberish,
      _toPot: BigNumberish,
      _amount: BigNumberish,
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Move any funds received by the colony in `_token` denomination to the top-level domain pot, siphoning off a small amount to the reward pot. If called against a colony's own token, no fee is taken.
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    claimColonyFunds(
      _token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the total amount of tokens `_token` minus amount reserved to be paid to the reputation and token holders as rewards.
     * @param _token Address of the token, `0x0` value indicates Ether
     */
    getNonRewardPotsTotal(
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Allow the _approvee to obligate some amount of tokens as a stake.
     * @param _amount Amount of internal token up to which we are willing to be obligated.
     * @param _approvee Address of the account we are willing to let obligate us.
     * @param _domainId Domain in which we are willing to be obligated.
     */
    approveStake(
      _approvee: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Obligate the user some amount of tokens as a stake.
     * @param _amount Amount of internal token we are obligating.
     * @param _domainId Domain in which we are obligating the user.
     * @param _user Address of the account we are obligating.
     */
    obligateStake(
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Deobligate the user some amount of tokens, releasing the stake.
     * @param _amount Amount of internal token we are deobligating.
     * @param _domainId Domain in which we are deobligating the user.
     * @param _user Address of the account we are deobligating.
     */
    deobligateStake(
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfer some amount of obligated tokens. Can be called by the arbitration role.
     * @param _amount Amount of internal token we are transferring.
     * @param _childSkillIndex The child index in `_permissionDomainId` where we can find `_domainId`.
     * @param _domainId Domain in which we are transferring the tokens.
     * @param _obligator Address of the account who set the obligation.
     * @param _permissionDomainId The domainId in which I have the permission to take this action.
     * @param _recipient Recipient of the transferred tokens.
     * @param _user Address of the account we are transferring.
     */
    transferStake(
      _permissionDomainId: BigNumberish,
      _childSkillIndex: BigNumberish,
      _obligator: string,
      _user: string,
      _domainId: BigNumberish,
      _amount: BigNumberish,
      _recipient: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * View an approval to obligate tokens.
     * @param _domainId Domain in which we are willing to be obligated.
     * @param _obligator Address of the account we are willing to let obligate us.
     * @param _user User allowing their tokens to be obligated.
     */
    getApproval(
      _user: string,
      _obligator: string,
      _domainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * View an obligation of tokens.
     * @param _domainId Domain in which we are obligated.
     * @param _obligator Address of the account who obligated us.
     * @param _user User whose tokens are obligated.
     */
    getObligation(
      _user: string,
      _obligator: string,
      _domainId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the domain corresponding to a funding pot
     * @param _fundingPotId Id of the funding pot
     */
    getDomainFromFundingPot(
      _fundingPotId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Burn tokens held by the colony. Can only burn tokens held in the root funding pot.
     * @param amount The amount of tokens to burn
     * @param token The address of the token to burn
     */
    burnTokens(
      token: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * unlock the native colony token, if possible
     */
    unlockToken(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Update the internal bookkeeping around external ERC20 approvals
     * @param spender The account we have approved
     * @param token The address of the token which was approved
     */
    updateApprovalAmount(
      token: string,
      spender: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the current approval amount
     * @param spender The account we have approved
     * @param token The address of the token which was approved
     */
    getTokenApproval(
      token: string,
      spender: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the current total approval amount across all spenders
     * @param token The address of the token which was approved
     */
    getTotalTokenApproval(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
