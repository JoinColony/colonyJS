/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription,
} from ".";

interface IColonyNetworkInterface extends Interface {
  functions: {
    approveExitRecovery: TypedFunctionDescription<{ encode([]: []): string }>;

    checkNotAdditionalProtectedVariable: TypedFunctionDescription<{
      encode([_slot]: [BigNumberish]): string;
    }>;

    enterRecoveryMode: TypedFunctionDescription<{ encode([]: []): string }>;

    executeMetaTransaction: TypedFunctionDescription<{
      encode([userAddress, payload, sigR, sigS, sigV]: [
        string,
        Arrayish,
        Arrayish,
        Arrayish,
        BigNumberish
      ]): string;
    }>;

    exitRecoveryMode: TypedFunctionDescription<{ encode([]: []): string }>;

    getMetatransactionNonce: TypedFunctionDescription<{
      encode([userAddress]: [string]): string;
    }>;

    isInRecoveryMode: TypedFunctionDescription<{ encode([]: []): string }>;

    numRecoveryRoles: TypedFunctionDescription<{ encode([]: []): string }>;

    removeRecoveryRole: TypedFunctionDescription<{
      encode([_user]: [string]): string;
    }>;

    setRecoveryRole: TypedFunctionDescription<{
      encode([_user]: [string]): string;
    }>;

    setStorageSlotRecovery: TypedFunctionDescription<{
      encode([_slot, _value]: [BigNumberish, Arrayish]): string;
    }>;

    supportsInterface: TypedFunctionDescription<{
      encode([interfaceID]: [Arrayish]): string;
    }>;

    setReplacementReputationUpdateLogEntry: TypedFunctionDescription<{
      encode([
        _reputationMiningCycle,
        _id,
        _user,
        _amount,
        _skillId,
        _colony,
        _nUpdates,
        _nPreviousUpdates,
      ]: [
        string,
        BigNumberish,
        string,
        BigNumberish,
        BigNumberish,
        string,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getReplacementReputationUpdateLogEntry: TypedFunctionDescription<{
      encode([_reputationMiningCycle, _id]: [string, BigNumberish]): string;
    }>;

    getReplacementReputationUpdateLogsExist: TypedFunctionDescription<{
      encode([_reputationMiningCycle]: [string]): string;
    }>;

    getMetaColony: TypedFunctionDescription<{ encode([]: []): string }>;

    getColonyCount: TypedFunctionDescription<{ encode([]: []): string }>;

    isColony: TypedFunctionDescription<{ encode([_colony]: [string]): string }>;

    addSkill: TypedFunctionDescription<{
      encode([_parentSkillId]: [BigNumberish]): string;
    }>;

    getSkill: TypedFunctionDescription<{
      encode([_skillId]: [BigNumberish]): string;
    }>;

    deprecateSkill: TypedFunctionDescription<{
      encode([_skillId]: [BigNumberish]): string;
    }>;

    appendReputationUpdateLog: TypedFunctionDescription<{
      encode([_user, _amount, _skillId]: [
        string,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getSkillCount: TypedFunctionDescription<{ encode([]: []): string }>;

    getReputationMiningSkillId: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    setTokenLocking: TypedFunctionDescription<{
      encode([_tokenLockingAddress]: [string]): string;
    }>;

    getTokenLocking: TypedFunctionDescription<{ encode([]: []): string }>;

    createMetaColony: TypedFunctionDescription<{
      encode([_tokenAddress]: [string]): string;
    }>;

    createColony: TypedFunctionDescription<{
      encode([_tokenAddress]: [string]): string;
    }>;

    addColonyVersion: TypedFunctionDescription<{
      encode([_version, _resolver]: [BigNumberish, string]): string;
    }>;

    initialise: TypedFunctionDescription<{
      encode([_resolver, _version]: [string, BigNumberish]): string;
    }>;

    getColony: TypedFunctionDescription<{
      encode([_id]: [BigNumberish]): string;
    }>;

    getCurrentColonyVersion: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getParentSkillId: TypedFunctionDescription<{
      encode([_skillId, _parentSkillIndex]: [
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getChildSkillId: TypedFunctionDescription<{
      encode([_skillId, _childSkillIndex]: [
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getReputationMiningCycle: TypedFunctionDescription<{
      encode([_active]: [boolean]): string;
    }>;

    calculateMinerWeight: TypedFunctionDescription<{
      encode([_timeStaked, _submissonIndex]: [
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getColonyVersionResolver: TypedFunctionDescription<{
      encode([_version]: [BigNumberish]): string;
    }>;

    setReputationRootHash: TypedFunctionDescription<{
      encode([newHash, newNLeaves, stakers]: [
        Arrayish,
        BigNumberish,
        string[]
      ]): string;
    }>;

    startNextCycle: TypedFunctionDescription<{ encode([]: []): string }>;

    initialiseReputationMining: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getReputationRootHash: TypedFunctionDescription<{ encode([]: []): string }>;

    getReputationRootHashNLeaves: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getReputationRootHashNNodes: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    startTokenAuction: TypedFunctionDescription<{
      encode([_token]: [string]): string;
    }>;

    setupRegistrar: TypedFunctionDescription<{
      encode([_ens, _rootNode]: [string, Arrayish]): string;
    }>;

    registerUserLabel: TypedFunctionDescription<{
      encode([username, orbitdb]: [string, string]): string;
    }>;

    registerColonyLabel: TypedFunctionDescription<{
      encode([colonyName, orbitdb]: [string, string]): string;
    }>;

    updateColonyOrbitDB: TypedFunctionDescription<{
      encode([orbitdb]: [string]): string;
    }>;

    updateUserOrbitDB: TypedFunctionDescription<{
      encode([orbitdb]: [string]): string;
    }>;

    getProfileDBAddress: TypedFunctionDescription<{
      encode([node]: [Arrayish]): string;
    }>;

    lookupRegisteredENSDomain: TypedFunctionDescription<{
      encode([addr]: [string]): string;
    }>;

    addr: TypedFunctionDescription<{ encode([node]: [Arrayish]): string }>;

    getENSRegistrar: TypedFunctionDescription<{ encode([]: []): string }>;

    setMiningResolver: TypedFunctionDescription<{
      encode([miningResolverAddress]: [string]): string;
    }>;

    getMiningResolver: TypedFunctionDescription<{ encode([]: []): string }>;

    addExtensionToNetwork: TypedFunctionDescription<{
      encode([extensionId, resolver]: [Arrayish, string]): string;
    }>;

    installExtension: TypedFunctionDescription<{
      encode([extensionId, version]: [Arrayish, BigNumberish]): string;
    }>;

    upgradeExtension: TypedFunctionDescription<{
      encode([extensionId, newVersion]: [Arrayish, BigNumberish]): string;
    }>;

    deprecateExtension: TypedFunctionDescription<{
      encode([extensionId, deprecated]: [Arrayish, boolean]): string;
    }>;

    uninstallExtension: TypedFunctionDescription<{
      encode([extensionId]: [Arrayish]): string;
    }>;

    getExtensionResolver: TypedFunctionDescription<{
      encode([extensionId, version]: [Arrayish, BigNumberish]): string;
    }>;

    getExtensionInstallation: TypedFunctionDescription<{
      encode([extensionId, colony]: [Arrayish, string]): string;
    }>;

    getFeeInverse: TypedFunctionDescription<{ encode([]: []): string }>;

    setFeeInverse: TypedFunctionDescription<{
      encode([_feeInverse]: [BigNumberish]): string;
    }>;

    getPayoutWhitelist: TypedFunctionDescription<{
      encode([_token]: [string]): string;
    }>;

    setPayoutWhitelist: TypedFunctionDescription<{
      encode([_token, _status]: [string, boolean]): string;
    }>;

    punishStakers: TypedFunctionDescription<{
      encode([_stakers, _amount]: [string[], BigNumberish]): string;
    }>;

    stakeForMining: TypedFunctionDescription<{
      encode([_amount]: [BigNumberish]): string;
    }>;

    unstakeForMining: TypedFunctionDescription<{
      encode([_amount]: [BigNumberish]): string;
    }>;

    getMiningStake: TypedFunctionDescription<{
      encode([_user]: [string]): string;
    }>;

    reward: TypedFunctionDescription<{
      encode([_recipient, _amount]: [string, BigNumberish]): string;
    }>;

    burnUnneededRewards: TypedFunctionDescription<{
      encode([_amount]: [BigNumberish]): string;
    }>;

    claimMiningReward: TypedFunctionDescription<{
      encode([_recipient]: [string]): string;
    }>;

    setReputationMiningCycleReward: TypedFunctionDescription<{
      encode([_amount]: [BigNumberish]): string;
    }>;

    getReputationMiningCycleReward: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    deployTokenViaNetwork: TypedFunctionDescription<{
      encode([_name, _symbol, _decimals]: [
        string,
        string,
        BigNumberish
      ]): string;
    }>;

    deployTokenAuthority: TypedFunctionDescription<{
      encode([_token, _colony, allowedToTransfer]: [
        string,
        string,
        string[]
      ]): string;
    }>;
  };

  events: {
    AuctionCreated: TypedEventDescription<{
      encodeTopics([auction, token, quantity]: [null, null, null]): string[];
    }>;

    ColonyAdded: TypedEventDescription<{
      encodeTopics([colonyId, colonyAddress, token]: [
        BigNumberish | null,
        string | null,
        null
      ]): string[];
    }>;

    ColonyLabelRegistered: TypedEventDescription<{
      encodeTopics([colony, label]: [string | null, null]): string[];
    }>;

    ColonyNetworkInitialised: TypedEventDescription<{
      encodeTopics([resolver]: [null]): string[];
    }>;

    ColonyVersionAdded: TypedEventDescription<{
      encodeTopics([version, resolver]: [null, null]): string[];
    }>;

    ExtensionAddedToNetwork: TypedEventDescription<{
      encodeTopics([extensionId, version]: [Arrayish | null, null]): string[];
    }>;

    ExtensionDeprecated: TypedEventDescription<{
      encodeTopics([extensionId, colony, deprecated]: [
        Arrayish | null,
        string | null,
        null
      ]): string[];
    }>;

    ExtensionInstalled: TypedEventDescription<{
      encodeTopics([extensionId, colony, version]: [
        Arrayish | null,
        string | null,
        null
      ]): string[];
    }>;

    ExtensionUninstalled: TypedEventDescription<{
      encodeTopics([extensionId, colony]: [
        Arrayish | null,
        string | null
      ]): string[];
    }>;

    ExtensionUpgraded: TypedEventDescription<{
      encodeTopics([extensionId, colony, version]: [
        Arrayish | null,
        string | null,
        null
      ]): string[];
    }>;

    MetaColonyCreated: TypedEventDescription<{
      encodeTopics([metaColony, token, rootSkillId]: [
        null,
        null,
        null
      ]): string[];
    }>;

    MetaTransactionExecuted: TypedEventDescription<{
      encodeTopics([userAddress, relayerAddress, payload]: [
        null,
        null,
        null
      ]): string[];
    }>;

    MiningCycleResolverSet: TypedEventDescription<{
      encodeTopics([miningCycleResolver]: [null]): string[];
    }>;

    NetworkFeeInverseSet: TypedEventDescription<{
      encodeTopics([feeInverse]: [null]): string[];
    }>;

    RecoveryModeEntered: TypedEventDescription<{
      encodeTopics([user]: [null]): string[];
    }>;

    RecoveryModeExitApproved: TypedEventDescription<{
      encodeTopics([user]: [null]): string[];
    }>;

    RecoveryModeExited: TypedEventDescription<{
      encodeTopics([user]: [null]): string[];
    }>;

    RecoveryRoleSet: TypedEventDescription<{
      encodeTopics([user, setTo]: [string | null, null]): string[];
    }>;

    RecoveryStorageSlotSet: TypedEventDescription<{
      encodeTopics([user, slot, fromValue, toValue]: [
        null,
        null,
        null,
        null
      ]): string[];
    }>;

    RegistrarInitialised: TypedEventDescription<{
      encodeTopics([ens, rootNode]: [null, null]): string[];
    }>;

    ReputationMinerPenalised: TypedEventDescription<{
      encodeTopics([miner, tokensLost]: [null, null]): string[];
    }>;

    ReputationMiningCycleComplete: TypedEventDescription<{
      encodeTopics([hash, nLeaves]: [null, null]): string[];
    }>;

    ReputationMiningInitialised: TypedEventDescription<{
      encodeTopics([inactiveReputationMiningCycle]: [null]): string[];
    }>;

    ReputationMiningRewardSet: TypedEventDescription<{
      encodeTopics([amount]: [null]): string[];
    }>;

    ReputationRootHashSet: TypedEventDescription<{
      encodeTopics([newHash, newNLeaves, stakers, reward]: [
        null,
        null,
        null,
        null
      ]): string[];
    }>;

    SkillAdded: TypedEventDescription<{
      encodeTopics([skillId, parentSkillId]: [null, null]): string[];
    }>;

    TokenAuthorityDeployed: TypedEventDescription<{
      encodeTopics([tokenAuthorityAddress]: [null]): string[];
    }>;

    TokenDeployed: TypedEventDescription<{
      encodeTopics([tokenAddress]: [null]): string[];
    }>;

    TokenLockingAddressSet: TypedEventDescription<{
      encodeTopics([tokenLocking]: [null]): string[];
    }>;

    TokenWhitelisted: TypedEventDescription<{
      encodeTopics([token, status]: [null, null]): string[];
    }>;

    UserLabelRegistered: TypedEventDescription<{
      encodeTopics([user, label]: [string | null, null]): string[];
    }>;
  };
}

export class IColonyNetwork extends Contract {
  connect(signerOrProvider: Signer | Provider | string): IColonyNetwork;
  attach(addressOrName: string): IColonyNetwork;
  deployed(): Promise<IColonyNetwork>;

  on(event: EventFilter | string, listener: Listener): IColonyNetwork;
  once(event: EventFilter | string, listener: Listener): IColonyNetwork;
  addListener(
    eventName: EventFilter | string,
    listener: Listener
  ): IColonyNetwork;
  removeAllListeners(eventName: EventFilter | string): IColonyNetwork;
  removeListener(eventName: any, listener: Listener): IColonyNetwork;

  interface: IColonyNetworkInterface;

  functions: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    "approveExitRecovery()"(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<void>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    "checkNotAdditionalProtectedVariable(uint256)"(
      _slot: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<void>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    "enterRecoveryMode()"(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Executes a metatransaction targeting this contract
     * @param payload The transaction data that will be executed if signature valid
     * @param sigR The 'r' part of the signature
     * @param sigS The 's' part of the signature
     * @param sigV The 'v' part of the signature
     * @param userAddress The address of the user that signed the metatransaction
     */
    executeMetaTransaction(
      userAddress: string,
      payload: Arrayish,
      sigR: Arrayish,
      sigS: Arrayish,
      sigV: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Executes a metatransaction targeting this contract
     * @param payload The transaction data that will be executed if signature valid
     * @param sigR The 'r' part of the signature
     * @param sigS The 's' part of the signature
     * @param sigV The 'v' part of the signature
     * @param userAddress The address of the user that signed the metatransaction
     */
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)"(
      userAddress: string,
      payload: Arrayish,
      sigR: Arrayish,
      sigS: Arrayish,
      sigV: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    "exitRecoveryMode()"(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Gets the next metatransaction nonce for user that should be used targeting this contract
     * @param userAddress The address of the user that will sign the metatransaction
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the next metatransaction nonce for user that should be used targeting this contract
     * @param userAddress The address of the user that will sign the metatransaction
     */
    "getMetatransactionNonce(address)"(
      userAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(overrides?: TransactionOverrides): Promise<boolean>;

    /**
     * Is colony network in recovery mode.
     */
    "isInRecoveryMode()"(overrides?: TransactionOverrides): Promise<boolean>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Return number of recovery roles.
     */
    "numRecoveryRoles()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    "removeRecoveryRole(address)"(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    "setRecoveryRole(address)"(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    "setStorageSlotRecovery(uint256,bytes32)"(
      _slot: BigNumberish,
      _value: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Interface identification is specified in ERC-165.
     * Query if a contract implements an interface
     * @param interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      interfaceID: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<boolean>;

    /**
     * Interface identification is specified in ERC-165.
     * Query if a contract implements an interface
     * @param interfaceID The interface identifier, as specified in ERC-165
     */
    "supportsInterface(bytes4)"(
      interfaceID: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<boolean>;

    /**
     * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
     * Set a replacement log entry if we're in recovery mode.
     * @param _amount The amount of reputation being earned / lost
     * @param _colony The address of the colony being updated
     * @param _id The number of the log entry in the reputation mining cycle in question.
     * @param _nPreviousUpdates The number of updates in the log before this entry
     * @param _nUpdates The number of updates the log entry corresponds to
     * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
     * @param _skillId The id of the origin skill for the reputation update
     * @param _user The address of the user earning / losing the reputation
     */
    setReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
     * Set a replacement log entry if we're in recovery mode.
     * @param _amount The amount of reputation being earned / lost
     * @param _colony The address of the colony being updated
     * @param _id The number of the log entry in the reputation mining cycle in question.
     * @param _nPreviousUpdates The number of updates in the log before this entry
     * @param _nUpdates The number of updates the log entry corresponds to
     * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
     * @param _skillId The id of the origin skill for the reputation update
     * @param _user The address of the user earning / losing the reputation
     */
    "setReplacementReputationUpdateLogEntry(address,uint256,address,int256,uint256,address,uint128,uint128)"(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
     * @param _id The log entry number we wish to see if there is a replacement for
     * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
     */
    getReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        user: string;
        amount: BigNumber;
        skillId: BigNumber;
        colony: string;
        nUpdates: BigNumber;
        nPreviousUpdates: BigNumber;
      }
    >;

    /**
     * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
     * @param _id The log entry number we wish to see if there is a replacement for
     * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
     */
    "getReplacementReputationUpdateLogEntry(address,uint256)"(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<
      [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
        user: string;
        amount: BigNumber;
        skillId: BigNumber;
        colony: string;
        nUpdates: BigNumber;
        nPreviousUpdates: BigNumber;
      }
    >;

    /**
     * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
     * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
     */
    getReplacementReputationUpdateLogsExist(
      _reputationMiningCycle: string,
      overrides?: TransactionOverrides
    ): Promise<boolean>;

    /**
     * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
     * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
     */
    "getReplacementReputationUpdateLogsExist(address)"(
      _reputationMiningCycle: string,
      overrides?: TransactionOverrides
    ): Promise<boolean>;

    /**
     * Get the Meta Colony address.
     */
    getMetaColony(overrides?: TransactionOverrides): Promise<string>;

    /**
     * Get the Meta Colony address.
     */
    "getMetaColony()"(overrides?: TransactionOverrides): Promise<string>;

    /**
     * Get the number of colonies in the network.
     */
    getColonyCount(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the number of colonies in the network.
     */
    "getColonyCount()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Check if specific address is a colony created on colony network.
     * @param _colony Address of the colony
     */
    isColony(
      _colony: string,
      overrides?: TransactionOverrides
    ): Promise<boolean>;

    /**
     * Check if specific address is a colony created on colony network.
     * @param _colony Address of the colony
     */
    "isColony(address)"(
      _colony: string,
      overrides?: TransactionOverrides
    ): Promise<boolean>;

    /**
     * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
     * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
     * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
     */
    addSkill(
      _parentSkillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
     * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
     * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
     */
    "addSkill(uint256)"(
      _parentSkillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get the `nParents` and `nChildren` of skill with id `_skillId`.
     * @param _skillId Id of the skill
     */
    getSkill(
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber[], BigNumber[], boolean, boolean] & {
        nParents: BigNumber;
        nChildren: BigNumber;
        parents: BigNumber[];
        children: BigNumber[];
        globalSkill: boolean;
        deprecated: boolean;
      }
    >;

    /**
     * Get the `nParents` and `nChildren` of skill with id `_skillId`.
     * @param _skillId Id of the skill
     */
    "getSkill(uint256)"(
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<
      [BigNumber, BigNumber, BigNumber[], BigNumber[], boolean, boolean] & {
        nParents: BigNumber;
        nChildren: BigNumber;
        parents: BigNumber[];
        children: BigNumber[];
        globalSkill: boolean;
        deprecated: boolean;
      }
    >;

    /**
     * Mark a global skill as deprecated which stops new tasks and payments from using it.
     * @param _skillId Id of the skill
     */
    deprecateSkill(
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Mark a global skill as deprecated which stops new tasks and payments from using it.
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256)"(
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
     * Adds a reputation update entry to log.
     * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
     * @param _skillId The skill for the reputation update
     * @param _user The address of the user for the reputation update
     */
    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
     * Adds a reputation update entry to log.
     * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
     * @param _skillId The skill for the reputation update
     * @param _user The address of the user for the reputation update
     */
    "appendReputationUpdateLog(address,int256,uint256)"(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get the number of skills in the network including both global and local skills.
     */
    getSkillCount(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the number of skills in the network including both global and local skills.
     */
    "getSkillCount()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
     */
    getReputationMiningSkillId(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
     */
    "getReputationMiningSkillId()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Sets the token locking address. This is only set once, and can't be changed afterwards.
     * @param _tokenLockingAddress Address of the locking contract
     */
    setTokenLocking(
      _tokenLockingAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Sets the token locking address. This is only set once, and can't be changed afterwards.
     * @param _tokenLockingAddress Address of the locking contract
     */
    "setTokenLocking(address)"(
      _tokenLockingAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get token locking contract address.
     */
    getTokenLocking(overrides?: TransactionOverrides): Promise<string>;

    /**
     * Get token locking contract address.
     */
    "getTokenLocking()"(overrides?: TransactionOverrides): Promise<string>;

    /**
     * Create the Meta Colony, same as a normal colony plus the root skill.
     * @param _tokenAddress Address of the CLNY token
     */
    createMetaColony(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Create the Meta Colony, same as a normal colony plus the root skill.
     * @param _tokenAddress Address of the CLNY token
     */
    "createMetaColony(address)"(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, at version 3
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
     */
    createColony(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, at version 3
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
     */
    "createColony(address)"(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _metadata The metadata associated with the new colony
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _orbitdb DEPRECATED Currently a no-op
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _useExtensionManager DEPRECATED Currently a no-op
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string,bool)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _orbitdb: string,
      _useExtensionManager: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
     * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
     * @param _version The new Colony contract version
     */
    addColonyVersion(
      _version: BigNumberish,
      _resolver: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
     * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
     * @param _version The new Colony contract version
     */
    "addColonyVersion(uint256,address)"(
      _version: BigNumberish,
      _resolver: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Only allowed to be run once, by the Network owner before any Colony versions are added.
     * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
     * @param _resolver Address of the resolver for Colony contract
     * @param _version Version of the Colony contract the resolver represents
     */
    initialise(
      _resolver: string,
      _version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Only allowed to be run once, by the Network owner before any Colony versions are added.
     * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
     * @param _resolver Address of the resolver for Colony contract
     * @param _version Version of the Colony contract the resolver represents
     */
    "initialise(address,uint256)"(
      _resolver: string,
      _version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get a colony address by its Id in the network.
     * @param _id Id of the colony to get
     */
    getColony(
      _id: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Get a colony address by its Id in the network.
     * @param _id Id of the colony to get
     */
    "getColony(uint256)"(
      _id: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Returns the latest Colony contract version. This is the version used to create all new colonies.
     */
    getCurrentColonyVersion(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the latest Colony contract version. This is the version used to create all new colonies.
     */
    "getCurrentColonyVersion()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
     * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
     * @param _skillId Id of the skill
     */
    getParentSkillId(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
     * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
     * @param _skillId Id of the skill
     */
    "getParentSkillId(uint256,uint256)"(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
     * @param _childSkillIndex Index of the `skill.children` array to get
     * @param _skillId Id of the skill
     */
    getChildSkillId(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
     * @param _childSkillIndex Index of the `skill.children` array to get
     * @param _skillId Id of the skill
     */
    "getChildSkillId(uint256,uint256)"(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
     * @param _active Whether the user wants the active or inactive reputation mining cycle
     */
    getReputationMiningCycle(
      _active: boolean,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
     * @param _active Whether the user wants the active or inactive reputation mining cycle
     */
    "getReputationMiningCycle(bool)"(
      _active: boolean,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Calculate raw miner weight in WADs.
     * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
     * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
     */
    calculateMinerWeight(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate raw miner weight in WADs.
     * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
     * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
     */
    "calculateMinerWeight(uint256,uint256)"(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `Resolver` address for Colony contract version `_version`.
     * @param _version The Colony contract version
     */
    getColonyVersionResolver(
      _version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Get the `Resolver` address for Colony contract version `_version`.
     * @param _version The Colony contract version
     */
    "getColonyVersionResolver(uint256)"(
      _version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
     * @param newHash The reputation root hash
     * @param newNLeaves The updated leaves count value
     * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    setReputationRootHash(
      newHash: Arrayish,
      newNLeaves: BigNumberish,
      stakers: string[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
     * @param newHash The reputation root hash
     * @param newNLeaves The updated leaves count value
     * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    "setReputationRootHash(bytes32,uint256,address[])"(
      newHash: Arrayish,
      newNLeaves: BigNumberish,
      stakers: string[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This version of setReputationRootHash is deprecated and will be removed in a future release. It transparently calls the new version if it is called (essentially, removing the `reward` parameter.
     * @param newHash The reputation root hash
     * @param newNLeaves The updated leaves count value
     * @param reward Amount of CLNY to be distributed as reward to miners (not used)
     * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    "setReputationRootHash(bytes32,uint256,address[],uint256)"(
      newHash: Arrayish,
      newNLeaves: BigNumberish,
      stakers: string[],
      reward: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
     */
    startNextCycle(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
     */
    "startNextCycle()"(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Creates initial inactive reputation mining cycle.
     */
    initialiseReputationMining(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Creates initial inactive reputation mining cycle.
     */
    "initialiseReputationMining()"(
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get the root hash of the current reputation state tree.
     */
    getReputationRootHash(overrides?: TransactionOverrides): Promise<string>;

    /**
     * Get the root hash of the current reputation state tree.
     */
    "getReputationRootHash()"(
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNLeaves(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
     * Get the number of leaves in the current reputation state tree.
     */
    "getReputationRootHashNLeaves()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNNodes(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
     * Get the number of leaves in the current reputation state tree.
     */
    "getReputationRootHashNNodes()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
     * @param _token Address of the token held by the network to be auctioned
     */
    startTokenAuction(
      _token: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
     * @param _token Address of the token held by the network to be auctioned
     */
    "startTokenAuction(address)"(
      _token: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Setup registrar with ENS and root node.
     * @param _ens Address of ENS registrar
     * @param _rootNode Namehash of the root node for the domain
     */
    setupRegistrar(
      _ens: string,
      _rootNode: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Setup registrar with ENS and root node.
     * @param _ens Address of ENS registrar
     * @param _rootNode Namehash of the root node for the domain
     */
    "setupRegistrar(address,bytes32)"(
      _ens: string,
      _rootNode: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Register a "user.joincolony.eth" label.
     * @param orbitdb The path of the orbitDB database associated with the user profile
     * @param username The label to register
     */
    registerUserLabel(
      username: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Register a "user.joincolony.eth" label.
     * @param orbitdb The path of the orbitDB database associated with the user profile
     * @param username The label to register
     */
    "registerUserLabel(string,string)"(
      username: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
     * @param colonyName The label to register.
     * @param orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      colonyName: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
     * @param colonyName The label to register.
     * @param orbitdb The path of the orbitDB database associated with the colony name
     */
    "registerColonyLabel(string,string)"(
      colonyName: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the colony
     */
    "updateColonyOrbitDB(string)"(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the user
     */
    updateUserOrbitDB(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the user
     */
    "updateUserOrbitDB(string)"(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Retrieve the orbitdb address corresponding to a registered account.
     * @param node The Namehash of the account being queried.
     */
    getProfileDBAddress(
      node: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Retrieve the orbitdb address corresponding to a registered account.
     * @param node The Namehash of the account being queried.
     */
    "getProfileDBAddress(bytes32)"(
      node: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Reverse lookup a username from an address.
     * @param addr The address we wish to find the corresponding ENS domain for (if any)
     */
    lookupRegisteredENSDomain(
      addr: string,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Reverse lookup a username from an address.
     * @param addr The address we wish to find the corresponding ENS domain for (if any)
     */
    "lookupRegisteredENSDomain(address)"(
      addr: string,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Returns the address the supplied node resolves do, if we are the resolver.
     * @param node The namehash of the ENS address being requested
     */
    addr(node: Arrayish, overrides?: TransactionOverrides): Promise<string>;

    /**
     * Returns the address the supplied node resolves do, if we are the resolver.
     * @param node The namehash of the ENS address being requested
     */
    "addr(bytes32)"(
      node: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Returns the address of the ENSRegistrar for the Network.
     */
    getENSRegistrar(overrides?: TransactionOverrides): Promise<string>;

    /**
     * Returns the address of the ENSRegistrar for the Network.
     */
    "getENSRegistrar()"(overrides?: TransactionOverrides): Promise<string>;

    /**
     * Set the resolver to be used by new instances of ReputationMiningCycle.
     * @param miningResolverAddress The address of the Resolver contract with the functions correctly wired.
     */
    setMiningResolver(
      miningResolverAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set the resolver to be used by new instances of ReputationMiningCycle.
     * @param miningResolverAddress The address of the Resolver contract with the functions correctly wired.
     */
    "setMiningResolver(address)"(
      miningResolverAddress: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get the resolver to be used by new instances of ReputationMiningCycle.
     */
    getMiningResolver(overrides?: TransactionOverrides): Promise<string>;

    /**
     * Get the resolver to be used by new instances of ReputationMiningCycle.
     */
    "getMiningResolver()"(overrides?: TransactionOverrides): Promise<string>;

    /**
     * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
     * Add a new extension resolver to the Extensions repository.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param resolver The deployed resolver containing the extension contract logic
     */
    addExtensionToNetwork(
      extensionId: Arrayish,
      resolver: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
     * Add a new extension resolver to the Extensions repository.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param resolver The deployed resolver containing the extension contract logic
     */
    "addExtensionToNetwork(bytes32,address)"(
      extensionId: Arrayish,
      resolver: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Install an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension to install
     */
    installExtension(
      extensionId: Arrayish,
      version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Install an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension to install
     */
    "installExtension(bytes32,uint256)"(
      extensionId: Arrayish,
      version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Upgrade an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param newVersion Version of the extension to upgrade to (must be one greater than current)
     */
    upgradeExtension(
      extensionId: Arrayish,
      newVersion: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Upgrade an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param newVersion Version of the extension to upgrade to (must be one greater than current)
     */
    "upgradeExtension(bytes32,uint256)"(
      extensionId: Arrayish,
      newVersion: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set the deprecation of an extension in a colony. Can only be called by a Colony.
     * @param deprecated Whether to deprecate the extension or not
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      extensionId: Arrayish,
      deprecated: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set the deprecation of an extension in a colony. Can only be called by a Colony.
     * @param deprecated Whether to deprecate the extension or not
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    "deprecateExtension(bytes32,bool)"(
      extensionId: Arrayish,
      deprecated: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Uninstall an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      extensionId: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Uninstall an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    "uninstallExtension(bytes32)"(
      extensionId: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get an extension's resolver.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension
     */
    getExtensionResolver(
      extensionId: Arrayish,
      version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Get an extension's resolver.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension
     */
    "getExtensionResolver(bytes32,uint256)"(
      extensionId: Arrayish,
      version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Get an extension's installation.
     * @param colony Address of the colony the extension is installed in
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    getExtensionInstallation(
      extensionId: Arrayish,
      colony: string,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Get an extension's installation.
     * @param colony Address of the colony the extension is installed in
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    "getExtensionInstallation(bytes32,address)"(
      extensionId: Arrayish,
      colony: string,
      overrides?: TransactionOverrides
    ): Promise<string>;

    /**
     * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getFeeInverse(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
     */
    "getFeeInverse()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
     * @param _feeInverse The inverse of the network fee to set
     */
    setFeeInverse(
      _feeInverse: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
     * @param _feeInverse The inverse of the network fee to set
     */
    "setFeeInverse(uint256)"(
      _feeInverse: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Get a token's status in the payout whitelist
     * @param _token The token being queried
     */
    getPayoutWhitelist(
      _token: string,
      overrides?: TransactionOverrides
    ): Promise<boolean>;

    /**
     * Get a token's status in the payout whitelist
     * @param _token The token being queried
     */
    "getPayoutWhitelist(address)"(
      _token: string,
      overrides?: TransactionOverrides
    ): Promise<boolean>;

    /**
     * Set a token's status in the payout whitelist
     * @param _status The whitelist status
     * @param _token The token being set
     */
    setPayoutWhitelist(
      _token: string,
      _status: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Set a token's status in the payout whitelist
     * @param _status The whitelist status
     * @param _token The token being set
     */
    "setPayoutWhitelist(address,bool)"(
      _token: string,
      _status: boolean,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * While external, it can only be called successfully by the current ReputationMiningCycle.
     * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
     * @param _amount Amount of stake to slash
     * @param _stakers Array of the addresses of stakers to punish
     */
    punishStakers(
      _stakers: string[],
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * While external, it can only be called successfully by the current ReputationMiningCycle.
     * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
     * @param _amount Amount of stake to slash
     * @param _stakers Array of the addresses of stakers to punish
     */
    "punishStakers(address[],uint256)"(
      _stakers: string[],
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Stake CLNY to allow the staker to participate in reputation mining.
     * @param _amount Amount of CLNY to stake for the purposes of mining
     */
    stakeForMining(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Stake CLNY to allow the staker to participate in reputation mining.
     * @param _amount Amount of CLNY to stake for the purposes of mining
     */
    "stakeForMining(uint256)"(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Unstake CLNY currently staked for reputation mining.
     * @param _amount Amount of CLNY staked for mining to unstake
     */
    unstakeForMining(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Unstake CLNY currently staked for reputation mining.
     * @param _amount Amount of CLNY staked for mining to unstake
     */
    "unstakeForMining(uint256)"(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * returns how much CLNY _user has staked for the purposes of reputation mining
     * @param _user The user to query
     */
    getMiningStake(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<
      [BigNumber, BigNumber] & { amount: BigNumber; timestamp: BigNumber }
    >;

    /**
     * returns how much CLNY _user has staked for the purposes of reputation mining
     * @param _user The user to query
     */
    "getMiningStake(address)"(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<
      [BigNumber, BigNumber] & { amount: BigNumber; timestamp: BigNumber }
    >;

    /**
     * Only callable by the active reputation mining cycle
     * Used to track that a user is eligible to claim a reward
     * @param _amount The amount of CLNY to be awarded
     * @param _recipient The address receiving the award
     */
    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to track that a user is eligible to claim a reward
     * @param _amount The amount of CLNY to be awarded
     * @param _recipient The address receiving the award
     */
    "reward(address,uint256)"(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
     * @param _amount The amount of CLNY to burn
     */
    burnUnneededRewards(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
     * @param _amount The amount of CLNY to burn
     */
    "burnUnneededRewards(uint256)"(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Can be called by anyone, not just _recipient
     * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
     * @param _recipient The user whose rewards to claim
     */
    claimMiningReward(
      _recipient: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Can be called by anyone, not just _recipient
     * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
     * @param _recipient The user whose rewards to claim
     */
    "claimMiningReward(address)"(
      _recipient: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the total per-cycle reputation reward, which will be split between all miners.
     */
    setReputationMiningCycleReward(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the total per-cycle reputation reward, which will be split between all miners.
     */
    "setReputationMiningCycleReward(uint256)"(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    getReputationMiningCycleReward(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    "getReputationMiningCycleReward()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token.
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
     * @param _name The name of the token
     * @param _symbol The short 'ticket' symbol for the token
     */
    deployTokenViaNetwork(
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token.
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
     * @param _name The name of the token
     * @param _symbol The short 'ticket' symbol for the token
     */
    "deployTokenViaNetwork(string,string,uint8)"(
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token authority
     * @param _colony The address of the colony in control of the token
     * @param _token The address of the otken
     * @param allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
     */
    deployTokenAuthority(
      _token: string,
      _colony: string,
      allowedToTransfer: string[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token authority
     * @param _colony The address of the colony in control of the token
     * @param _token The address of the otken
     * @param allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
     */
    "deployTokenAuthority(address,address,address[])"(
      _token: string,
      _colony: string,
      allowedToTransfer: string[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;
  };

  /**
   * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
   */
  approveExitRecovery(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
   */
  "approveExitRecovery()"(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
   * Check whether the supplied slot is a protected variable specific to this contract
   * @param _slot The storage slot number to check.
   */
  checkNotAdditionalProtectedVariable(
    _slot: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<void>;

  /**
   * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
   * Check whether the supplied slot is a protected variable specific to this contract
   * @param _slot The storage slot number to check.
   */
  "checkNotAdditionalProtectedVariable(uint256)"(
    _slot: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<void>;

  /**
   * Put colony network mining into recovery mode. Can only be called by user with recovery role.
   */
  enterRecoveryMode(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Put colony network mining into recovery mode. Can only be called by user with recovery role.
   */
  "enterRecoveryMode()"(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Executes a metatransaction targeting this contract
   * @param payload The transaction data that will be executed if signature valid
   * @param sigR The 'r' part of the signature
   * @param sigS The 's' part of the signature
   * @param sigV The 'v' part of the signature
   * @param userAddress The address of the user that signed the metatransaction
   */
  executeMetaTransaction(
    userAddress: string,
    payload: Arrayish,
    sigR: Arrayish,
    sigS: Arrayish,
    sigV: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Executes a metatransaction targeting this contract
   * @param payload The transaction data that will be executed if signature valid
   * @param sigR The 'r' part of the signature
   * @param sigS The 's' part of the signature
   * @param sigV The 'v' part of the signature
   * @param userAddress The address of the user that signed the metatransaction
   */
  "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)"(
    userAddress: string,
    payload: Arrayish,
    sigR: Arrayish,
    sigS: Arrayish,
    sigV: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
   */
  exitRecoveryMode(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
   */
  "exitRecoveryMode()"(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Gets the next metatransaction nonce for user that should be used targeting this contract
   * @param userAddress The address of the user that will sign the metatransaction
   */
  getMetatransactionNonce(
    userAddress: string,
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the next metatransaction nonce for user that should be used targeting this contract
   * @param userAddress The address of the user that will sign the metatransaction
   */
  "getMetatransactionNonce(address)"(
    userAddress: string,
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Is colony network in recovery mode.
   */
  isInRecoveryMode(overrides?: TransactionOverrides): Promise<boolean>;

  /**
   * Is colony network in recovery mode.
   */
  "isInRecoveryMode()"(overrides?: TransactionOverrides): Promise<boolean>;

  /**
   * Return number of recovery roles.
   */
  numRecoveryRoles(overrides?: TransactionOverrides): Promise<BigNumber>;

  /**
   * Return number of recovery roles.
   */
  "numRecoveryRoles()"(overrides?: TransactionOverrides): Promise<BigNumber>;

  /**
   * Remove colony recovery role. Can only be called by root role.
   * @param _user User we want to remove recovery role from
   */
  removeRecoveryRole(
    _user: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Remove colony recovery role. Can only be called by root role.
   * @param _user User we want to remove recovery role from
   */
  "removeRecoveryRole(address)"(
    _user: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set new colony recovery role. Can be called by root.
   * @param _user User we want to give a recovery role to
   */
  setRecoveryRole(
    _user: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set new colony recovery role. Can be called by root.
   * @param _user User we want to give a recovery role to
   */
  "setRecoveryRole(address)"(
    _user: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * certain critical variables are protected from editing in this function
   * Update value of arbitrary storage variable. Can only be called by user with recovery role.
   * @param _slot Uint address of storage slot to be updated
   * @param _value word of data to be set
   */
  setStorageSlotRecovery(
    _slot: BigNumberish,
    _value: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * certain critical variables are protected from editing in this function
   * Update value of arbitrary storage variable. Can only be called by user with recovery role.
   * @param _slot Uint address of storage slot to be updated
   * @param _value word of data to be set
   */
  "setStorageSlotRecovery(uint256,bytes32)"(
    _slot: BigNumberish,
    _value: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Interface identification is specified in ERC-165.
   * Query if a contract implements an interface
   * @param interfaceID The interface identifier, as specified in ERC-165
   */
  supportsInterface(
    interfaceID: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<boolean>;

  /**
   * Interface identification is specified in ERC-165.
   * Query if a contract implements an interface
   * @param interfaceID The interface identifier, as specified in ERC-165
   */
  "supportsInterface(bytes4)"(
    interfaceID: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<boolean>;

  /**
   * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
   * Set a replacement log entry if we're in recovery mode.
   * @param _amount The amount of reputation being earned / lost
   * @param _colony The address of the colony being updated
   * @param _id The number of the log entry in the reputation mining cycle in question.
   * @param _nPreviousUpdates The number of updates in the log before this entry
   * @param _nUpdates The number of updates the log entry corresponds to
   * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
   * @param _skillId The id of the origin skill for the reputation update
   * @param _user The address of the user earning / losing the reputation
   */
  setReplacementReputationUpdateLogEntry(
    _reputationMiningCycle: string,
    _id: BigNumberish,
    _user: string,
    _amount: BigNumberish,
    _skillId: BigNumberish,
    _colony: string,
    _nUpdates: BigNumberish,
    _nPreviousUpdates: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
   * Set a replacement log entry if we're in recovery mode.
   * @param _amount The amount of reputation being earned / lost
   * @param _colony The address of the colony being updated
   * @param _id The number of the log entry in the reputation mining cycle in question.
   * @param _nPreviousUpdates The number of updates in the log before this entry
   * @param _nUpdates The number of updates the log entry corresponds to
   * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
   * @param _skillId The id of the origin skill for the reputation update
   * @param _user The address of the user earning / losing the reputation
   */
  "setReplacementReputationUpdateLogEntry(address,uint256,address,int256,uint256,address,uint128,uint128)"(
    _reputationMiningCycle: string,
    _id: BigNumberish,
    _user: string,
    _amount: BigNumberish,
    _skillId: BigNumberish,
    _colony: string,
    _nUpdates: BigNumberish,
    _nPreviousUpdates: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
   * @param _id The log entry number we wish to see if there is a replacement for
   * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
   */
  getReplacementReputationUpdateLogEntry(
    _reputationMiningCycle: string,
    _id: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<
    [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
      user: string;
      amount: BigNumber;
      skillId: BigNumber;
      colony: string;
      nUpdates: BigNumber;
      nPreviousUpdates: BigNumber;
    }
  >;

  /**
   * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
   * @param _id The log entry number we wish to see if there is a replacement for
   * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
   */
  "getReplacementReputationUpdateLogEntry(address,uint256)"(
    _reputationMiningCycle: string,
    _id: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<
    [string, BigNumber, BigNumber, string, BigNumber, BigNumber] & {
      user: string;
      amount: BigNumber;
      skillId: BigNumber;
      colony: string;
      nUpdates: BigNumber;
      nPreviousUpdates: BigNumber;
    }
  >;

  /**
   * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
   * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
   */
  getReplacementReputationUpdateLogsExist(
    _reputationMiningCycle: string,
    overrides?: TransactionOverrides
  ): Promise<boolean>;

  /**
   * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
   * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
   */
  "getReplacementReputationUpdateLogsExist(address)"(
    _reputationMiningCycle: string,
    overrides?: TransactionOverrides
  ): Promise<boolean>;

  /**
   * Get the Meta Colony address.
   */
  getMetaColony(overrides?: TransactionOverrides): Promise<string>;

  /**
   * Get the Meta Colony address.
   */
  "getMetaColony()"(overrides?: TransactionOverrides): Promise<string>;

  /**
   * Get the number of colonies in the network.
   */
  getColonyCount(overrides?: TransactionOverrides): Promise<BigNumber>;

  /**
   * Get the number of colonies in the network.
   */
  "getColonyCount()"(overrides?: TransactionOverrides): Promise<BigNumber>;

  /**
   * Check if specific address is a colony created on colony network.
   * @param _colony Address of the colony
   */
  isColony(_colony: string, overrides?: TransactionOverrides): Promise<boolean>;

  /**
   * Check if specific address is a colony created on colony network.
   * @param _colony Address of the colony
   */
  "isColony(address)"(
    _colony: string,
    overrides?: TransactionOverrides
  ): Promise<boolean>;

  /**
   * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
   * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
   * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
   */
  addSkill(
    _parentSkillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
   * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
   * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
   */
  "addSkill(uint256)"(
    _parentSkillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get the `nParents` and `nChildren` of skill with id `_skillId`.
   * @param _skillId Id of the skill
   */
  getSkill(
    _skillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber[], BigNumber[], boolean, boolean] & {
      nParents: BigNumber;
      nChildren: BigNumber;
      parents: BigNumber[];
      children: BigNumber[];
      globalSkill: boolean;
      deprecated: boolean;
    }
  >;

  /**
   * Get the `nParents` and `nChildren` of skill with id `_skillId`.
   * @param _skillId Id of the skill
   */
  "getSkill(uint256)"(
    _skillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<
    [BigNumber, BigNumber, BigNumber[], BigNumber[], boolean, boolean] & {
      nParents: BigNumber;
      nChildren: BigNumber;
      parents: BigNumber[];
      children: BigNumber[];
      globalSkill: boolean;
      deprecated: boolean;
    }
  >;

  /**
   * Mark a global skill as deprecated which stops new tasks and payments from using it.
   * @param _skillId Id of the skill
   */
  deprecateSkill(
    _skillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Mark a global skill as deprecated which stops new tasks and payments from using it.
   * @param _skillId Id of the skill
   */
  "deprecateSkill(uint256)"(
    _skillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
   * Adds a reputation update entry to log.
   * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
   * @param _skillId The skill for the reputation update
   * @param _user The address of the user for the reputation update
   */
  appendReputationUpdateLog(
    _user: string,
    _amount: BigNumberish,
    _skillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
   * Adds a reputation update entry to log.
   * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
   * @param _skillId The skill for the reputation update
   * @param _user The address of the user for the reputation update
   */
  "appendReputationUpdateLog(address,int256,uint256)"(
    _user: string,
    _amount: BigNumberish,
    _skillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get the number of skills in the network including both global and local skills.
   */
  getSkillCount(overrides?: TransactionOverrides): Promise<BigNumber>;

  /**
   * Get the number of skills in the network including both global and local skills.
   */
  "getSkillCount()"(overrides?: TransactionOverrides): Promise<BigNumber>;

  /**
   * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
   */
  getReputationMiningSkillId(
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
   */
  "getReputationMiningSkillId()"(
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Sets the token locking address. This is only set once, and can't be changed afterwards.
   * @param _tokenLockingAddress Address of the locking contract
   */
  setTokenLocking(
    _tokenLockingAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Sets the token locking address. This is only set once, and can't be changed afterwards.
   * @param _tokenLockingAddress Address of the locking contract
   */
  "setTokenLocking(address)"(
    _tokenLockingAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get token locking contract address.
   */
  getTokenLocking(overrides?: TransactionOverrides): Promise<string>;

  /**
   * Get token locking contract address.
   */
  "getTokenLocking()"(overrides?: TransactionOverrides): Promise<string>;

  /**
   * Create the Meta Colony, same as a normal colony plus the root skill.
   * @param _tokenAddress Address of the CLNY token
   */
  createMetaColony(
    _tokenAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Create the Meta Colony, same as a normal colony plus the root skill.
   * @param _tokenAddress Address of the CLNY token
   */
  "createMetaColony(address)"(
    _tokenAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
   * Creates a new colony in the network, at version 3
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
   */
  createColony(
    _tokenAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
   * Creates a new colony in the network, at version 3
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
   */
  "createColony(address)"(
    _tokenAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
   * Creates a new colony in the network, with an optional ENS name
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _metadata The metadata associated with the new colony
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  "createColony(address,uint256,string,string)"(
    _tokenAddress: string,
    _version: BigNumberish,
    _colonyName: string,
    _metadata: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * For the colony to mint tokens, token ownership must be transferred to the new colony
   * Creates a new colony in the network, with an optional ENS name
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  "createColony(address,uint256,string)"(
    _tokenAddress: string,
    _version: BigNumberish,
    _colonyName: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
   * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _orbitdb DEPRECATED Currently a no-op
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token
   * @param _useExtensionManager DEPRECATED Currently a no-op
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  "createColony(address,uint256,string,string,bool)"(
    _tokenAddress: string,
    _version: BigNumberish,
    _colonyName: string,
    _orbitdb: string,
    _useExtensionManager: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
   * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
   * @param _version The new Colony contract version
   */
  addColonyVersion(
    _version: BigNumberish,
    _resolver: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
   * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
   * @param _version The new Colony contract version
   */
  "addColonyVersion(uint256,address)"(
    _version: BigNumberish,
    _resolver: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Only allowed to be run once, by the Network owner before any Colony versions are added.
   * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
   * @param _resolver Address of the resolver for Colony contract
   * @param _version Version of the Colony contract the resolver represents
   */
  initialise(
    _resolver: string,
    _version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Only allowed to be run once, by the Network owner before any Colony versions are added.
   * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
   * @param _resolver Address of the resolver for Colony contract
   * @param _version Version of the Colony contract the resolver represents
   */
  "initialise(address,uint256)"(
    _resolver: string,
    _version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get a colony address by its Id in the network.
   * @param _id Id of the colony to get
   */
  getColony(
    _id: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Get a colony address by its Id in the network.
   * @param _id Id of the colony to get
   */
  "getColony(uint256)"(
    _id: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Returns the latest Colony contract version. This is the version used to create all new colonies.
   */
  getCurrentColonyVersion(overrides?: TransactionOverrides): Promise<BigNumber>;

  /**
   * Returns the latest Colony contract version. This is the version used to create all new colonies.
   */
  "getCurrentColonyVersion()"(
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
   * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
   * @param _skillId Id of the skill
   */
  getParentSkillId(
    _skillId: BigNumberish,
    _parentSkillIndex: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
   * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
   * @param _skillId Id of the skill
   */
  "getParentSkillId(uint256,uint256)"(
    _skillId: BigNumberish,
    _parentSkillIndex: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
   * @param _childSkillIndex Index of the `skill.children` array to get
   * @param _skillId Id of the skill
   */
  getChildSkillId(
    _skillId: BigNumberish,
    _childSkillIndex: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
   * @param _childSkillIndex Index of the `skill.children` array to get
   * @param _skillId Id of the skill
   */
  "getChildSkillId(uint256,uint256)"(
    _skillId: BigNumberish,
    _childSkillIndex: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
   * @param _active Whether the user wants the active or inactive reputation mining cycle
   */
  getReputationMiningCycle(
    _active: boolean,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
   * @param _active Whether the user wants the active or inactive reputation mining cycle
   */
  "getReputationMiningCycle(bool)"(
    _active: boolean,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Calculate raw miner weight in WADs.
   * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
   * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
   */
  calculateMinerWeight(
    _timeStaked: BigNumberish,
    _submissonIndex: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Calculate raw miner weight in WADs.
   * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
   * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
   */
  "calculateMinerWeight(uint256,uint256)"(
    _timeStaked: BigNumberish,
    _submissonIndex: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Get the `Resolver` address for Colony contract version `_version`.
   * @param _version The Colony contract version
   */
  getColonyVersionResolver(
    _version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Get the `Resolver` address for Colony contract version `_version`.
   * @param _version The Colony contract version
   */
  "getColonyVersionResolver(uint256)"(
    _version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
   * @param newHash The reputation root hash
   * @param newNLeaves The updated leaves count value
   * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
   */
  setReputationRootHash(
    newHash: Arrayish,
    newNLeaves: BigNumberish,
    stakers: string[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
   * @param newHash The reputation root hash
   * @param newNLeaves The updated leaves count value
   * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
   */
  "setReputationRootHash(bytes32,uint256,address[])"(
    newHash: Arrayish,
    newNLeaves: BigNumberish,
    stakers: string[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This version of setReputationRootHash is deprecated and will be removed in a future release. It transparently calls the new version if it is called (essentially, removing the `reward` parameter.
   * @param newHash The reputation root hash
   * @param newNLeaves The updated leaves count value
   * @param reward Amount of CLNY to be distributed as reward to miners (not used)
   * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
   */
  "setReputationRootHash(bytes32,uint256,address[],uint256)"(
    newHash: Arrayish,
    newNLeaves: BigNumberish,
    stakers: string[],
    reward: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
   */
  startNextCycle(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
   */
  "startNextCycle()"(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Creates initial inactive reputation mining cycle.
   */
  initialiseReputationMining(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Creates initial inactive reputation mining cycle.
   */
  "initialiseReputationMining()"(
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get the root hash of the current reputation state tree.
   */
  getReputationRootHash(overrides?: TransactionOverrides): Promise<string>;

  /**
   * Get the root hash of the current reputation state tree.
   */
  "getReputationRootHash()"(overrides?: TransactionOverrides): Promise<string>;

  /**
   * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
   * Get the number of leaves in the current reputation state tree.
   */
  getReputationRootHashNLeaves(
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
   * Get the number of leaves in the current reputation state tree.
   */
  "getReputationRootHashNLeaves()"(
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
   * Get the number of leaves in the current reputation state tree.
   */
  getReputationRootHashNNodes(
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
   * Get the number of leaves in the current reputation state tree.
   */
  "getReputationRootHashNNodes()"(
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
   * @param _token Address of the token held by the network to be auctioned
   */
  startTokenAuction(
    _token: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
   * @param _token Address of the token held by the network to be auctioned
   */
  "startTokenAuction(address)"(
    _token: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Setup registrar with ENS and root node.
   * @param _ens Address of ENS registrar
   * @param _rootNode Namehash of the root node for the domain
   */
  setupRegistrar(
    _ens: string,
    _rootNode: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Setup registrar with ENS and root node.
   * @param _ens Address of ENS registrar
   * @param _rootNode Namehash of the root node for the domain
   */
  "setupRegistrar(address,bytes32)"(
    _ens: string,
    _rootNode: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Register a "user.joincolony.eth" label.
   * @param orbitdb The path of the orbitDB database associated with the user profile
   * @param username The label to register
   */
  registerUserLabel(
    username: string,
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Register a "user.joincolony.eth" label.
   * @param orbitdb The path of the orbitDB database associated with the user profile
   * @param username The label to register
   */
  "registerUserLabel(string,string)"(
    username: string,
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
   * @param colonyName The label to register.
   * @param orbitdb The path of the orbitDB database associated with the colony name
   */
  registerColonyLabel(
    colonyName: string,
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
   * @param colonyName The label to register.
   * @param orbitdb The path of the orbitDB database associated with the colony name
   */
  "registerColonyLabel(string,string)"(
    colonyName: string,
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
   * @param orbitdb The path of the orbitDB database to be associated with the colony
   */
  updateColonyOrbitDB(
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
   * @param orbitdb The path of the orbitDB database to be associated with the colony
   */
  "updateColonyOrbitDB(string)"(
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
   * @param orbitdb The path of the orbitDB database to be associated with the user
   */
  updateUserOrbitDB(
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
   * @param orbitdb The path of the orbitDB database to be associated with the user
   */
  "updateUserOrbitDB(string)"(
    orbitdb: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Retrieve the orbitdb address corresponding to a registered account.
   * @param node The Namehash of the account being queried.
   */
  getProfileDBAddress(
    node: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Retrieve the orbitdb address corresponding to a registered account.
   * @param node The Namehash of the account being queried.
   */
  "getProfileDBAddress(bytes32)"(
    node: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Reverse lookup a username from an address.
   * @param addr The address we wish to find the corresponding ENS domain for (if any)
   */
  lookupRegisteredENSDomain(
    addr: string,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Reverse lookup a username from an address.
   * @param addr The address we wish to find the corresponding ENS domain for (if any)
   */
  "lookupRegisteredENSDomain(address)"(
    addr: string,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Returns the address the supplied node resolves do, if we are the resolver.
   * @param node The namehash of the ENS address being requested
   */
  addr(node: Arrayish, overrides?: TransactionOverrides): Promise<string>;

  /**
   * Returns the address the supplied node resolves do, if we are the resolver.
   * @param node The namehash of the ENS address being requested
   */
  "addr(bytes32)"(
    node: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Returns the address of the ENSRegistrar for the Network.
   */
  getENSRegistrar(overrides?: TransactionOverrides): Promise<string>;

  /**
   * Returns the address of the ENSRegistrar for the Network.
   */
  "getENSRegistrar()"(overrides?: TransactionOverrides): Promise<string>;

  /**
   * Set the resolver to be used by new instances of ReputationMiningCycle.
   * @param miningResolverAddress The address of the Resolver contract with the functions correctly wired.
   */
  setMiningResolver(
    miningResolverAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set the resolver to be used by new instances of ReputationMiningCycle.
   * @param miningResolverAddress The address of the Resolver contract with the functions correctly wired.
   */
  "setMiningResolver(address)"(
    miningResolverAddress: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get the resolver to be used by new instances of ReputationMiningCycle.
   */
  getMiningResolver(overrides?: TransactionOverrides): Promise<string>;

  /**
   * Get the resolver to be used by new instances of ReputationMiningCycle.
   */
  "getMiningResolver()"(overrides?: TransactionOverrides): Promise<string>;

  /**
   * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
   * Add a new extension resolver to the Extensions repository.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param resolver The deployed resolver containing the extension contract logic
   */
  addExtensionToNetwork(
    extensionId: Arrayish,
    resolver: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
   * Add a new extension resolver to the Extensions repository.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param resolver The deployed resolver containing the extension contract logic
   */
  "addExtensionToNetwork(bytes32,address)"(
    extensionId: Arrayish,
    resolver: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Install an extension in a colony. Can only be called by a Colony.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param version Version of the extension to install
   */
  installExtension(
    extensionId: Arrayish,
    version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Install an extension in a colony. Can only be called by a Colony.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param version Version of the extension to install
   */
  "installExtension(bytes32,uint256)"(
    extensionId: Arrayish,
    version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Upgrade an extension in a colony. Can only be called by a Colony.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param newVersion Version of the extension to upgrade to (must be one greater than current)
   */
  upgradeExtension(
    extensionId: Arrayish,
    newVersion: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Upgrade an extension in a colony. Can only be called by a Colony.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param newVersion Version of the extension to upgrade to (must be one greater than current)
   */
  "upgradeExtension(bytes32,uint256)"(
    extensionId: Arrayish,
    newVersion: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set the deprecation of an extension in a colony. Can only be called by a Colony.
   * @param deprecated Whether to deprecate the extension or not
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  deprecateExtension(
    extensionId: Arrayish,
    deprecated: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set the deprecation of an extension in a colony. Can only be called by a Colony.
   * @param deprecated Whether to deprecate the extension or not
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  "deprecateExtension(bytes32,bool)"(
    extensionId: Arrayish,
    deprecated: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Uninstall an extension in a colony. Can only be called by a Colony.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  uninstallExtension(
    extensionId: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Uninstall an extension in a colony. Can only be called by a Colony.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  "uninstallExtension(bytes32)"(
    extensionId: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get an extension's resolver.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param version Version of the extension
   */
  getExtensionResolver(
    extensionId: Arrayish,
    version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Get an extension's resolver.
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   * @param version Version of the extension
   */
  "getExtensionResolver(bytes32,uint256)"(
    extensionId: Arrayish,
    version: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Get an extension's installation.
   * @param colony Address of the colony the extension is installed in
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  getExtensionInstallation(
    extensionId: Arrayish,
    colony: string,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Get an extension's installation.
   * @param colony Address of the colony the extension is installed in
   * @param extensionId keccak256 hash of the extension name, used as an indentifier
   */
  "getExtensionInstallation(bytes32,address)"(
    extensionId: Arrayish,
    colony: string,
    overrides?: TransactionOverrides
  ): Promise<string>;

  /**
   * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
   */
  getFeeInverse(overrides?: TransactionOverrides): Promise<BigNumber>;

  /**
   * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
   */
  "getFeeInverse()"(overrides?: TransactionOverrides): Promise<BigNumber>;

  /**
   * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
   * @param _feeInverse The inverse of the network fee to set
   */
  setFeeInverse(
    _feeInverse: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
   * @param _feeInverse The inverse of the network fee to set
   */
  "setFeeInverse(uint256)"(
    _feeInverse: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Get a token's status in the payout whitelist
   * @param _token The token being queried
   */
  getPayoutWhitelist(
    _token: string,
    overrides?: TransactionOverrides
  ): Promise<boolean>;

  /**
   * Get a token's status in the payout whitelist
   * @param _token The token being queried
   */
  "getPayoutWhitelist(address)"(
    _token: string,
    overrides?: TransactionOverrides
  ): Promise<boolean>;

  /**
   * Set a token's status in the payout whitelist
   * @param _status The whitelist status
   * @param _token The token being set
   */
  setPayoutWhitelist(
    _token: string,
    _status: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Set a token's status in the payout whitelist
   * @param _status The whitelist status
   * @param _token The token being set
   */
  "setPayoutWhitelist(address,bool)"(
    _token: string,
    _status: boolean,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * While external, it can only be called successfully by the current ReputationMiningCycle.
   * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
   * @param _amount Amount of stake to slash
   * @param _stakers Array of the addresses of stakers to punish
   */
  punishStakers(
    _stakers: string[],
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * While external, it can only be called successfully by the current ReputationMiningCycle.
   * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
   * @param _amount Amount of stake to slash
   * @param _stakers Array of the addresses of stakers to punish
   */
  "punishStakers(address[],uint256)"(
    _stakers: string[],
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Stake CLNY to allow the staker to participate in reputation mining.
   * @param _amount Amount of CLNY to stake for the purposes of mining
   */
  stakeForMining(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Stake CLNY to allow the staker to participate in reputation mining.
   * @param _amount Amount of CLNY to stake for the purposes of mining
   */
  "stakeForMining(uint256)"(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Unstake CLNY currently staked for reputation mining.
   * @param _amount Amount of CLNY staked for mining to unstake
   */
  unstakeForMining(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Unstake CLNY currently staked for reputation mining.
   * @param _amount Amount of CLNY staked for mining to unstake
   */
  "unstakeForMining(uint256)"(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * returns how much CLNY _user has staked for the purposes of reputation mining
   * @param _user The user to query
   */
  getMiningStake(
    _user: string,
    overrides?: TransactionOverrides
  ): Promise<
    [BigNumber, BigNumber] & { amount: BigNumber; timestamp: BigNumber }
  >;

  /**
   * returns how much CLNY _user has staked for the purposes of reputation mining
   * @param _user The user to query
   */
  "getMiningStake(address)"(
    _user: string,
    overrides?: TransactionOverrides
  ): Promise<
    [BigNumber, BigNumber] & { amount: BigNumber; timestamp: BigNumber }
  >;

  /**
   * Only callable by the active reputation mining cycle
   * Used to track that a user is eligible to claim a reward
   * @param _amount The amount of CLNY to be awarded
   * @param _recipient The address receiving the award
   */
  reward(
    _recipient: string,
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Only callable by the active reputation mining cycle
   * Used to track that a user is eligible to claim a reward
   * @param _amount The amount of CLNY to be awarded
   * @param _recipient The address receiving the award
   */
  "reward(address,uint256)"(
    _recipient: string,
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Only callable by the active reputation mining cycle
   * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
   * @param _amount The amount of CLNY to burn
   */
  burnUnneededRewards(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Only callable by the active reputation mining cycle
   * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
   * @param _amount The amount of CLNY to burn
   */
  "burnUnneededRewards(uint256)"(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Can be called by anyone, not just _recipient
   * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
   * @param _recipient The user whose rewards to claim
   */
  claimMiningReward(
    _recipient: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Can be called by anyone, not just _recipient
   * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
   * @param _recipient The user whose rewards to claim
   */
  "claimMiningReward(address)"(
    _recipient: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Can only be called by the MetaColony.
   * Called to set the total per-cycle reputation reward, which will be split between all miners.
   */
  setReputationMiningCycleReward(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Can only be called by the MetaColony.
   * Called to set the total per-cycle reputation reward, which will be split between all miners.
   */
  "setReputationMiningCycleReward(uint256)"(
    _amount: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Called to get the total per-cycle reputation mining reward.
   */
  getReputationMiningCycleReward(
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * Called to get the total per-cycle reputation mining reward.
   */
  "getReputationMiningCycleReward()"(
    overrides?: TransactionOverrides
  ): Promise<BigNumber>;

  /**
   * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
   * Called to deploy a token.
   * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
   * @param _name The name of the token
   * @param _symbol The short 'ticket' symbol for the token
   */
  deployTokenViaNetwork(
    _name: string,
    _symbol: string,
    _decimals: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
   * Called to deploy a token.
   * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
   * @param _name The name of the token
   * @param _symbol The short 'ticket' symbol for the token
   */
  "deployTokenViaNetwork(string,string,uint8)"(
    _name: string,
    _symbol: string,
    _decimals: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
   * Called to deploy a token authority
   * @param _colony The address of the colony in control of the token
   * @param _token The address of the otken
   * @param allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
   */
  deployTokenAuthority(
    _token: string,
    _colony: string,
    allowedToTransfer: string[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
   * Called to deploy a token authority
   * @param _colony The address of the colony in control of the token
   * @param _token The address of the otken
   * @param allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
   */
  "deployTokenAuthority(address,address,address[])"(
    _token: string,
    _colony: string,
    allowedToTransfer: string[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  filters: {
    AuctionCreated(auction: null, token: null, quantity: null): EventFilter;

    ColonyAdded(
      colonyId: BigNumberish | null,
      colonyAddress: string | null,
      token: null
    ): EventFilter;

    ColonyLabelRegistered(colony: string | null, label: null): EventFilter;

    ColonyNetworkInitialised(resolver: null): EventFilter;

    ColonyVersionAdded(version: null, resolver: null): EventFilter;

    ExtensionAddedToNetwork(
      extensionId: Arrayish | null,
      version: null
    ): EventFilter;

    ExtensionDeprecated(
      extensionId: Arrayish | null,
      colony: string | null,
      deprecated: null
    ): EventFilter;

    ExtensionInstalled(
      extensionId: Arrayish | null,
      colony: string | null,
      version: null
    ): EventFilter;

    ExtensionUninstalled(
      extensionId: Arrayish | null,
      colony: string | null
    ): EventFilter;

    ExtensionUpgraded(
      extensionId: Arrayish | null,
      colony: string | null,
      version: null
    ): EventFilter;

    MetaColonyCreated(
      metaColony: null,
      token: null,
      rootSkillId: null
    ): EventFilter;

    MetaTransactionExecuted(
      userAddress: null,
      relayerAddress: null,
      payload: null
    ): EventFilter;

    MiningCycleResolverSet(miningCycleResolver: null): EventFilter;

    NetworkFeeInverseSet(feeInverse: null): EventFilter;

    RecoveryModeEntered(user: null): EventFilter;

    RecoveryModeExitApproved(user: null): EventFilter;

    RecoveryModeExited(user: null): EventFilter;

    RecoveryRoleSet(user: string | null, setTo: null): EventFilter;

    RecoveryStorageSlotSet(
      user: null,
      slot: null,
      fromValue: null,
      toValue: null
    ): EventFilter;

    RegistrarInitialised(ens: null, rootNode: null): EventFilter;

    ReputationMinerPenalised(miner: null, tokensLost: null): EventFilter;

    ReputationMiningCycleComplete(hash: null, nLeaves: null): EventFilter;

    ReputationMiningInitialised(
      inactiveReputationMiningCycle: null
    ): EventFilter;

    ReputationMiningRewardSet(amount: null): EventFilter;

    ReputationRootHashSet(
      newHash: null,
      newNLeaves: null,
      stakers: null,
      reward: null
    ): EventFilter;

    SkillAdded(skillId: null, parentSkillId: null): EventFilter;

    TokenAuthorityDeployed(tokenAuthorityAddress: null): EventFilter;

    TokenDeployed(tokenAddress: null): EventFilter;

    TokenLockingAddressSet(tokenLocking: null): EventFilter;

    TokenWhitelisted(token: null, status: null): EventFilter;

    UserLabelRegistered(user: string | null, label: null): EventFilter;
  };

  estimate: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    "approveExitRecovery()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    "checkNotAdditionalProtectedVariable(uint256)"(
      _slot: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    "enterRecoveryMode()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Executes a metatransaction targeting this contract
     * @param payload The transaction data that will be executed if signature valid
     * @param sigR The 'r' part of the signature
     * @param sigS The 's' part of the signature
     * @param sigV The 'v' part of the signature
     * @param userAddress The address of the user that signed the metatransaction
     */
    executeMetaTransaction(
      userAddress: string,
      payload: Arrayish,
      sigR: Arrayish,
      sigS: Arrayish,
      sigV: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Executes a metatransaction targeting this contract
     * @param payload The transaction data that will be executed if signature valid
     * @param sigR The 'r' part of the signature
     * @param sigS The 's' part of the signature
     * @param sigV The 'v' part of the signature
     * @param userAddress The address of the user that signed the metatransaction
     */
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)"(
      userAddress: string,
      payload: Arrayish,
      sigR: Arrayish,
      sigS: Arrayish,
      sigV: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    "exitRecoveryMode()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Gets the next metatransaction nonce for user that should be used targeting this contract
     * @param userAddress The address of the user that will sign the metatransaction
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the next metatransaction nonce for user that should be used targeting this contract
     * @param userAddress The address of the user that will sign the metatransaction
     */
    "getMetatransactionNonce(address)"(
      userAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Is colony network in recovery mode.
     */
    "isInRecoveryMode()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Return number of recovery roles.
     */
    "numRecoveryRoles()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    "removeRecoveryRole(address)"(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    "setRecoveryRole(address)"(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    "setStorageSlotRecovery(uint256,bytes32)"(
      _slot: BigNumberish,
      _value: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Interface identification is specified in ERC-165.
     * Query if a contract implements an interface
     * @param interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      interfaceID: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Interface identification is specified in ERC-165.
     * Query if a contract implements an interface
     * @param interfaceID The interface identifier, as specified in ERC-165
     */
    "supportsInterface(bytes4)"(
      interfaceID: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
     * Set a replacement log entry if we're in recovery mode.
     * @param _amount The amount of reputation being earned / lost
     * @param _colony The address of the colony being updated
     * @param _id The number of the log entry in the reputation mining cycle in question.
     * @param _nPreviousUpdates The number of updates in the log before this entry
     * @param _nUpdates The number of updates the log entry corresponds to
     * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
     * @param _skillId The id of the origin skill for the reputation update
     * @param _user The address of the user earning / losing the reputation
     */
    setReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
     * Set a replacement log entry if we're in recovery mode.
     * @param _amount The amount of reputation being earned / lost
     * @param _colony The address of the colony being updated
     * @param _id The number of the log entry in the reputation mining cycle in question.
     * @param _nPreviousUpdates The number of updates in the log before this entry
     * @param _nUpdates The number of updates the log entry corresponds to
     * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
     * @param _skillId The id of the origin skill for the reputation update
     * @param _user The address of the user earning / losing the reputation
     */
    "setReplacementReputationUpdateLogEntry(address,uint256,address,int256,uint256,address,uint128,uint128)"(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
     * @param _id The log entry number we wish to see if there is a replacement for
     * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
     */
    getReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
     * @param _id The log entry number we wish to see if there is a replacement for
     * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
     */
    "getReplacementReputationUpdateLogEntry(address,uint256)"(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
     * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
     */
    getReplacementReputationUpdateLogsExist(
      _reputationMiningCycle: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
     * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
     */
    "getReplacementReputationUpdateLogsExist(address)"(
      _reputationMiningCycle: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the Meta Colony address.
     */
    getMetaColony(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the Meta Colony address.
     */
    "getMetaColony()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the number of colonies in the network.
     */
    getColonyCount(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the number of colonies in the network.
     */
    "getColonyCount()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Check if specific address is a colony created on colony network.
     * @param _colony Address of the colony
     */
    isColony(
      _colony: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Check if specific address is a colony created on colony network.
     * @param _colony Address of the colony
     */
    "isColony(address)"(
      _colony: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
     * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
     * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
     */
    addSkill(
      _parentSkillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
     * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
     * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
     */
    "addSkill(uint256)"(
      _parentSkillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `nParents` and `nChildren` of skill with id `_skillId`.
     * @param _skillId Id of the skill
     */
    getSkill(
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `nParents` and `nChildren` of skill with id `_skillId`.
     * @param _skillId Id of the skill
     */
    "getSkill(uint256)"(
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Mark a global skill as deprecated which stops new tasks and payments from using it.
     * @param _skillId Id of the skill
     */
    deprecateSkill(
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Mark a global skill as deprecated which stops new tasks and payments from using it.
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256)"(
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
     * Adds a reputation update entry to log.
     * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
     * @param _skillId The skill for the reputation update
     * @param _user The address of the user for the reputation update
     */
    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
     * Adds a reputation update entry to log.
     * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
     * @param _skillId The skill for the reputation update
     * @param _user The address of the user for the reputation update
     */
    "appendReputationUpdateLog(address,int256,uint256)"(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the number of skills in the network including both global and local skills.
     */
    getSkillCount(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the number of skills in the network including both global and local skills.
     */
    "getSkillCount()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
     */
    getReputationMiningSkillId(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
     */
    "getReputationMiningSkillId()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Sets the token locking address. This is only set once, and can't be changed afterwards.
     * @param _tokenLockingAddress Address of the locking contract
     */
    setTokenLocking(
      _tokenLockingAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Sets the token locking address. This is only set once, and can't be changed afterwards.
     * @param _tokenLockingAddress Address of the locking contract
     */
    "setTokenLocking(address)"(
      _tokenLockingAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get token locking contract address.
     */
    getTokenLocking(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get token locking contract address.
     */
    "getTokenLocking()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Create the Meta Colony, same as a normal colony plus the root skill.
     * @param _tokenAddress Address of the CLNY token
     */
    createMetaColony(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Create the Meta Colony, same as a normal colony plus the root skill.
     * @param _tokenAddress Address of the CLNY token
     */
    "createMetaColony(address)"(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, at version 3
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
     */
    createColony(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, at version 3
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
     */
    "createColony(address)"(
      _tokenAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _metadata The metadata associated with the new colony
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _orbitdb DEPRECATED Currently a no-op
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _useExtensionManager DEPRECATED Currently a no-op
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string,bool)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _orbitdb: string,
      _useExtensionManager: boolean,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
     * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
     * @param _version The new Colony contract version
     */
    addColonyVersion(
      _version: BigNumberish,
      _resolver: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
     * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
     * @param _version The new Colony contract version
     */
    "addColonyVersion(uint256,address)"(
      _version: BigNumberish,
      _resolver: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Only allowed to be run once, by the Network owner before any Colony versions are added.
     * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
     * @param _resolver Address of the resolver for Colony contract
     * @param _version Version of the Colony contract the resolver represents
     */
    initialise(
      _resolver: string,
      _version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Only allowed to be run once, by the Network owner before any Colony versions are added.
     * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
     * @param _resolver Address of the resolver for Colony contract
     * @param _version Version of the Colony contract the resolver represents
     */
    "initialise(address,uint256)"(
      _resolver: string,
      _version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get a colony address by its Id in the network.
     * @param _id Id of the colony to get
     */
    getColony(
      _id: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get a colony address by its Id in the network.
     * @param _id Id of the colony to get
     */
    "getColony(uint256)"(
      _id: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the latest Colony contract version. This is the version used to create all new colonies.
     */
    getCurrentColonyVersion(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the latest Colony contract version. This is the version used to create all new colonies.
     */
    "getCurrentColonyVersion()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
     * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
     * @param _skillId Id of the skill
     */
    getParentSkillId(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
     * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
     * @param _skillId Id of the skill
     */
    "getParentSkillId(uint256,uint256)"(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
     * @param _childSkillIndex Index of the `skill.children` array to get
     * @param _skillId Id of the skill
     */
    getChildSkillId(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
     * @param _childSkillIndex Index of the `skill.children` array to get
     * @param _skillId Id of the skill
     */
    "getChildSkillId(uint256,uint256)"(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
     * @param _active Whether the user wants the active or inactive reputation mining cycle
     */
    getReputationMiningCycle(
      _active: boolean,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
     * @param _active Whether the user wants the active or inactive reputation mining cycle
     */
    "getReputationMiningCycle(bool)"(
      _active: boolean,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate raw miner weight in WADs.
     * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
     * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
     */
    calculateMinerWeight(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate raw miner weight in WADs.
     * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
     * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
     */
    "calculateMinerWeight(uint256,uint256)"(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `Resolver` address for Colony contract version `_version`.
     * @param _version The Colony contract version
     */
    getColonyVersionResolver(
      _version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `Resolver` address for Colony contract version `_version`.
     * @param _version The Colony contract version
     */
    "getColonyVersionResolver(uint256)"(
      _version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
     * @param newHash The reputation root hash
     * @param newNLeaves The updated leaves count value
     * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    setReputationRootHash(
      newHash: Arrayish,
      newNLeaves: BigNumberish,
      stakers: string[],
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
     * @param newHash The reputation root hash
     * @param newNLeaves The updated leaves count value
     * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    "setReputationRootHash(bytes32,uint256,address[])"(
      newHash: Arrayish,
      newNLeaves: BigNumberish,
      stakers: string[],
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * This version of setReputationRootHash is deprecated and will be removed in a future release. It transparently calls the new version if it is called (essentially, removing the `reward` parameter.
     * @param newHash The reputation root hash
     * @param newNLeaves The updated leaves count value
     * @param reward Amount of CLNY to be distributed as reward to miners (not used)
     * @param stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    "setReputationRootHash(bytes32,uint256,address[],uint256)"(
      newHash: Arrayish,
      newNLeaves: BigNumberish,
      stakers: string[],
      reward: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
     */
    startNextCycle(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
     */
    "startNextCycle()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Creates initial inactive reputation mining cycle.
     */
    initialiseReputationMining(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Creates initial inactive reputation mining cycle.
     */
    "initialiseReputationMining()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the root hash of the current reputation state tree.
     */
    getReputationRootHash(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the root hash of the current reputation state tree.
     */
    "getReputationRootHash()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNLeaves(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
     * Get the number of leaves in the current reputation state tree.
     */
    "getReputationRootHashNLeaves()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNNodes(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
     * Get the number of leaves in the current reputation state tree.
     */
    "getReputationRootHashNNodes()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
     * @param _token Address of the token held by the network to be auctioned
     */
    startTokenAuction(
      _token: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
     * @param _token Address of the token held by the network to be auctioned
     */
    "startTokenAuction(address)"(
      _token: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Setup registrar with ENS and root node.
     * @param _ens Address of ENS registrar
     * @param _rootNode Namehash of the root node for the domain
     */
    setupRegistrar(
      _ens: string,
      _rootNode: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Setup registrar with ENS and root node.
     * @param _ens Address of ENS registrar
     * @param _rootNode Namehash of the root node for the domain
     */
    "setupRegistrar(address,bytes32)"(
      _ens: string,
      _rootNode: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Register a "user.joincolony.eth" label.
     * @param orbitdb The path of the orbitDB database associated with the user profile
     * @param username The label to register
     */
    registerUserLabel(
      username: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Register a "user.joincolony.eth" label.
     * @param orbitdb The path of the orbitDB database associated with the user profile
     * @param username The label to register
     */
    "registerUserLabel(string,string)"(
      username: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
     * @param colonyName The label to register.
     * @param orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      colonyName: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
     * @param colonyName The label to register.
     * @param orbitdb The path of the orbitDB database associated with the colony name
     */
    "registerColonyLabel(string,string)"(
      colonyName: string,
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the colony
     */
    "updateColonyOrbitDB(string)"(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the user
     */
    updateUserOrbitDB(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
     * @param orbitdb The path of the orbitDB database to be associated with the user
     */
    "updateUserOrbitDB(string)"(
      orbitdb: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Retrieve the orbitdb address corresponding to a registered account.
     * @param node The Namehash of the account being queried.
     */
    getProfileDBAddress(
      node: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Retrieve the orbitdb address corresponding to a registered account.
     * @param node The Namehash of the account being queried.
     */
    "getProfileDBAddress(bytes32)"(
      node: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Reverse lookup a username from an address.
     * @param addr The address we wish to find the corresponding ENS domain for (if any)
     */
    lookupRegisteredENSDomain(
      addr: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Reverse lookup a username from an address.
     * @param addr The address we wish to find the corresponding ENS domain for (if any)
     */
    "lookupRegisteredENSDomain(address)"(
      addr: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the address the supplied node resolves do, if we are the resolver.
     * @param node The namehash of the ENS address being requested
     */
    addr(node: Arrayish, overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Returns the address the supplied node resolves do, if we are the resolver.
     * @param node The namehash of the ENS address being requested
     */
    "addr(bytes32)"(
      node: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the address of the ENSRegistrar for the Network.
     */
    getENSRegistrar(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the ENSRegistrar for the Network.
     */
    "getENSRegistrar()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Set the resolver to be used by new instances of ReputationMiningCycle.
     * @param miningResolverAddress The address of the Resolver contract with the functions correctly wired.
     */
    setMiningResolver(
      miningResolverAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set the resolver to be used by new instances of ReputationMiningCycle.
     * @param miningResolverAddress The address of the Resolver contract with the functions correctly wired.
     */
    "setMiningResolver(address)"(
      miningResolverAddress: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get the resolver to be used by new instances of ReputationMiningCycle.
     */
    getMiningResolver(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Get the resolver to be used by new instances of ReputationMiningCycle.
     */
    "getMiningResolver()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
     * Add a new extension resolver to the Extensions repository.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param resolver The deployed resolver containing the extension contract logic
     */
    addExtensionToNetwork(
      extensionId: Arrayish,
      resolver: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
     * Add a new extension resolver to the Extensions repository.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param resolver The deployed resolver containing the extension contract logic
     */
    "addExtensionToNetwork(bytes32,address)"(
      extensionId: Arrayish,
      resolver: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Install an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension to install
     */
    installExtension(
      extensionId: Arrayish,
      version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Install an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension to install
     */
    "installExtension(bytes32,uint256)"(
      extensionId: Arrayish,
      version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Upgrade an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param newVersion Version of the extension to upgrade to (must be one greater than current)
     */
    upgradeExtension(
      extensionId: Arrayish,
      newVersion: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Upgrade an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param newVersion Version of the extension to upgrade to (must be one greater than current)
     */
    "upgradeExtension(bytes32,uint256)"(
      extensionId: Arrayish,
      newVersion: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set the deprecation of an extension in a colony. Can only be called by a Colony.
     * @param deprecated Whether to deprecate the extension or not
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      extensionId: Arrayish,
      deprecated: boolean,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set the deprecation of an extension in a colony. Can only be called by a Colony.
     * @param deprecated Whether to deprecate the extension or not
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    "deprecateExtension(bytes32,bool)"(
      extensionId: Arrayish,
      deprecated: boolean,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Uninstall an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      extensionId: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Uninstall an extension in a colony. Can only be called by a Colony.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    "uninstallExtension(bytes32)"(
      extensionId: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get an extension's resolver.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension
     */
    getExtensionResolver(
      extensionId: Arrayish,
      version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get an extension's resolver.
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     * @param version Version of the extension
     */
    "getExtensionResolver(bytes32,uint256)"(
      extensionId: Arrayish,
      version: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get an extension's installation.
     * @param colony Address of the colony the extension is installed in
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    getExtensionInstallation(
      extensionId: Arrayish,
      colony: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get an extension's installation.
     * @param colony Address of the colony the extension is installed in
     * @param extensionId keccak256 hash of the extension name, used as an indentifier
     */
    "getExtensionInstallation(bytes32,address)"(
      extensionId: Arrayish,
      colony: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getFeeInverse(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
     */
    "getFeeInverse()"(overrides?: TransactionOverrides): Promise<BigNumber>;

    /**
     * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
     * @param _feeInverse The inverse of the network fee to set
     */
    setFeeInverse(
      _feeInverse: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
     * @param _feeInverse The inverse of the network fee to set
     */
    "setFeeInverse(uint256)"(
      _feeInverse: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get a token's status in the payout whitelist
     * @param _token The token being queried
     */
    getPayoutWhitelist(
      _token: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Get a token's status in the payout whitelist
     * @param _token The token being queried
     */
    "getPayoutWhitelist(address)"(
      _token: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set a token's status in the payout whitelist
     * @param _status The whitelist status
     * @param _token The token being set
     */
    setPayoutWhitelist(
      _token: string,
      _status: boolean,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Set a token's status in the payout whitelist
     * @param _status The whitelist status
     * @param _token The token being set
     */
    "setPayoutWhitelist(address,bool)"(
      _token: string,
      _status: boolean,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * While external, it can only be called successfully by the current ReputationMiningCycle.
     * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
     * @param _amount Amount of stake to slash
     * @param _stakers Array of the addresses of stakers to punish
     */
    punishStakers(
      _stakers: string[],
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * While external, it can only be called successfully by the current ReputationMiningCycle.
     * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
     * @param _amount Amount of stake to slash
     * @param _stakers Array of the addresses of stakers to punish
     */
    "punishStakers(address[],uint256)"(
      _stakers: string[],
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Stake CLNY to allow the staker to participate in reputation mining.
     * @param _amount Amount of CLNY to stake for the purposes of mining
     */
    stakeForMining(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Stake CLNY to allow the staker to participate in reputation mining.
     * @param _amount Amount of CLNY to stake for the purposes of mining
     */
    "stakeForMining(uint256)"(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Unstake CLNY currently staked for reputation mining.
     * @param _amount Amount of CLNY staked for mining to unstake
     */
    unstakeForMining(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Unstake CLNY currently staked for reputation mining.
     * @param _amount Amount of CLNY staked for mining to unstake
     */
    "unstakeForMining(uint256)"(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * returns how much CLNY _user has staked for the purposes of reputation mining
     * @param _user The user to query
     */
    getMiningStake(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * returns how much CLNY _user has staked for the purposes of reputation mining
     * @param _user The user to query
     */
    "getMiningStake(address)"(
      _user: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to track that a user is eligible to claim a reward
     * @param _amount The amount of CLNY to be awarded
     * @param _recipient The address receiving the award
     */
    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to track that a user is eligible to claim a reward
     * @param _amount The amount of CLNY to be awarded
     * @param _recipient The address receiving the award
     */
    "reward(address,uint256)"(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
     * @param _amount The amount of CLNY to burn
     */
    burnUnneededRewards(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
     * @param _amount The amount of CLNY to burn
     */
    "burnUnneededRewards(uint256)"(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Can be called by anyone, not just _recipient
     * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
     * @param _recipient The user whose rewards to claim
     */
    claimMiningReward(
      _recipient: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Can be called by anyone, not just _recipient
     * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
     * @param _recipient The user whose rewards to claim
     */
    "claimMiningReward(address)"(
      _recipient: string,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the total per-cycle reputation reward, which will be split between all miners.
     */
    setReputationMiningCycleReward(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the total per-cycle reputation reward, which will be split between all miners.
     */
    "setReputationMiningCycleReward(uint256)"(
      _amount: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    getReputationMiningCycleReward(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    "getReputationMiningCycleReward()"(
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token.
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
     * @param _name The name of the token
     * @param _symbol The short 'ticket' symbol for the token
     */
    deployTokenViaNetwork(
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token.
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
     * @param _name The name of the token
     * @param _symbol The short 'ticket' symbol for the token
     */
    "deployTokenViaNetwork(string,string,uint8)"(
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token authority
     * @param _colony The address of the colony in control of the token
     * @param _token The address of the otken
     * @param allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
     */
    deployTokenAuthority(
      _token: string,
      _colony: string,
      allowedToTransfer: string[],
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token authority
     * @param _colony The address of the colony in control of the token
     * @param _token The address of the otken
     * @param allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
     */
    "deployTokenAuthority(address,address,address[])"(
      _token: string,
      _colony: string,
      allowedToTransfer: string[],
      overrides?: TransactionOverrides
    ): Promise<BigNumber>;
  };
}
