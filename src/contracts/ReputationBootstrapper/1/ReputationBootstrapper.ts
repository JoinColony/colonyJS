/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace ReputationBootstrapper {
  export type GrantStruct = {
    amount: PromiseOrValue<BigNumberish>;
    timestamp: PromiseOrValue<BigNumberish>;
  };

  export type GrantStructOutput = [BigNumber, BigNumber] & {
    amount: BigNumber;
    timestamp: BigNumber;
  };
}

export interface ReputationBootstrapperInterface extends utils.Interface {
  functions: {
    "authority()": FunctionFragment;
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getCapabilityRoles(bytes4)": FunctionFragment;
    "getChainId()": FunctionFragment;
    "getColony()": FunctionFragment;
    "getDeprecated()": FunctionFragment;
    "getMetatransactionNonce(address)": FunctionFragment;
    "multicall(bytes[])": FunctionFragment;
    "owner()": FunctionFragment;
    "setAuthority(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "verify(address,uint256,uint256,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "identifier()": FunctionFragment;
    "version()": FunctionFragment;
    "install(address)": FunctionFragment;
    "finishUpgrade()": FunctionFragment;
    "deprecate(bool)": FunctionFragment;
    "uninstall()": FunctionFragment;
    "setGrants(bool[],bytes32[],uint256[])": FunctionFragment;
    "commitSecret(bytes32)": FunctionFragment;
    "claimGrant(bool,uint256)": FunctionFragment;
    "getToken()": FunctionFragment;
    "getDecayPeriod()": FunctionFragment;
    "getDecayNumerator()": FunctionFragment;
    "getDecayDenominator()": FunctionFragment;
    "getTotalPayableGrants()": FunctionFragment;
    "getGrant(bool,bytes32)": FunctionFragment;
    "getCommittedSecret(bytes32)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "authority"
      | "executeMetaTransaction"
      | "getCapabilityRoles"
      | "getChainId"
      | "getColony"
      | "getDeprecated"
      | "getMetatransactionNonce"
      | "multicall"
      | "owner"
      | "setAuthority"
      | "setOwner"
      | "verify"
      | "identifier"
      | "version"
      | "install"
      | "finishUpgrade"
      | "deprecate"
      | "uninstall"
      | "setGrants"
      | "commitSecret"
      | "claimGrant"
      | "getToken"
      | "getDecayPeriod"
      | "getDecayNumerator"
      | "getDecayDenominator"
      | "getTotalPayableGrants"
      | "getGrant"
      | "getCommittedSecret"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getCapabilityRoles",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getChainId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getColony", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getDeprecated",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMetatransactionNonce",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAuthority",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "verify",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "identifier",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "install",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "finishUpgrade",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deprecate",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(functionFragment: "uninstall", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setGrants",
    values: [
      PromiseOrValue<boolean>[],
      PromiseOrValue<BytesLike>[],
      PromiseOrValue<BigNumberish>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "commitSecret",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "claimGrant",
    values: [PromiseOrValue<boolean>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(functionFragment: "getToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getDecayPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDecayNumerator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getDecayDenominator",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTotalPayableGrants",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getGrant",
    values: [PromiseOrValue<boolean>, PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getCommittedSecret",
    values: [PromiseOrValue<BytesLike>]
  ): string;

  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCapabilityRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getChainId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getColony", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDeprecated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetatransactionNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "verify", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "identifier", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "install", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finishUpgrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deprecate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "uninstall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "setGrants", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "commitSecret",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "claimGrant", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDecayPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDecayNumerator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDecayDenominator",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTotalPayableGrants",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getGrant", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCommittedSecret",
    data: BytesLike
  ): Result;

  events: {
    "ExtensionInitialised()": EventFragment;
    "GrantClaimed(address,uint256,bool)": EventFragment;
    "GrantSet(bool,bytes32,uint256)": EventFragment;
    "LogSetAuthority(address)": EventFragment;
    "LogSetOwner(address)": EventFragment;
    "MetaTransactionExecuted(address,address,bytes)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ExtensionInitialised"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "GrantClaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "GrantSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
}

export interface ExtensionInitialisedEventObject {}
export type ExtensionInitialisedEvent = TypedEvent<
  [],
  ExtensionInitialisedEventObject
>;

export type ExtensionInitialisedEventFilter =
  TypedEventFilter<ExtensionInitialisedEvent>;

export interface GrantClaimedEventObject {
  recipient: string;
  reputationAmount: BigNumber;
  paid: boolean;
}
export type GrantClaimedEvent = TypedEvent<
  [string, BigNumber, boolean],
  GrantClaimedEventObject
>;

export type GrantClaimedEventFilter = TypedEventFilter<GrantClaimedEvent>;

export interface GrantSetEventObject {
  paid: boolean;
  hashedSecret: string;
  reputationAmount: BigNumber;
}
export type GrantSetEvent = TypedEvent<
  [boolean, string, BigNumber],
  GrantSetEventObject
>;

export type GrantSetEventFilter = TypedEventFilter<GrantSetEvent>;

export interface LogSetAuthorityEventObject {
  authority: string;
}
export type LogSetAuthorityEvent = TypedEvent<
  [string],
  LogSetAuthorityEventObject
>;

export type LogSetAuthorityEventFilter = TypedEventFilter<LogSetAuthorityEvent>;

export interface LogSetOwnerEventObject {
  owner: string;
}
export type LogSetOwnerEvent = TypedEvent<[string], LogSetOwnerEventObject>;

export type LogSetOwnerEventFilter = TypedEventFilter<LogSetOwnerEvent>;

export interface MetaTransactionExecutedEventObject {
  user: string;
  relayerAddress: string;
  functionSignature: string;
}
export type MetaTransactionExecutedEvent = TypedEvent<
  [string, string, string],
  MetaTransactionExecutedEventObject
>;

export type MetaTransactionExecutedEventFilter =
  TypedEventFilter<MetaTransactionExecutedEvent>;

export interface ReputationBootstrapper extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: ReputationBootstrapperInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    authority(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getCapabilityRoles(
      _sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getChainId(overrides?: CallOverrides): Promise<[BigNumber]>;

    getColony(overrides?: CallOverrides): Promise<[string]>;

    getDeprecated(overrides?: CallOverrides): Promise<[boolean]>;

    getMetatransactionNonce(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<[BigNumber]>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     */
    deprecate(
      _deprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set an arbitrary number of grants
     * @param _amounts An array of reputation amounts claimable by the secret
     * @param _hashedSecrets An array of (hashed) secrets
     * @param _paid An array of booleans indicated pair or unpaid
     */
    setGrants(
      _paid: PromiseOrValue<boolean>[],
      _hashedSecrets: PromiseOrValue<BytesLike>[],
      _amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Commit the secret, beginning the security delay window
     * @param _committedSecret A sha256 hash of (userAddress, secret)
     */
    commitSecret(
      _committedSecret: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Claim the grant, after committing the secret and having the security delay elapse
     * @param _secret The secret corresponding to a reputation grant
     */
    claimGrant(
      _paid: PromiseOrValue<boolean>,
      _secret: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getToken(overrides?: CallOverrides): Promise<[string]>;

    getDecayPeriod(overrides?: CallOverrides): Promise<[BigNumber]>;

    getDecayNumerator(overrides?: CallOverrides): Promise<[BigNumber]>;

    getDecayDenominator(overrides?: CallOverrides): Promise<[BigNumber]>;

    getTotalPayableGrants(overrides?: CallOverrides): Promise<[BigNumber]>;

    getGrant(
      _paid: PromiseOrValue<boolean>,
      _hashedSecret: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<
      [ReputationBootstrapper.GrantStructOutput] & {
        grant: ReputationBootstrapper.GrantStructOutput;
      }
    >;

    getCommittedSecret(
      _addressHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>;
  };

  authority(overrides?: CallOverrides): Promise<string>;

  /**
   * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
   * @param _payload Function call to make via meta transaction
   * @param _sigR R part of the signature
   * @param _sigS S part of the signature
   * @param _sigV V part of the signature
   * @param _user Address of user trying to do meta transaction
   */
  executeMetaTransaction(
    _user: PromiseOrValue<string>,
    _payload: PromiseOrValue<BytesLike>,
    _sigR: PromiseOrValue<BytesLike>,
    _sigS: PromiseOrValue<BytesLike>,
    _sigV: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getCapabilityRoles(
    _sig: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  getChainId(overrides?: CallOverrides): Promise<BigNumber>;

  getColony(overrides?: CallOverrides): Promise<string>;

  getDeprecated(overrides?: CallOverrides): Promise<boolean>;

  getMetatransactionNonce(
    _user: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  multicall(
    data: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  setAuthority(
    authority_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    owner_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  verify(
    _owner: PromiseOrValue<string>,
    _nonce: PromiseOrValue<BigNumberish>,
    _chainId: PromiseOrValue<BigNumberish>,
    _payload: PromiseOrValue<BytesLike>,
    _sigR: PromiseOrValue<BytesLike>,
    _sigS: PromiseOrValue<BytesLike>,
    _sigV: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Returns the identifier of the extension
   */
  identifier(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the version of the extension
   */
  version(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Configures the extension
   * @param _colony The colony in which the extension holds permissions
   */
  install(
    _colony: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called when upgrading the extension
   */
  finishUpgrade(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called when deprecating (or undeprecating) the extension
   */
  deprecate(
    _deprecated: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called when uninstalling the extension
   */
  uninstall(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set an arbitrary number of grants
   * @param _amounts An array of reputation amounts claimable by the secret
   * @param _hashedSecrets An array of (hashed) secrets
   * @param _paid An array of booleans indicated pair or unpaid
   */
  setGrants(
    _paid: PromiseOrValue<boolean>[],
    _hashedSecrets: PromiseOrValue<BytesLike>[],
    _amounts: PromiseOrValue<BigNumberish>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Commit the secret, beginning the security delay window
   * @param _committedSecret A sha256 hash of (userAddress, secret)
   */
  commitSecret(
    _committedSecret: PromiseOrValue<BytesLike>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Claim the grant, after committing the secret and having the security delay elapse
   * @param _secret The secret corresponding to a reputation grant
   */
  claimGrant(
    _paid: PromiseOrValue<boolean>,
    _secret: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getToken(overrides?: CallOverrides): Promise<string>;

  getDecayPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  getDecayNumerator(overrides?: CallOverrides): Promise<BigNumber>;

  getDecayDenominator(overrides?: CallOverrides): Promise<BigNumber>;

  getTotalPayableGrants(overrides?: CallOverrides): Promise<BigNumber>;

  getGrant(
    _paid: PromiseOrValue<boolean>,
    _hashedSecret: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<ReputationBootstrapper.GrantStructOutput>;

  getCommittedSecret(
    _addressHash: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    authority(overrides?: CallOverrides): Promise<string>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getCapabilityRoles(
      _sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<string>;

    getDeprecated(overrides?: CallOverrides): Promise<boolean>;

    getMetatransactionNonce(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    owner(overrides?: CallOverrides): Promise<string>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(overrides?: CallOverrides): Promise<void>;

    /**
     * Called when deprecating (or undeprecating) the extension
     */
    deprecate(
      _deprecated: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(overrides?: CallOverrides): Promise<void>;

    /**
     * Set an arbitrary number of grants
     * @param _amounts An array of reputation amounts claimable by the secret
     * @param _hashedSecrets An array of (hashed) secrets
     * @param _paid An array of booleans indicated pair or unpaid
     */
    setGrants(
      _paid: PromiseOrValue<boolean>[],
      _hashedSecrets: PromiseOrValue<BytesLike>[],
      _amounts: PromiseOrValue<BigNumberish>[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Commit the secret, beginning the security delay window
     * @param _committedSecret A sha256 hash of (userAddress, secret)
     */
    commitSecret(
      _committedSecret: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Claim the grant, after committing the secret and having the security delay elapse
     * @param _secret The secret corresponding to a reputation grant
     */
    claimGrant(
      _paid: PromiseOrValue<boolean>,
      _secret: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    getToken(overrides?: CallOverrides): Promise<string>;

    getDecayPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    getDecayNumerator(overrides?: CallOverrides): Promise<BigNumber>;

    getDecayDenominator(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalPayableGrants(overrides?: CallOverrides): Promise<BigNumber>;

    getGrant(
      _paid: PromiseOrValue<boolean>,
      _hashedSecret: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<ReputationBootstrapper.GrantStructOutput>;

    getCommittedSecret(
      _addressHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "ExtensionInitialised()"(): ExtensionInitialisedEventFilter;
    ExtensionInitialised(): ExtensionInitialisedEventFilter;

    "GrantClaimed(address,uint256,bool)"(
      recipient?: null,
      reputationAmount?: null,
      paid?: null
    ): GrantClaimedEventFilter;
    GrantClaimed(
      recipient?: null,
      reputationAmount?: null,
      paid?: null
    ): GrantClaimedEventFilter;

    "GrantSet(bool,bytes32,uint256)"(
      paid?: null,
      hashedSecret?: null,
      reputationAmount?: null
    ): GrantSetEventFilter;
    GrantSet(
      paid?: null,
      hashedSecret?: null,
      reputationAmount?: null
    ): GrantSetEventFilter;

    "LogSetAuthority(address)"(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;
    LogSetAuthority(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;

    "LogSetOwner(address)"(
      owner?: PromiseOrValue<string> | null
    ): LogSetOwnerEventFilter;
    LogSetOwner(owner?: PromiseOrValue<string> | null): LogSetOwnerEventFilter;

    "MetaTransactionExecuted(address,address,bytes)"(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;
    MetaTransactionExecuted(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;
  };

  estimateGas: {
    authority(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getCapabilityRoles(
      _sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<BigNumber>;

    getDeprecated(overrides?: CallOverrides): Promise<BigNumber>;

    getMetatransactionNonce(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Called when deprecating (or undeprecating) the extension
     */
    deprecate(
      _deprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Set an arbitrary number of grants
     * @param _amounts An array of reputation amounts claimable by the secret
     * @param _hashedSecrets An array of (hashed) secrets
     * @param _paid An array of booleans indicated pair or unpaid
     */
    setGrants(
      _paid: PromiseOrValue<boolean>[],
      _hashedSecrets: PromiseOrValue<BytesLike>[],
      _amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Commit the secret, beginning the security delay window
     * @param _committedSecret A sha256 hash of (userAddress, secret)
     */
    commitSecret(
      _committedSecret: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Claim the grant, after committing the secret and having the security delay elapse
     * @param _secret The secret corresponding to a reputation grant
     */
    claimGrant(
      _paid: PromiseOrValue<boolean>,
      _secret: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getToken(overrides?: CallOverrides): Promise<BigNumber>;

    getDecayPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    getDecayNumerator(overrides?: CallOverrides): Promise<BigNumber>;

    getDecayDenominator(overrides?: CallOverrides): Promise<BigNumber>;

    getTotalPayableGrants(overrides?: CallOverrides): Promise<BigNumber>;

    getGrant(
      _paid: PromiseOrValue<boolean>,
      _hashedSecret: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getCommittedSecret(
      _addressHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getCapabilityRoles(
      _sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getColony(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDeprecated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getMetatransactionNonce(
      _user: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     */
    deprecate(
      _deprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set an arbitrary number of grants
     * @param _amounts An array of reputation amounts claimable by the secret
     * @param _hashedSecrets An array of (hashed) secrets
     * @param _paid An array of booleans indicated pair or unpaid
     */
    setGrants(
      _paid: PromiseOrValue<boolean>[],
      _hashedSecrets: PromiseOrValue<BytesLike>[],
      _amounts: PromiseOrValue<BigNumberish>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Commit the secret, beginning the security delay window
     * @param _committedSecret A sha256 hash of (userAddress, secret)
     */
    commitSecret(
      _committedSecret: PromiseOrValue<BytesLike>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Claim the grant, after committing the secret and having the security delay elapse
     * @param _secret The secret corresponding to a reputation grant
     */
    claimGrant(
      _paid: PromiseOrValue<boolean>,
      _secret: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDecayPeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDecayNumerator(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDecayDenominator(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTotalPayableGrants(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getGrant(
      _paid: PromiseOrValue<boolean>,
      _hashedSecret: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getCommittedSecret(
      _addressHash: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
