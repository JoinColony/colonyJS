/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface WhitelistInterface extends utils.Interface {
  functions: {
    "authority()": FunctionFragment;
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getCapabilityRoles(bytes4)": FunctionFragment;
    "getChainId()": FunctionFragment;
    "getColony()": FunctionFragment;
    "getDeprecated()": FunctionFragment;
    "multicall(bytes[])": FunctionFragment;
    "owner()": FunctionFragment;
    "setAuthority(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "verify(address,uint256,uint256,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getMetatransactionNonce(address)": FunctionFragment;
    "identifier()": FunctionFragment;
    "version()": FunctionFragment;
    "install(address)": FunctionFragment;
    "finishUpgrade()": FunctionFragment;
    "deprecate(bool)": FunctionFragment;
    "uninstall()": FunctionFragment;
    "initialise(bool,string)": FunctionFragment;
    "approveUsers(address[],bool)": FunctionFragment;
    "signAgreement(string)": FunctionFragment;
    "isApproved(address)": FunctionFragment;
    "getUseApprovals()": FunctionFragment;
    "getAgreementHash()": FunctionFragment;
    "getApproval(address)": FunctionFragment;
    "getSignature(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "authority"
      | "executeMetaTransaction"
      | "getCapabilityRoles"
      | "getChainId"
      | "getColony"
      | "getDeprecated"
      | "multicall"
      | "owner"
      | "setAuthority"
      | "setOwner"
      | "verify"
      | "getMetatransactionNonce"
      | "identifier"
      | "version"
      | "install"
      | "finishUpgrade"
      | "deprecate"
      | "uninstall"
      | "initialise"
      | "approveUsers"
      | "signAgreement"
      | "isApproved"
      | "getUseApprovals"
      | "getAgreementHash"
      | "getApproval"
      | "getSignature"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [string, BytesLike, BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCapabilityRoles",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getChainId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getColony", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getDeprecated",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAuthority",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "setOwner", values: [string]): string;
  encodeFunctionData(
    functionFragment: "verify",
    values: [
      string,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike,
      BytesLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetatransactionNonce",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "identifier",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(functionFragment: "install", values: [string]): string;
  encodeFunctionData(
    functionFragment: "finishUpgrade",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "deprecate", values: [boolean]): string;
  encodeFunctionData(functionFragment: "uninstall", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "initialise",
    values: [boolean, string]
  ): string;
  encodeFunctionData(
    functionFragment: "approveUsers",
    values: [string[], boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "signAgreement",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "isApproved", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getUseApprovals",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getAgreementHash",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getApproval", values: [string]): string;
  encodeFunctionData(
    functionFragment: "getSignature",
    values: [string]
  ): string;

  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCapabilityRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getChainId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getColony", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDeprecated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "verify", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMetatransactionNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "identifier", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "install", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finishUpgrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deprecate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "uninstall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialise", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "approveUsers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "signAgreement",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isApproved", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getUseApprovals",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getAgreementHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getApproval",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSignature",
    data: BytesLike
  ): Result;

  events: {
    "AgreementSigned(address)": EventFragment;
    "ExtensionInitialised()": EventFragment;
    "LogSetAuthority(address)": EventFragment;
    "LogSetOwner(address)": EventFragment;
    "MetaTransactionExecuted(address,address,bytes)": EventFragment;
    "UserApproved(address,bool)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AgreementSigned"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExtensionInitialised"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserApproved"): EventFragment;
}

export interface AgreementSignedEventObject {
  _user: string;
}
export type AgreementSignedEvent = TypedEvent<
  [string],
  AgreementSignedEventObject
>;

export type AgreementSignedEventFilter = TypedEventFilter<AgreementSignedEvent>;

export interface ExtensionInitialisedEventObject {}
export type ExtensionInitialisedEvent = TypedEvent<
  [],
  ExtensionInitialisedEventObject
>;

export type ExtensionInitialisedEventFilter =
  TypedEventFilter<ExtensionInitialisedEvent>;

export interface LogSetAuthorityEventObject {
  authority: string;
}
export type LogSetAuthorityEvent = TypedEvent<
  [string],
  LogSetAuthorityEventObject
>;

export type LogSetAuthorityEventFilter = TypedEventFilter<LogSetAuthorityEvent>;

export interface LogSetOwnerEventObject {
  owner: string;
}
export type LogSetOwnerEvent = TypedEvent<[string], LogSetOwnerEventObject>;

export type LogSetOwnerEventFilter = TypedEventFilter<LogSetOwnerEvent>;

export interface MetaTransactionExecutedEventObject {
  user: string;
  relayerAddress: string;
  functionSignature: string;
}
export type MetaTransactionExecutedEvent = TypedEvent<
  [string, string, string],
  MetaTransactionExecutedEventObject
>;

export type MetaTransactionExecutedEventFilter =
  TypedEventFilter<MetaTransactionExecutedEvent>;

export interface UserApprovedEventObject {
  _user: string;
  _status: boolean;
}
export type UserApprovedEvent = TypedEvent<
  [string, boolean],
  UserApprovedEventObject
>;

export type UserApprovedEventFilter = TypedEventFilter<UserApprovedEvent>;

export interface Whitelist extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: WhitelistInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    authority(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getChainId(overrides?: CallOverrides): Promise<[BigNumber]>;

    getColony(overrides?: CallOverrides): Promise<[string]>;

    getDeprecated(overrides?: CallOverrides): Promise<[boolean]>;

    multicall(
      data: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param userAddress The user's address
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    /**
     * Returns the identifier of the extension
     */
    identifier(
      overrides?: CallOverrides
    ): Promise<[string] & { _identifier: string }>;

    /**
     * Returns the version of the extension
     */
    version(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _version: BigNumber }>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialise the extension
     * @param _agreementHash An agreement hash (such as an IPFS URI)
     * @param _useApprovals Whether or not to require administrative approval
     */
    initialise(
      _useApprovals: boolean,
      _agreementHash: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Sets user statuses in the whitelist
     * @param _status The whitelist status to set
     * @param _users An array of user addresses
     */
    approveUsers(
      _users: string[],
      _status: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * The user's signature on the agreement
     * @param _agreementHash The agreement hash being signed
     */
    signAgreement(
      _agreementHash: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get the user's overall whitelist status
     * @param _user The address of the user
     */
    isApproved(
      _user: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { _approved: boolean }>;

    /**
     * Get the useApprovals boolean
     */
    getUseApprovals(
      overrides?: CallOverrides
    ): Promise<[boolean] & { _useApprovals: boolean }>;

    /**
     * Get the agreementHash
     */
    getAgreementHash(
      overrides?: CallOverrides
    ): Promise<[string] & { _hash: string }>;

    /**
     * Get the user's approval status
     * @param _user The address of the user
     */
    getApproval(
      _user: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { _status: boolean }>;

    /**
     * Get the user's signature status
     * @param _user The address of the user
     */
    getSignature(
      _user: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { _status: boolean }>;
  };

  authority(overrides?: CallOverrides): Promise<string>;

  /**
   * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
   * @param _payload Function call to make via meta transaction
   * @param _sigR R part of the signature
   * @param _sigS S part of the signature
   * @param _sigV V part of the signature
   * @param _user Address of user trying to do meta transaction
   */
  executeMetaTransaction(
    _user: string,
    _payload: BytesLike,
    _sigR: BytesLike,
    _sigS: BytesLike,
    _sigV: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  getCapabilityRoles(
    _sig: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  getChainId(overrides?: CallOverrides): Promise<BigNumber>;

  getColony(overrides?: CallOverrides): Promise<string>;

  getDeprecated(overrides?: CallOverrides): Promise<boolean>;

  multicall(
    data: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  setAuthority(
    authority_: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  setOwner(
    owner_: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  verify(
    _owner: string,
    _nonce: BigNumberish,
    _chainId: BigNumberish,
    _payload: BytesLike,
    _sigR: BytesLike,
    _sigS: BytesLike,
    _sigV: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Gets the next nonce for a meta-transaction
   * @param userAddress The user's address
   */
  getMetatransactionNonce(
    userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the identifier of the extension
   */
  identifier(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the version of the extension
   */
  version(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Configures the extension
   * @param _colony The colony in which the extension holds permissions
   */
  install(
    _colony: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called when upgrading the extension
   */
  finishUpgrade(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called when deprecating (or undeprecating) the extension
   * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
   */
  deprecate(
    _deprecated: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called when uninstalling the extension
   */
  uninstall(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialise the extension
   * @param _agreementHash An agreement hash (such as an IPFS URI)
   * @param _useApprovals Whether or not to require administrative approval
   */
  initialise(
    _useApprovals: boolean,
    _agreementHash: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Sets user statuses in the whitelist
   * @param _status The whitelist status to set
   * @param _users An array of user addresses
   */
  approveUsers(
    _users: string[],
    _status: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * The user's signature on the agreement
   * @param _agreementHash The agreement hash being signed
   */
  signAgreement(
    _agreementHash: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get the user's overall whitelist status
   * @param _user The address of the user
   */
  isApproved(_user: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Get the useApprovals boolean
   */
  getUseApprovals(overrides?: CallOverrides): Promise<boolean>;

  /**
   * Get the agreementHash
   */
  getAgreementHash(overrides?: CallOverrides): Promise<string>;

  /**
   * Get the user's approval status
   * @param _user The address of the user
   */
  getApproval(_user: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Get the user's signature status
   * @param _user The address of the user
   */
  getSignature(_user: string, overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    authority(overrides?: CallOverrides): Promise<string>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<string>;

    getDeprecated(overrides?: CallOverrides): Promise<boolean>;

    multicall(data: BytesLike[], overrides?: CallOverrides): Promise<string[]>;

    owner(overrides?: CallOverrides): Promise<string>;

    setAuthority(authority_: string, overrides?: CallOverrides): Promise<void>;

    setOwner(owner_: string, overrides?: CallOverrides): Promise<void>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param userAddress The user's address
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(_colony: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(overrides?: CallOverrides): Promise<void>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(_deprecated: boolean, overrides?: CallOverrides): Promise<void>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(overrides?: CallOverrides): Promise<void>;

    /**
     * Initialise the extension
     * @param _agreementHash An agreement hash (such as an IPFS URI)
     * @param _useApprovals Whether or not to require administrative approval
     */
    initialise(
      _useApprovals: boolean,
      _agreementHash: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Sets user statuses in the whitelist
     * @param _status The whitelist status to set
     * @param _users An array of user addresses
     */
    approveUsers(
      _users: string[],
      _status: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * The user's signature on the agreement
     * @param _agreementHash The agreement hash being signed
     */
    signAgreement(
      _agreementHash: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the user's overall whitelist status
     * @param _user The address of the user
     */
    isApproved(_user: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Get the useApprovals boolean
     */
    getUseApprovals(overrides?: CallOverrides): Promise<boolean>;

    /**
     * Get the agreementHash
     */
    getAgreementHash(overrides?: CallOverrides): Promise<string>;

    /**
     * Get the user's approval status
     * @param _user The address of the user
     */
    getApproval(_user: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Get the user's signature status
     * @param _user The address of the user
     */
    getSignature(_user: string, overrides?: CallOverrides): Promise<boolean>;
  };

  filters: {
    "AgreementSigned(address)"(
      _user?: string | null
    ): AgreementSignedEventFilter;
    AgreementSigned(_user?: string | null): AgreementSignedEventFilter;

    "ExtensionInitialised()"(): ExtensionInitialisedEventFilter;
    ExtensionInitialised(): ExtensionInitialisedEventFilter;

    "LogSetAuthority(address)"(
      authority?: string | null
    ): LogSetAuthorityEventFilter;
    LogSetAuthority(authority?: string | null): LogSetAuthorityEventFilter;

    "LogSetOwner(address)"(owner?: string | null): LogSetOwnerEventFilter;
    LogSetOwner(owner?: string | null): LogSetOwnerEventFilter;

    "MetaTransactionExecuted(address,address,bytes)"(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;
    MetaTransactionExecuted(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;

    "UserApproved(address,bool)"(
      _user?: string | null,
      _status?: null
    ): UserApprovedEventFilter;
    UserApproved(
      _user?: string | null,
      _status?: null
    ): UserApprovedEventFilter;
  };

  estimateGas: {
    authority(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<BigNumber>;

    getDeprecated(overrides?: CallOverrides): Promise<BigNumber>;

    multicall(
      data: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param userAddress The user's address
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    /**
     * Initialise the extension
     * @param _agreementHash An agreement hash (such as an IPFS URI)
     * @param _useApprovals Whether or not to require administrative approval
     */
    initialise(
      _useApprovals: boolean,
      _agreementHash: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Sets user statuses in the whitelist
     * @param _status The whitelist status to set
     * @param _users An array of user addresses
     */
    approveUsers(
      _users: string[],
      _status: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * The user's signature on the agreement
     * @param _agreementHash The agreement hash being signed
     */
    signAgreement(
      _agreementHash: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get the user's overall whitelist status
     * @param _user The address of the user
     */
    isApproved(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the useApprovals boolean
     */
    getUseApprovals(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the agreementHash
     */
    getAgreementHash(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the user's approval status
     * @param _user The address of the user
     */
    getApproval(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the user's signature status
     * @param _user The address of the user
     */
    getSignature(_user: string, overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getColony(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDeprecated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    multicall(
      data: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param userAddress The user's address
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialise the extension
     * @param _agreementHash An agreement hash (such as an IPFS URI)
     * @param _useApprovals Whether or not to require administrative approval
     */
    initialise(
      _useApprovals: boolean,
      _agreementHash: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Sets user statuses in the whitelist
     * @param _status The whitelist status to set
     * @param _users An array of user addresses
     */
    approveUsers(
      _users: string[],
      _status: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * The user's signature on the agreement
     * @param _agreementHash The agreement hash being signed
     */
    signAgreement(
      _agreementHash: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the user's overall whitelist status
     * @param _user The address of the user
     */
    isApproved(
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the useApprovals boolean
     */
    getUseApprovals(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the agreementHash
     */
    getAgreementHash(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the user's approval status
     * @param _user The address of the user
     */
    getApproval(
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the user's signature status
     * @param _user The address of the user
     */
    getSignature(
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
