/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export interface CoinMachineInterface extends utils.Interface {
  functions: {
    "authority()": FunctionFragment;
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getCapabilityRoles(bytes4)": FunctionFragment;
    "getChainId()": FunctionFragment;
    "getColony()": FunctionFragment;
    "getDeprecated()": FunctionFragment;
    "owner()": FunctionFragment;
    "setAuthority(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "verify(address,uint256,uint256,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getMetatransactionNonce(address)": FunctionFragment;
    "identifier()": FunctionFragment;
    "version()": FunctionFragment;
    "install(address)": FunctionFragment;
    "finishUpgrade()": FunctionFragment;
    "deprecate(bool)": FunctionFragment;
    "uninstall()": FunctionFragment;
    "initialise(address,address,uint256,uint256,uint256,uint256,uint256,uint256,address)": FunctionFragment;
    "setWhitelist(address)": FunctionFragment;
    "buyTokens(uint256)": FunctionFragment;
    "updatePeriod()": FunctionFragment;
    "getPurchaseToken()": FunctionFragment;
    "getToken()": FunctionFragment;
    "getActivePeriod()": FunctionFragment;
    "getActiveSold()": FunctionFragment;
    "getActiveIntake()": FunctionFragment;
    "getEMAIntake()": FunctionFragment;
    "getTokenBalance()": FunctionFragment;
    "getPeriodLength()": FunctionFragment;
    "getWindowSize()": FunctionFragment;
    "getTargetPerPeriod()": FunctionFragment;
    "getMaxPerPeriod()": FunctionFragment;
    "getCurrentPrice()": FunctionFragment;
    "getSellableTokens()": FunctionFragment;
    "getUserLimit(address)": FunctionFragment;
    "getMaxPurchase(address)": FunctionFragment;
    "getWhitelist()": FunctionFragment;
    "getEvolvePrice()": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "authority"
      | "executeMetaTransaction"
      | "getCapabilityRoles"
      | "getChainId"
      | "getColony"
      | "getDeprecated"
      | "owner"
      | "setAuthority"
      | "setOwner"
      | "verify"
      | "getMetatransactionNonce"
      | "identifier"
      | "version"
      | "install"
      | "finishUpgrade"
      | "deprecate"
      | "uninstall"
      | "initialise"
      | "setWhitelist"
      | "buyTokens"
      | "updatePeriod"
      | "getPurchaseToken"
      | "getToken"
      | "getActivePeriod"
      | "getActiveSold"
      | "getActiveIntake"
      | "getEMAIntake"
      | "getTokenBalance"
      | "getPeriodLength"
      | "getWindowSize"
      | "getTargetPerPeriod"
      | "getMaxPerPeriod"
      | "getCurrentPrice"
      | "getSellableTokens"
      | "getUserLimit"
      | "getMaxPurchase"
      | "getWhitelist"
      | "getEvolvePrice"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [string, BytesLike, BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCapabilityRoles",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getChainId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getColony", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getDeprecated",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAuthority",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "setOwner", values: [string]): string;
  encodeFunctionData(
    functionFragment: "verify",
    values: [
      string,
      BigNumberish,
      BigNumberish,
      BytesLike,
      BytesLike,
      BytesLike,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetatransactionNonce",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "identifier",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(functionFragment: "install", values: [string]): string;
  encodeFunctionData(
    functionFragment: "finishUpgrade",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "deprecate", values: [boolean]): string;
  encodeFunctionData(functionFragment: "uninstall", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "initialise",
    values: [
      string,
      string,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      BigNumberish,
      string
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "setWhitelist",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "buyTokens",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updatePeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPurchaseToken",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getToken", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getActivePeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveSold",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getActiveIntake",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getEMAIntake",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenBalance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getPeriodLength",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getWindowSize",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getTargetPerPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMaxPerPeriod",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentPrice",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getSellableTokens",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getUserLimit",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getMaxPurchase",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getWhitelist",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getEvolvePrice",
    values?: undefined
  ): string;

  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCapabilityRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getChainId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getColony", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDeprecated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "verify", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMetatransactionNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "identifier", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "install", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finishUpgrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deprecate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "uninstall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "initialise", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "buyTokens", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "updatePeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPurchaseToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getToken", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getActivePeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveSold",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getActiveIntake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getEMAIntake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenBalance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPeriodLength",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWindowSize",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTargetPerPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMaxPerPeriod",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentPrice",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSellableTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getUserLimit",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMaxPurchase",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getEvolvePrice",
    data: BytesLike
  ): Result;

  events: {
    "ExtensionInitialised()": EventFragment;
    "LogSetAuthority(address)": EventFragment;
    "LogSetOwner(address)": EventFragment;
    "MetaTransactionExecuted(address,address,bytes)": EventFragment;
    "PeriodUpdated(uint256,uint256)": EventFragment;
    "PriceEvolutionSet(bool)": EventFragment;
    "TokensBought(address,address,uint256,uint256)": EventFragment;
    "WhitelistSet(address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ExtensionInitialised"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PeriodUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "PriceEvolutionSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokensBought"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "WhitelistSet"): EventFragment;
}

export interface ExtensionInitialisedEventObject {}
export type ExtensionInitialisedEvent = TypedEvent<
  [],
  ExtensionInitialisedEventObject
>;

export type ExtensionInitialisedEventFilter =
  TypedEventFilter<ExtensionInitialisedEvent>;

export interface LogSetAuthorityEventObject {
  authority: string;
}
export type LogSetAuthorityEvent = TypedEvent<
  [string],
  LogSetAuthorityEventObject
>;

export type LogSetAuthorityEventFilter = TypedEventFilter<LogSetAuthorityEvent>;

export interface LogSetOwnerEventObject {
  owner: string;
}
export type LogSetOwnerEvent = TypedEvent<[string], LogSetOwnerEventObject>;

export type LogSetOwnerEventFilter = TypedEventFilter<LogSetOwnerEvent>;

export interface MetaTransactionExecutedEventObject {
  user: string;
  relayerAddress: string;
  functionSignature: string;
}
export type MetaTransactionExecutedEvent = TypedEvent<
  [string, string, string],
  MetaTransactionExecutedEventObject
>;

export type MetaTransactionExecutedEventFilter =
  TypedEventFilter<MetaTransactionExecutedEvent>;

export interface PeriodUpdatedEventObject {
  activePeriod: BigNumber;
  currentPeriod: BigNumber;
}
export type PeriodUpdatedEvent = TypedEvent<
  [BigNumber, BigNumber],
  PeriodUpdatedEventObject
>;

export type PeriodUpdatedEventFilter = TypedEventFilter<PeriodUpdatedEvent>;

export interface PriceEvolutionSetEventObject {
  evolvePrice: boolean;
}
export type PriceEvolutionSetEvent = TypedEvent<
  [boolean],
  PriceEvolutionSetEventObject
>;

export type PriceEvolutionSetEventFilter =
  TypedEventFilter<PriceEvolutionSetEvent>;

export interface TokensBoughtEventObject {
  buyer: string;
  token: string;
  numTokens: BigNumber;
  totalCost: BigNumber;
}
export type TokensBoughtEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  TokensBoughtEventObject
>;

export type TokensBoughtEventFilter = TypedEventFilter<TokensBoughtEvent>;

export interface WhitelistSetEventObject {
  whitelist: string;
}
export type WhitelistSetEvent = TypedEvent<[string], WhitelistSetEventObject>;

export type WhitelistSetEventFilter = TypedEventFilter<WhitelistSetEvent>;

export interface CoinMachine extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: CoinMachineInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    authority(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getChainId(overrides?: CallOverrides): Promise<[BigNumber]>;

    getColony(overrides?: CallOverrides): Promise<[string]>;

    getDeprecated(overrides?: CallOverrides): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param _userAddress The user's address
     */
    getMetatransactionNonce(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _nonce: BigNumber }>;

    /**
     * Returns the identifier of the extension
     */
    identifier(
      overrides?: CallOverrides
    ): Promise<[string] & { _identifier: string }>;

    /**
     * Returns the version of the extension
     */
    version(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _version: BigNumber }>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Must be called before any sales can be made
     * @param _maxPerPeriod The maximum number of tokens that can be sold per period
     * @param _periodLength How long in seconds each period of the sale should last
     * @param _purchaseToken The token to receive payments in. Use 0x0 for ether
     * @param _startingPrice The sale price to start at, expressed in units of _purchaseToken per token being sold, as a WAD
     * @param _targetPerPeriod The number of tokens to aim to sell per period
     * @param _token The token we are selling. Cannot be ether
     * @param _userLimitFraction The fraction of the total sale that a single user can buy (in WAD)
     * @param _whitelist Optionally an address of a whitelist contract to use can be provided. Pass 0x0 if no whitelist being used
     * @param _windowSize Characteristic number of periods that should be used for the moving average. In the long-term, 86% of the weighting will be in this window size. The higher the number, the slower the price will be to adjust
     */
    initialise(
      _token: string,
      _purchaseToken: string,
      _periodLength: BigNumberish,
      _windowSize: BigNumberish,
      _targetPerPeriod: BigNumberish,
      _maxPerPeriod: BigNumberish,
      _userLimitFraction: BigNumberish,
      _startingPrice: BigNumberish,
      _whitelist: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Set the address for an (optional) whitelist
     * @param _whitelist The address of the whitelist
     */
    setWhitelist(
      _whitelist: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Purchase tokens from Coin Machine.
     * @param _numTokens The number of tokens to purchase
     */
    buyTokens(
      _numTokens: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Bring the token accounting current
     */
    updatePeriod(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the address of the token being used to make purchases
     */
    getPurchaseToken(
      overrides?: CallOverrides
    ): Promise<[string] & { _token: string }>;

    /**
     * Get the address of the token being sold
     */
    getToken(overrides?: CallOverrides): Promise<[string] & { _token: string }>;

    /**
     * Get the period that the price was last updated for or a purchase was made
     */
    getActivePeriod(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _period: BigNumber }>;

    /**
     * Get the number of tokens sold in the period that the price was last updated for or a purchase was made
     */
    getActiveSold(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _sold: BigNumber }>;

    /**
     * Get the number of tokens received in the period that the price was last updated for or a purchase was made
     */
    getActiveIntake(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _intake: BigNumber }>;

    /**
     * Get the EMA of the number of tokens received each period
     */
    getEMAIntake(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _amount: BigNumber }>;

    /**
     * Get the remaining balance of tokens
     */
    getTokenBalance(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _balance: BigNumber }>;

    /**
     * Get the length of the sale period
     */
    getPeriodLength(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _length: BigNumber }>;

    /**
     * Get the size of the averaging window
     */
    getWindowSize(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _size: BigNumber }>;

    /**
     * Get the target number of tokens to sell per period
     */
    getTargetPerPeriod(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _target: BigNumber }>;

    /**
     * Get the maximum number of tokens to sell per period
     */
    getMaxPerPeriod(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _max: BigNumber }>;

    /**
     * Get the current price per token
     */
    getCurrentPrice(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _price: BigNumber }>;

    /**
     * Get the number of remaining tokens for sale this period
     */
    getSellableTokens(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _remaining: BigNumber }>;

    /**
     * Get the maximum amount of tokens a user can purchase in total
     * @param _user The user's address
     */
    getUserLimit(
      _user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _max: BigNumber }>;

    /**
     * Get the maximum amount of tokens a user can purchase in a period
     * @param _user The user's address
     */
    getMaxPurchase(
      _user: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _max: BigNumber }>;

    /**
     * Get the address of the whitelist (if exists)
     */
    getWhitelist(
      overrides?: CallOverrides
    ): Promise<[string] & { _whitelist: string }>;

    /**
     * Get the evolvePrice boolean
     */
    getEvolvePrice(
      overrides?: CallOverrides
    ): Promise<[boolean] & { _evolve: boolean }>;
  };

  authority(overrides?: CallOverrides): Promise<string>;

  /**
   * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
   * @param _payload Function call to make via meta transaction
   * @param _sigR R part of the signature
   * @param _sigS S part of the signature
   * @param _sigV V part of the signature
   * @param _user Address of user trying to do meta transaction
   */
  executeMetaTransaction(
    _user: string,
    _payload: BytesLike,
    _sigR: BytesLike,
    _sigS: BytesLike,
    _sigV: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  getCapabilityRoles(
    _sig: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  getChainId(overrides?: CallOverrides): Promise<BigNumber>;

  getColony(overrides?: CallOverrides): Promise<string>;

  getDeprecated(overrides?: CallOverrides): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  setAuthority(
    authority_: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    owner_: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  verify(
    _owner: string,
    _nonce: BigNumberish,
    _chainId: BigNumberish,
    _payload: BytesLike,
    _sigR: BytesLike,
    _sigS: BytesLike,
    _sigV: BigNumberish,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Gets the next nonce for a meta-transaction
   * @param _userAddress The user's address
   */
  getMetatransactionNonce(
    _userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the identifier of the extension
   */
  identifier(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the version of the extension
   */
  version(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Configures the extension
   * @param _colony The colony in which the extension holds permissions
   */
  install(
    _colony: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called when upgrading the extension
   */
  finishUpgrade(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called when deprecating (or undeprecating) the extension
   * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
   */
  deprecate(
    _deprecated: boolean,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called when uninstalling the extension
   */
  uninstall(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Must be called before any sales can be made
   * @param _maxPerPeriod The maximum number of tokens that can be sold per period
   * @param _periodLength How long in seconds each period of the sale should last
   * @param _purchaseToken The token to receive payments in. Use 0x0 for ether
   * @param _startingPrice The sale price to start at, expressed in units of _purchaseToken per token being sold, as a WAD
   * @param _targetPerPeriod The number of tokens to aim to sell per period
   * @param _token The token we are selling. Cannot be ether
   * @param _userLimitFraction The fraction of the total sale that a single user can buy (in WAD)
   * @param _whitelist Optionally an address of a whitelist contract to use can be provided. Pass 0x0 if no whitelist being used
   * @param _windowSize Characteristic number of periods that should be used for the moving average. In the long-term, 86% of the weighting will be in this window size. The higher the number, the slower the price will be to adjust
   */
  initialise(
    _token: string,
    _purchaseToken: string,
    _periodLength: BigNumberish,
    _windowSize: BigNumberish,
    _targetPerPeriod: BigNumberish,
    _maxPerPeriod: BigNumberish,
    _userLimitFraction: BigNumberish,
    _startingPrice: BigNumberish,
    _whitelist: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Set the address for an (optional) whitelist
   * @param _whitelist The address of the whitelist
   */
  setWhitelist(
    _whitelist: string,
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Purchase tokens from Coin Machine.
   * @param _numTokens The number of tokens to purchase
   */
  buyTokens(
    _numTokens: BigNumberish,
    overrides?: PayableOverrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Bring the token accounting current
   */
  updatePeriod(
    overrides?: Overrides & { from?: string | Promise<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the address of the token being used to make purchases
   */
  getPurchaseToken(overrides?: CallOverrides): Promise<string>;

  /**
   * Get the address of the token being sold
   */
  getToken(overrides?: CallOverrides): Promise<string>;

  /**
   * Get the period that the price was last updated for or a purchase was made
   */
  getActivePeriod(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the number of tokens sold in the period that the price was last updated for or a purchase was made
   */
  getActiveSold(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the number of tokens received in the period that the price was last updated for or a purchase was made
   */
  getActiveIntake(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the EMA of the number of tokens received each period
   */
  getEMAIntake(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the remaining balance of tokens
   */
  getTokenBalance(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the length of the sale period
   */
  getPeriodLength(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the size of the averaging window
   */
  getWindowSize(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the target number of tokens to sell per period
   */
  getTargetPerPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the maximum number of tokens to sell per period
   */
  getMaxPerPeriod(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the current price per token
   */
  getCurrentPrice(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the number of remaining tokens for sale this period
   */
  getSellableTokens(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the maximum amount of tokens a user can purchase in total
   * @param _user The user's address
   */
  getUserLimit(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the maximum amount of tokens a user can purchase in a period
   * @param _user The user's address
   */
  getMaxPurchase(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the address of the whitelist (if exists)
   */
  getWhitelist(overrides?: CallOverrides): Promise<string>;

  /**
   * Get the evolvePrice boolean
   */
  getEvolvePrice(overrides?: CallOverrides): Promise<boolean>;

  callStatic: {
    authority(overrides?: CallOverrides): Promise<string>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<string>;

    getDeprecated(overrides?: CallOverrides): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    setAuthority(authority_: string, overrides?: CallOverrides): Promise<void>;

    setOwner(owner_: string, overrides?: CallOverrides): Promise<void>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param _userAddress The user's address
     */
    getMetatransactionNonce(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(_colony: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(overrides?: CallOverrides): Promise<void>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(_deprecated: boolean, overrides?: CallOverrides): Promise<void>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(overrides?: CallOverrides): Promise<void>;

    /**
     * Must be called before any sales can be made
     * @param _maxPerPeriod The maximum number of tokens that can be sold per period
     * @param _periodLength How long in seconds each period of the sale should last
     * @param _purchaseToken The token to receive payments in. Use 0x0 for ether
     * @param _startingPrice The sale price to start at, expressed in units of _purchaseToken per token being sold, as a WAD
     * @param _targetPerPeriod The number of tokens to aim to sell per period
     * @param _token The token we are selling. Cannot be ether
     * @param _userLimitFraction The fraction of the total sale that a single user can buy (in WAD)
     * @param _whitelist Optionally an address of a whitelist contract to use can be provided. Pass 0x0 if no whitelist being used
     * @param _windowSize Characteristic number of periods that should be used for the moving average. In the long-term, 86% of the weighting will be in this window size. The higher the number, the slower the price will be to adjust
     */
    initialise(
      _token: string,
      _purchaseToken: string,
      _periodLength: BigNumberish,
      _windowSize: BigNumberish,
      _targetPerPeriod: BigNumberish,
      _maxPerPeriod: BigNumberish,
      _userLimitFraction: BigNumberish,
      _startingPrice: BigNumberish,
      _whitelist: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set the address for an (optional) whitelist
     * @param _whitelist The address of the whitelist
     */
    setWhitelist(_whitelist: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Purchase tokens from Coin Machine.
     * @param _numTokens The number of tokens to purchase
     */
    buyTokens(
      _numTokens: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Bring the token accounting current
     */
    updatePeriod(overrides?: CallOverrides): Promise<void>;

    /**
     * Get the address of the token being used to make purchases
     */
    getPurchaseToken(overrides?: CallOverrides): Promise<string>;

    /**
     * Get the address of the token being sold
     */
    getToken(overrides?: CallOverrides): Promise<string>;

    /**
     * Get the period that the price was last updated for or a purchase was made
     */
    getActivePeriod(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the number of tokens sold in the period that the price was last updated for or a purchase was made
     */
    getActiveSold(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the number of tokens received in the period that the price was last updated for or a purchase was made
     */
    getActiveIntake(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the EMA of the number of tokens received each period
     */
    getEMAIntake(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the remaining balance of tokens
     */
    getTokenBalance(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the length of the sale period
     */
    getPeriodLength(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the size of the averaging window
     */
    getWindowSize(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the target number of tokens to sell per period
     */
    getTargetPerPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the maximum number of tokens to sell per period
     */
    getMaxPerPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the current price per token
     */
    getCurrentPrice(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the number of remaining tokens for sale this period
     */
    getSellableTokens(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the maximum amount of tokens a user can purchase in total
     * @param _user The user's address
     */
    getUserLimit(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the maximum amount of tokens a user can purchase in a period
     * @param _user The user's address
     */
    getMaxPurchase(
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the address of the whitelist (if exists)
     */
    getWhitelist(overrides?: CallOverrides): Promise<string>;

    /**
     * Get the evolvePrice boolean
     */
    getEvolvePrice(overrides?: CallOverrides): Promise<boolean>;
  };

  filters: {
    "ExtensionInitialised()"(): ExtensionInitialisedEventFilter;
    ExtensionInitialised(): ExtensionInitialisedEventFilter;

    "LogSetAuthority(address)"(
      authority?: string | null
    ): LogSetAuthorityEventFilter;
    LogSetAuthority(authority?: string | null): LogSetAuthorityEventFilter;

    "LogSetOwner(address)"(owner?: string | null): LogSetOwnerEventFilter;
    LogSetOwner(owner?: string | null): LogSetOwnerEventFilter;

    "MetaTransactionExecuted(address,address,bytes)"(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;
    MetaTransactionExecuted(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;

    "PeriodUpdated(uint256,uint256)"(
      activePeriod?: null,
      currentPeriod?: null
    ): PeriodUpdatedEventFilter;
    PeriodUpdated(
      activePeriod?: null,
      currentPeriod?: null
    ): PeriodUpdatedEventFilter;

    "PriceEvolutionSet(bool)"(evolvePrice?: null): PriceEvolutionSetEventFilter;
    PriceEvolutionSet(evolvePrice?: null): PriceEvolutionSetEventFilter;

    "TokensBought(address,address,uint256,uint256)"(
      buyer?: string | null,
      token?: null,
      numTokens?: null,
      totalCost?: null
    ): TokensBoughtEventFilter;
    TokensBought(
      buyer?: string | null,
      token?: null,
      numTokens?: null,
      totalCost?: null
    ): TokensBoughtEventFilter;

    "WhitelistSet(address)"(whitelist?: null): WhitelistSetEventFilter;
    WhitelistSet(whitelist?: null): WhitelistSetEventFilter;
  };

  estimateGas: {
    authority(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<BigNumber>;

    getDeprecated(overrides?: CallOverrides): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param _userAddress The user's address
     */
    getMetatransactionNonce(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Must be called before any sales can be made
     * @param _maxPerPeriod The maximum number of tokens that can be sold per period
     * @param _periodLength How long in seconds each period of the sale should last
     * @param _purchaseToken The token to receive payments in. Use 0x0 for ether
     * @param _startingPrice The sale price to start at, expressed in units of _purchaseToken per token being sold, as a WAD
     * @param _targetPerPeriod The number of tokens to aim to sell per period
     * @param _token The token we are selling. Cannot be ether
     * @param _userLimitFraction The fraction of the total sale that a single user can buy (in WAD)
     * @param _whitelist Optionally an address of a whitelist contract to use can be provided. Pass 0x0 if no whitelist being used
     * @param _windowSize Characteristic number of periods that should be used for the moving average. In the long-term, 86% of the weighting will be in this window size. The higher the number, the slower the price will be to adjust
     */
    initialise(
      _token: string,
      _purchaseToken: string,
      _periodLength: BigNumberish,
      _windowSize: BigNumberish,
      _targetPerPeriod: BigNumberish,
      _maxPerPeriod: BigNumberish,
      _userLimitFraction: BigNumberish,
      _startingPrice: BigNumberish,
      _whitelist: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Set the address for an (optional) whitelist
     * @param _whitelist The address of the whitelist
     */
    setWhitelist(
      _whitelist: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Purchase tokens from Coin Machine.
     * @param _numTokens The number of tokens to purchase
     */
    buyTokens(
      _numTokens: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Bring the token accounting current
     */
    updatePeriod(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<BigNumber>;

    /**
     * Get the address of the token being used to make purchases
     */
    getPurchaseToken(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the address of the token being sold
     */
    getToken(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the period that the price was last updated for or a purchase was made
     */
    getActivePeriod(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the number of tokens sold in the period that the price was last updated for or a purchase was made
     */
    getActiveSold(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the number of tokens received in the period that the price was last updated for or a purchase was made
     */
    getActiveIntake(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the EMA of the number of tokens received each period
     */
    getEMAIntake(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the remaining balance of tokens
     */
    getTokenBalance(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the length of the sale period
     */
    getPeriodLength(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the size of the averaging window
     */
    getWindowSize(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the target number of tokens to sell per period
     */
    getTargetPerPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the maximum number of tokens to sell per period
     */
    getMaxPerPeriod(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the current price per token
     */
    getCurrentPrice(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the number of remaining tokens for sale this period
     */
    getSellableTokens(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the maximum amount of tokens a user can purchase in total
     * @param _user The user's address
     */
    getUserLimit(_user: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the maximum amount of tokens a user can purchase in a period
     * @param _user The user's address
     */
    getMaxPurchase(
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the address of the whitelist (if exists)
     */
    getWhitelist(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the evolvePrice boolean
     */
    getEvolvePrice(overrides?: CallOverrides): Promise<BigNumber>;
  };

  populateTransaction: {
    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: string,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    getCapabilityRoles(
      _sig: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getColony(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDeprecated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      authority_: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      owner_: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    verify(
      _owner: string,
      _nonce: BigNumberish,
      _chainId: BigNumberish,
      _payload: BytesLike,
      _sigR: BytesLike,
      _sigS: BytesLike,
      _sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param _userAddress The user's address
     */
    getMetatransactionNonce(
      _userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: boolean,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Must be called before any sales can be made
     * @param _maxPerPeriod The maximum number of tokens that can be sold per period
     * @param _periodLength How long in seconds each period of the sale should last
     * @param _purchaseToken The token to receive payments in. Use 0x0 for ether
     * @param _startingPrice The sale price to start at, expressed in units of _purchaseToken per token being sold, as a WAD
     * @param _targetPerPeriod The number of tokens to aim to sell per period
     * @param _token The token we are selling. Cannot be ether
     * @param _userLimitFraction The fraction of the total sale that a single user can buy (in WAD)
     * @param _whitelist Optionally an address of a whitelist contract to use can be provided. Pass 0x0 if no whitelist being used
     * @param _windowSize Characteristic number of periods that should be used for the moving average. In the long-term, 86% of the weighting will be in this window size. The higher the number, the slower the price will be to adjust
     */
    initialise(
      _token: string,
      _purchaseToken: string,
      _periodLength: BigNumberish,
      _windowSize: BigNumberish,
      _targetPerPeriod: BigNumberish,
      _maxPerPeriod: BigNumberish,
      _userLimitFraction: BigNumberish,
      _startingPrice: BigNumberish,
      _whitelist: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the address for an (optional) whitelist
     * @param _whitelist The address of the whitelist
     */
    setWhitelist(
      _whitelist: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Purchase tokens from Coin Machine.
     * @param _numTokens The number of tokens to purchase
     */
    buyTokens(
      _numTokens: BigNumberish,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Bring the token accounting current
     */
    updatePeriod(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the address of the token being used to make purchases
     */
    getPurchaseToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the address of the token being sold
     */
    getToken(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the period that the price was last updated for or a purchase was made
     */
    getActivePeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the number of tokens sold in the period that the price was last updated for or a purchase was made
     */
    getActiveSold(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the number of tokens received in the period that the price was last updated for or a purchase was made
     */
    getActiveIntake(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the EMA of the number of tokens received each period
     */
    getEMAIntake(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the remaining balance of tokens
     */
    getTokenBalance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the length of the sale period
     */
    getPeriodLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the size of the averaging window
     */
    getWindowSize(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the target number of tokens to sell per period
     */
    getTargetPerPeriod(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the maximum number of tokens to sell per period
     */
    getMaxPerPeriod(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the current price per token
     */
    getCurrentPrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the number of remaining tokens for sale this period
     */
    getSellableTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the maximum amount of tokens a user can purchase in total
     * @param _user The user's address
     */
    getUserLimit(
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the maximum amount of tokens a user can purchase in a period
     * @param _user The user's address
     */
    getMaxPurchase(
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the address of the whitelist (if exists)
     */
    getWhitelist(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the evolvePrice boolean
     */
    getEvolvePrice(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  };
}
