/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace ColonyNetworkDataTypes {
  export type ReputationLogEntryStruct = {
    user: string;
    amount: BigNumberish;
    skillId: BigNumberish;
    colony: string;
    nUpdates: BigNumberish;
    nPreviousUpdates: BigNumberish;
  };

  export type ReputationLogEntryStructOutput = [
    string,
    BigNumber,
    BigNumber,
    string,
    BigNumber,
    BigNumber
  ] & {
    user: string;
    amount: BigNumber;
    skillId: BigNumber;
    colony: string;
    nUpdates: BigNumber;
    nPreviousUpdates: BigNumber;
  };

  export type SkillStruct = {
    nParents: BigNumberish;
    nChildren: BigNumberish;
    parents: BigNumberish[];
    children: BigNumberish[];
    globalSkill: boolean;
    deprecated: boolean;
  };

  export type SkillStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber[],
    BigNumber[],
    boolean,
    boolean
  ] & {
    nParents: BigNumber;
    nChildren: BigNumber;
    parents: BigNumber[];
    children: BigNumber[];
    globalSkill: boolean;
    deprecated: boolean;
  };

  export type MiningStakeStruct = {
    amount: BigNumberish;
    timestamp: BigNumberish;
  };

  export type MiningStakeStructOutput = [BigNumber, BigNumber] & {
    amount: BigNumber;
    timestamp: BigNumber;
  };
}

export interface IColonyNetworkInterface extends utils.Interface {
  functions: {
    "approveExitRecovery()": FunctionFragment;
    "checkNotAdditionalProtectedVariable(uint256)": FunctionFragment;
    "enterRecoveryMode()": FunctionFragment;
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "exitRecoveryMode()": FunctionFragment;
    "getMetatransactionNonce(address)": FunctionFragment;
    "isInRecoveryMode()": FunctionFragment;
    "multicall(bytes[])": FunctionFragment;
    "numRecoveryRoles()": FunctionFragment;
    "removeRecoveryRole(address)": FunctionFragment;
    "setRecoveryRole(address)": FunctionFragment;
    "setStorageSlotRecovery(uint256,bytes32)": FunctionFragment;
    "supportsInterface(bytes4)": FunctionFragment;
    "setReplacementReputationUpdateLogEntry(address,uint256,address,int256,uint256,address,uint128,uint128)": FunctionFragment;
    "getReplacementReputationUpdateLogEntry(address,uint256)": FunctionFragment;
    "getReplacementReputationUpdateLogsExist(address)": FunctionFragment;
    "getMetaColony()": FunctionFragment;
    "getColonyCount()": FunctionFragment;
    "isColony(address)": FunctionFragment;
    "addSkill(uint256)": FunctionFragment;
    "getSkill(uint256)": FunctionFragment;
    "deprecateSkill(uint256)": FunctionFragment;
    "deprecateSkill(uint256,bool)": FunctionFragment;
    "initialiseRootLocalSkill()": FunctionFragment;
    "appendReputationUpdateLog(address,int256,uint256)": FunctionFragment;
    "getSkillCount()": FunctionFragment;
    "getReputationMiningSkillId()": FunctionFragment;
    "setTokenLocking(address)": FunctionFragment;
    "getTokenLocking()": FunctionFragment;
    "createMetaColony(address)": FunctionFragment;
    "createColony(address)": FunctionFragment;
    "createColony(address,uint256,string,string)": FunctionFragment;
    "createColony(address,uint256,string)": FunctionFragment;
    "createColony(address,uint256,string,string,bool)": FunctionFragment;
    "createColonyForFrontend(address,string,string,uint8,uint256,string,string)": FunctionFragment;
    "addColonyVersion(uint256,address)": FunctionFragment;
    "initialise(address,uint256)": FunctionFragment;
    "getColony(uint256)": FunctionFragment;
    "getCurrentColonyVersion()": FunctionFragment;
    "getParentSkillId(uint256,uint256)": FunctionFragment;
    "getChildSkillId(uint256,uint256)": FunctionFragment;
    "getReputationMiningCycle(bool)": FunctionFragment;
    "calculateMinerWeight(uint256,uint256)": FunctionFragment;
    "getColonyVersionResolver(uint256)": FunctionFragment;
    "setReputationRootHash(bytes32,uint256,address[])": FunctionFragment;
    "startNextCycle()": FunctionFragment;
    "initialiseReputationMining()": FunctionFragment;
    "getReputationRootHash()": FunctionFragment;
    "getReputationRootHashNLeaves()": FunctionFragment;
    "getReputationRootHashNNodes()": FunctionFragment;
    "startTokenAuction(address)": FunctionFragment;
    "setupRegistrar(address,bytes32)": FunctionFragment;
    "registerUserLabel(string,string)": FunctionFragment;
    "registerColonyLabel(string,string)": FunctionFragment;
    "updateColonyOrbitDB(string)": FunctionFragment;
    "updateUserOrbitDB(string)": FunctionFragment;
    "getProfileDBAddress(bytes32)": FunctionFragment;
    "lookupRegisteredENSDomain(address)": FunctionFragment;
    "addr(bytes32)": FunctionFragment;
    "getENSRegistrar()": FunctionFragment;
    "setMiningResolver(address)": FunctionFragment;
    "getMiningResolver()": FunctionFragment;
    "addExtensionToNetwork(bytes32,address)": FunctionFragment;
    "installExtension(bytes32,uint256)": FunctionFragment;
    "upgradeExtension(bytes32,uint256)": FunctionFragment;
    "deprecateExtension(bytes32,bool)": FunctionFragment;
    "uninstallExtension(bytes32)": FunctionFragment;
    "getExtensionResolver(bytes32,uint256)": FunctionFragment;
    "getExtensionInstallation(bytes32,address)": FunctionFragment;
    "getFeeInverse()": FunctionFragment;
    "setFeeInverse(uint256)": FunctionFragment;
    "getPayoutWhitelist(address)": FunctionFragment;
    "setPayoutWhitelist(address,bool)": FunctionFragment;
    "punishStakers(address[],uint256)": FunctionFragment;
    "stakeForMining(uint256)": FunctionFragment;
    "unstakeForMining(uint256)": FunctionFragment;
    "getMiningStake(address)": FunctionFragment;
    "reward(address,uint256)": FunctionFragment;
    "burnUnneededRewards(uint256)": FunctionFragment;
    "claimMiningReward(address)": FunctionFragment;
    "setReputationMiningCycleReward(uint256)": FunctionFragment;
    "getReputationMiningCycleReward()": FunctionFragment;
    "deployTokenViaNetwork(string,string,uint8)": FunctionFragment;
    "deployTokenAuthority(address,address,address[])": FunctionFragment;
    "setMiningDelegate(address,bool)": FunctionFragment;
    "getMiningDelegator(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "approveExitRecovery"
      | "checkNotAdditionalProtectedVariable"
      | "enterRecoveryMode"
      | "executeMetaTransaction"
      | "exitRecoveryMode"
      | "getMetatransactionNonce"
      | "isInRecoveryMode"
      | "multicall"
      | "numRecoveryRoles"
      | "removeRecoveryRole"
      | "setRecoveryRole"
      | "setStorageSlotRecovery"
      | "supportsInterface"
      | "setReplacementReputationUpdateLogEntry"
      | "getReplacementReputationUpdateLogEntry"
      | "getReplacementReputationUpdateLogsExist"
      | "getMetaColony"
      | "getColonyCount"
      | "isColony"
      | "addSkill"
      | "getSkill"
      | "deprecateSkill(uint256)"
      | "deprecateSkill(uint256,bool)"
      | "initialiseRootLocalSkill"
      | "appendReputationUpdateLog"
      | "getSkillCount"
      | "getReputationMiningSkillId"
      | "setTokenLocking"
      | "getTokenLocking"
      | "createMetaColony"
      | "createColony(address)"
      | "createColony(address,uint256,string,string)"
      | "createColony(address,uint256,string)"
      | "createColony(address,uint256,string,string,bool)"
      | "createColonyForFrontend"
      | "addColonyVersion"
      | "initialise"
      | "getColony"
      | "getCurrentColonyVersion"
      | "getParentSkillId"
      | "getChildSkillId"
      | "getReputationMiningCycle"
      | "calculateMinerWeight"
      | "getColonyVersionResolver"
      | "setReputationRootHash"
      | "startNextCycle"
      | "initialiseReputationMining"
      | "getReputationRootHash"
      | "getReputationRootHashNLeaves"
      | "getReputationRootHashNNodes"
      | "startTokenAuction"
      | "setupRegistrar"
      | "registerUserLabel"
      | "registerColonyLabel"
      | "updateColonyOrbitDB"
      | "updateUserOrbitDB"
      | "getProfileDBAddress"
      | "lookupRegisteredENSDomain"
      | "addr"
      | "getENSRegistrar"
      | "setMiningResolver"
      | "getMiningResolver"
      | "addExtensionToNetwork"
      | "installExtension"
      | "upgradeExtension"
      | "deprecateExtension"
      | "uninstallExtension"
      | "getExtensionResolver"
      | "getExtensionInstallation"
      | "getFeeInverse"
      | "setFeeInverse"
      | "getPayoutWhitelist"
      | "setPayoutWhitelist"
      | "punishStakers"
      | "stakeForMining"
      | "unstakeForMining"
      | "getMiningStake"
      | "reward"
      | "burnUnneededRewards"
      | "claimMiningReward"
      | "setReputationMiningCycleReward"
      | "getReputationMiningCycleReward"
      | "deployTokenViaNetwork"
      | "deployTokenAuthority"
      | "setMiningDelegate"
      | "getMiningDelegator"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "approveExitRecovery",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "checkNotAdditionalProtectedVariable",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "enterRecoveryMode",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [string, BytesLike, BytesLike, BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "exitRecoveryMode",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getMetatransactionNonce",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "isInRecoveryMode",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [BytesLike[]]
  ): string;
  encodeFunctionData(
    functionFragment: "numRecoveryRoles",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "removeRecoveryRole",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setRecoveryRole",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setStorageSlotRecovery",
    values: [BigNumberish, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "supportsInterface",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "setReplacementReputationUpdateLogEntry",
    values: [
      string,
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish,
      string,
      BigNumberish,
      BigNumberish
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getReplacementReputationUpdateLogEntry",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getReplacementReputationUpdateLogsExist",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetaColony",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getColonyCount",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "isColony", values: [string]): string;
  encodeFunctionData(
    functionFragment: "addSkill",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getSkill",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deprecateSkill(uint256)",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deprecateSkill(uint256,bool)",
    values: [BigNumberish, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "initialiseRootLocalSkill",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "appendReputationUpdateLog",
    values: [string, BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getSkillCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getReputationMiningSkillId",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setTokenLocking",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getTokenLocking",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "createMetaColony",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "createColony(address)",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "createColony(address,uint256,string,string)",
    values: [string, BigNumberish, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "createColony(address,uint256,string)",
    values: [string, BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "createColony(address,uint256,string,string,bool)",
    values: [string, BigNumberish, string, string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "createColonyForFrontend",
    values: [string, string, string, BigNumberish, BigNumberish, string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "addColonyVersion",
    values: [BigNumberish, string]
  ): string;
  encodeFunctionData(
    functionFragment: "initialise",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getColony",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getCurrentColonyVersion",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getParentSkillId",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getChildSkillId",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getReputationMiningCycle",
    values: [boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "calculateMinerWeight",
    values: [BigNumberish, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getColonyVersionResolver",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "setReputationRootHash",
    values: [BytesLike, BigNumberish, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "startNextCycle",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "initialiseReputationMining",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getReputationRootHash",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getReputationRootHashNLeaves",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getReputationRootHashNNodes",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "startTokenAuction",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setupRegistrar",
    values: [string, BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "registerUserLabel",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "registerColonyLabel",
    values: [string, string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateColonyOrbitDB",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateUserOrbitDB",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getProfileDBAddress",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "lookupRegisteredENSDomain",
    values: [string]
  ): string;
  encodeFunctionData(functionFragment: "addr", values: [BytesLike]): string;
  encodeFunctionData(
    functionFragment: "getENSRegistrar",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setMiningResolver",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "getMiningResolver",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "addExtensionToNetwork",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "installExtension",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "upgradeExtension",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deprecateExtension",
    values: [BytesLike, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "uninstallExtension",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getExtensionResolver",
    values: [BytesLike, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getExtensionInstallation",
    values: [BytesLike, string]
  ): string;
  encodeFunctionData(
    functionFragment: "getFeeInverse",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "setFeeInverse",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getPayoutWhitelist",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setPayoutWhitelist",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "punishStakers",
    values: [string[], BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeForMining",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "unstakeForMining",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getMiningStake",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "reward",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "burnUnneededRewards",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "claimMiningReward",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "setReputationMiningCycleReward",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "getReputationMiningCycleReward",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployTokenViaNetwork",
    values: [string, string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "deployTokenAuthority",
    values: [string, string, string[]]
  ): string;
  encodeFunctionData(
    functionFragment: "setMiningDelegate",
    values: [string, boolean]
  ): string;
  encodeFunctionData(
    functionFragment: "getMiningDelegator",
    values: [string]
  ): string;

  decodeFunctionResult(
    functionFragment: "approveExitRecovery",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "checkNotAdditionalProtectedVariable",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "enterRecoveryMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "exitRecoveryMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetatransactionNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "isInRecoveryMode",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "numRecoveryRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "removeRecoveryRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setRecoveryRole",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setStorageSlotRecovery",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "supportsInterface",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReplacementReputationUpdateLogEntry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReplacementReputationUpdateLogEntry",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReplacementReputationUpdateLogsExist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMetaColony",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getColonyCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "isColony", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "addSkill", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getSkill", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "deprecateSkill(uint256)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deprecateSkill(uint256,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initialiseRootLocalSkill",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "appendReputationUpdateLog",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getSkillCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReputationMiningSkillId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setTokenLocking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTokenLocking",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createMetaColony",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createColony(address)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createColony(address,uint256,string,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createColony(address,uint256,string)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createColony(address,uint256,string,string,bool)",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "createColonyForFrontend",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addColonyVersion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "initialise", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getColony", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getCurrentColonyVersion",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getParentSkillId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getChildSkillId",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReputationMiningCycle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "calculateMinerWeight",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getColonyVersionResolver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReputationRootHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startNextCycle",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "initialiseReputationMining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReputationRootHash",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReputationRootHashNLeaves",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReputationRootHashNNodes",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "startTokenAuction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setupRegistrar",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerUserLabel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "registerColonyLabel",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateColonyOrbitDB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateUserOrbitDB",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProfileDBAddress",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "lookupRegisteredENSDomain",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "addr", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getENSRegistrar",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMiningResolver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMiningResolver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "addExtensionToNetwork",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "installExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "upgradeExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deprecateExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uninstallExtension",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExtensionResolver",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getExtensionInstallation",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getFeeInverse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setFeeInverse",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getPayoutWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setPayoutWhitelist",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "punishStakers",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakeForMining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "unstakeForMining",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMiningStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "reward", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "burnUnneededRewards",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "claimMiningReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setReputationMiningCycleReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getReputationMiningCycleReward",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployTokenViaNetwork",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployTokenAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "setMiningDelegate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getMiningDelegator",
    data: BytesLike
  ): Result;

  events: {
    "AuctionCreated(address,address,uint256)": EventFragment;
    "ColonyAdded(uint256,address,address)": EventFragment;
    "ColonyLabelRegistered(address,bytes32)": EventFragment;
    "ColonyNetworkInitialised(address)": EventFragment;
    "ColonyVersionAdded(uint256,address)": EventFragment;
    "ExtensionAddedToNetwork(bytes32,uint256)": EventFragment;
    "ExtensionDeprecated(bytes32,address,bool)": EventFragment;
    "ExtensionInstalled(bytes32,address,uint256)": EventFragment;
    "ExtensionUninstalled(bytes32,address)": EventFragment;
    "ExtensionUpgraded(bytes32,address,uint256)": EventFragment;
    "MetaColonyCreated(address,address,uint256)": EventFragment;
    "MetaTransactionExecuted(address,address,bytes)": EventFragment;
    "MiningCycleResolverSet(address)": EventFragment;
    "NetworkFeeInverseSet(uint256)": EventFragment;
    "RecoveryModeEntered(address)": EventFragment;
    "RecoveryModeExitApproved(address)": EventFragment;
    "RecoveryModeExited(address)": EventFragment;
    "RecoveryRoleSet(address,bool)": EventFragment;
    "RecoveryStorageSlotSet(address,uint256,bytes32,bytes32)": EventFragment;
    "RegistrarInitialised(address,bytes32)": EventFragment;
    "ReputationMinerPenalised(address,uint256)": EventFragment;
    "ReputationMiningCycleComplete(bytes32,uint256)": EventFragment;
    "ReputationMiningInitialised(address)": EventFragment;
    "ReputationMiningRewardSet(uint256)": EventFragment;
    "ReputationRootHashSet(bytes32,uint256,address[],uint256)": EventFragment;
    "SkillAdded(uint256,uint256)": EventFragment;
    "TokenAuthorityDeployed(address)": EventFragment;
    "TokenDeployed(address)": EventFragment;
    "TokenLockingAddressSet(address)": EventFragment;
    "TokenWhitelisted(address,bool)": EventFragment;
    "UserLabelRegistered(address,bytes32)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "AuctionCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyLabelRegistered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyNetworkInitialised"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ColonyVersionAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExtensionAddedToNetwork"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExtensionDeprecated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExtensionInstalled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExtensionUninstalled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ExtensionUpgraded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaColonyCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MiningCycleResolverSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "NetworkFeeInverseSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryModeEntered"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryModeExitApproved"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryModeExited"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryRoleSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RecoveryStorageSlotSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "RegistrarInitialised"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReputationMinerPenalised"): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ReputationMiningCycleComplete"
  ): EventFragment;
  getEvent(
    nameOrSignatureOrTopic: "ReputationMiningInitialised"
  ): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReputationMiningRewardSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ReputationRootHashSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "SkillAdded"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenAuthorityDeployed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenDeployed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenLockingAddressSet"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenWhitelisted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UserLabelRegistered"): EventFragment;
}

export interface AuctionCreatedEventObject {
  auction: string;
  token: string;
  quantity: BigNumber;
}
export type AuctionCreatedEvent = TypedEvent<
  [string, string, BigNumber],
  AuctionCreatedEventObject
>;

export type AuctionCreatedEventFilter = TypedEventFilter<AuctionCreatedEvent>;

export interface ColonyAddedEventObject {
  colonyId: BigNumber;
  colonyAddress: string;
  token: string;
}
export type ColonyAddedEvent = TypedEvent<
  [BigNumber, string, string],
  ColonyAddedEventObject
>;

export type ColonyAddedEventFilter = TypedEventFilter<ColonyAddedEvent>;

export interface ColonyLabelRegisteredEventObject {
  colony: string;
  label: string;
}
export type ColonyLabelRegisteredEvent = TypedEvent<
  [string, string],
  ColonyLabelRegisteredEventObject
>;

export type ColonyLabelRegisteredEventFilter =
  TypedEventFilter<ColonyLabelRegisteredEvent>;

export interface ColonyNetworkInitialisedEventObject {
  resolver: string;
}
export type ColonyNetworkInitialisedEvent = TypedEvent<
  [string],
  ColonyNetworkInitialisedEventObject
>;

export type ColonyNetworkInitialisedEventFilter =
  TypedEventFilter<ColonyNetworkInitialisedEvent>;

export interface ColonyVersionAddedEventObject {
  version: BigNumber;
  resolver: string;
}
export type ColonyVersionAddedEvent = TypedEvent<
  [BigNumber, string],
  ColonyVersionAddedEventObject
>;

export type ColonyVersionAddedEventFilter =
  TypedEventFilter<ColonyVersionAddedEvent>;

export interface ExtensionAddedToNetworkEventObject {
  extensionId: string;
  version: BigNumber;
}
export type ExtensionAddedToNetworkEvent = TypedEvent<
  [string, BigNumber],
  ExtensionAddedToNetworkEventObject
>;

export type ExtensionAddedToNetworkEventFilter =
  TypedEventFilter<ExtensionAddedToNetworkEvent>;

export interface ExtensionDeprecatedEventObject {
  extensionId: string;
  colony: string;
  deprecated: boolean;
}
export type ExtensionDeprecatedEvent = TypedEvent<
  [string, string, boolean],
  ExtensionDeprecatedEventObject
>;

export type ExtensionDeprecatedEventFilter =
  TypedEventFilter<ExtensionDeprecatedEvent>;

export interface ExtensionInstalledEventObject {
  extensionId: string;
  colony: string;
  version: BigNumber;
}
export type ExtensionInstalledEvent = TypedEvent<
  [string, string, BigNumber],
  ExtensionInstalledEventObject
>;

export type ExtensionInstalledEventFilter =
  TypedEventFilter<ExtensionInstalledEvent>;

export interface ExtensionUninstalledEventObject {
  extensionId: string;
  colony: string;
}
export type ExtensionUninstalledEvent = TypedEvent<
  [string, string],
  ExtensionUninstalledEventObject
>;

export type ExtensionUninstalledEventFilter =
  TypedEventFilter<ExtensionUninstalledEvent>;

export interface ExtensionUpgradedEventObject {
  extensionId: string;
  colony: string;
  version: BigNumber;
}
export type ExtensionUpgradedEvent = TypedEvent<
  [string, string, BigNumber],
  ExtensionUpgradedEventObject
>;

export type ExtensionUpgradedEventFilter =
  TypedEventFilter<ExtensionUpgradedEvent>;

export interface MetaColonyCreatedEventObject {
  metaColony: string;
  token: string;
  rootSkillId: BigNumber;
}
export type MetaColonyCreatedEvent = TypedEvent<
  [string, string, BigNumber],
  MetaColonyCreatedEventObject
>;

export type MetaColonyCreatedEventFilter =
  TypedEventFilter<MetaColonyCreatedEvent>;

export interface MetaTransactionExecutedEventObject {
  userAddress: string;
  relayerAddress: string;
  payload: string;
}
export type MetaTransactionExecutedEvent = TypedEvent<
  [string, string, string],
  MetaTransactionExecutedEventObject
>;

export type MetaTransactionExecutedEventFilter =
  TypedEventFilter<MetaTransactionExecutedEvent>;

export interface MiningCycleResolverSetEventObject {
  miningCycleResolver: string;
}
export type MiningCycleResolverSetEvent = TypedEvent<
  [string],
  MiningCycleResolverSetEventObject
>;

export type MiningCycleResolverSetEventFilter =
  TypedEventFilter<MiningCycleResolverSetEvent>;

export interface NetworkFeeInverseSetEventObject {
  feeInverse: BigNumber;
}
export type NetworkFeeInverseSetEvent = TypedEvent<
  [BigNumber],
  NetworkFeeInverseSetEventObject
>;

export type NetworkFeeInverseSetEventFilter =
  TypedEventFilter<NetworkFeeInverseSetEvent>;

export interface RecoveryModeEnteredEventObject {
  user: string;
}
export type RecoveryModeEnteredEvent = TypedEvent<
  [string],
  RecoveryModeEnteredEventObject
>;

export type RecoveryModeEnteredEventFilter =
  TypedEventFilter<RecoveryModeEnteredEvent>;

export interface RecoveryModeExitApprovedEventObject {
  user: string;
}
export type RecoveryModeExitApprovedEvent = TypedEvent<
  [string],
  RecoveryModeExitApprovedEventObject
>;

export type RecoveryModeExitApprovedEventFilter =
  TypedEventFilter<RecoveryModeExitApprovedEvent>;

export interface RecoveryModeExitedEventObject {
  user: string;
}
export type RecoveryModeExitedEvent = TypedEvent<
  [string],
  RecoveryModeExitedEventObject
>;

export type RecoveryModeExitedEventFilter =
  TypedEventFilter<RecoveryModeExitedEvent>;

export interface RecoveryRoleSetEventObject {
  user: string;
  setTo: boolean;
}
export type RecoveryRoleSetEvent = TypedEvent<
  [string, boolean],
  RecoveryRoleSetEventObject
>;

export type RecoveryRoleSetEventFilter = TypedEventFilter<RecoveryRoleSetEvent>;

export interface RecoveryStorageSlotSetEventObject {
  user: string;
  slot: BigNumber;
  fromValue: string;
  toValue: string;
}
export type RecoveryStorageSlotSetEvent = TypedEvent<
  [string, BigNumber, string, string],
  RecoveryStorageSlotSetEventObject
>;

export type RecoveryStorageSlotSetEventFilter =
  TypedEventFilter<RecoveryStorageSlotSetEvent>;

export interface RegistrarInitialisedEventObject {
  ens: string;
  rootNode: string;
}
export type RegistrarInitialisedEvent = TypedEvent<
  [string, string],
  RegistrarInitialisedEventObject
>;

export type RegistrarInitialisedEventFilter =
  TypedEventFilter<RegistrarInitialisedEvent>;

export interface ReputationMinerPenalisedEventObject {
  miner: string;
  tokensLost: BigNumber;
}
export type ReputationMinerPenalisedEvent = TypedEvent<
  [string, BigNumber],
  ReputationMinerPenalisedEventObject
>;

export type ReputationMinerPenalisedEventFilter =
  TypedEventFilter<ReputationMinerPenalisedEvent>;

export interface ReputationMiningCycleCompleteEventObject {
  hash: string;
  nLeaves: BigNumber;
}
export type ReputationMiningCycleCompleteEvent = TypedEvent<
  [string, BigNumber],
  ReputationMiningCycleCompleteEventObject
>;

export type ReputationMiningCycleCompleteEventFilter =
  TypedEventFilter<ReputationMiningCycleCompleteEvent>;

export interface ReputationMiningInitialisedEventObject {
  inactiveReputationMiningCycle: string;
}
export type ReputationMiningInitialisedEvent = TypedEvent<
  [string],
  ReputationMiningInitialisedEventObject
>;

export type ReputationMiningInitialisedEventFilter =
  TypedEventFilter<ReputationMiningInitialisedEvent>;

export interface ReputationMiningRewardSetEventObject {
  amount: BigNumber;
}
export type ReputationMiningRewardSetEvent = TypedEvent<
  [BigNumber],
  ReputationMiningRewardSetEventObject
>;

export type ReputationMiningRewardSetEventFilter =
  TypedEventFilter<ReputationMiningRewardSetEvent>;

export interface ReputationRootHashSetEventObject {
  newHash: string;
  newNLeaves: BigNumber;
  stakers: string[];
  reward: BigNumber;
}
export type ReputationRootHashSetEvent = TypedEvent<
  [string, BigNumber, string[], BigNumber],
  ReputationRootHashSetEventObject
>;

export type ReputationRootHashSetEventFilter =
  TypedEventFilter<ReputationRootHashSetEvent>;

export interface SkillAddedEventObject {
  skillId: BigNumber;
  parentSkillId: BigNumber;
}
export type SkillAddedEvent = TypedEvent<
  [BigNumber, BigNumber],
  SkillAddedEventObject
>;

export type SkillAddedEventFilter = TypedEventFilter<SkillAddedEvent>;

export interface TokenAuthorityDeployedEventObject {
  tokenAuthorityAddress: string;
}
export type TokenAuthorityDeployedEvent = TypedEvent<
  [string],
  TokenAuthorityDeployedEventObject
>;

export type TokenAuthorityDeployedEventFilter =
  TypedEventFilter<TokenAuthorityDeployedEvent>;

export interface TokenDeployedEventObject {
  tokenAddress: string;
}
export type TokenDeployedEvent = TypedEvent<[string], TokenDeployedEventObject>;

export type TokenDeployedEventFilter = TypedEventFilter<TokenDeployedEvent>;

export interface TokenLockingAddressSetEventObject {
  tokenLocking: string;
}
export type TokenLockingAddressSetEvent = TypedEvent<
  [string],
  TokenLockingAddressSetEventObject
>;

export type TokenLockingAddressSetEventFilter =
  TypedEventFilter<TokenLockingAddressSetEvent>;

export interface TokenWhitelistedEventObject {
  token: string;
  status: boolean;
}
export type TokenWhitelistedEvent = TypedEvent<
  [string, boolean],
  TokenWhitelistedEventObject
>;

export type TokenWhitelistedEventFilter =
  TypedEventFilter<TokenWhitelistedEvent>;

export interface UserLabelRegisteredEventObject {
  user: string;
  label: string;
}
export type UserLabelRegisteredEvent = TypedEvent<
  [string, string],
  UserLabelRegisteredEventObject
>;

export type UserLabelRegisteredEventFilter =
  TypedEventFilter<UserLabelRegisteredEvent>;

export interface IColonyNetwork extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: IColonyNetworkInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[void]>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Executes a metatransaction targeting this contract
     * @param payload The transaction data that will be executed if signature valid
     * @param sigR The 'r' part of the signature
     * @param sigS The 's' part of the signature
     * @param sigV The 'v' part of the signature
     * @param userAddress The address of the user that signed the metatransaction
     */
    executeMetaTransaction(
      userAddress: string,
      payload: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Gets the next metatransaction nonce for user that should be used targeting this contract
     * @param userAddress The address of the user that will sign the metatransaction
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(
      overrides?: CallOverrides
    ): Promise<[boolean] & { inRecoveryMode: boolean }>;

    /**
     * The `msg.value` should not be trusted for any method callable from multicall.
     * Call multiple functions in the current contract and return the data from all of them if they all succeed
     * @param data The encoded function data for each of the calls to make to this contract
     */
    multicall(
      data: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { numRoles: BigNumber }>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Interface identification is specified in ERC-165.
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean] & { _status: boolean }>;

    /**
     * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
     * Set a replacement log entry if we're in recovery mode.
     * @param _amount The amount of reputation being earned / lost
     * @param _colony The address of the colony being updated
     * @param _id The number of the log entry in the reputation mining cycle in question.
     * @param _nPreviousUpdates The number of updates in the log before this entry
     * @param _nUpdates The number of updates the log entry corresponds to
     * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
     * @param _skillId The id of the origin skill for the reputation update
     * @param _user The address of the user earning / losing the reputation
     */
    setReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
     * @param _id The log entry number we wish to see if there is a replacement for
     * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
     */
    getReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [ColonyNetworkDataTypes.ReputationLogEntryStructOutput] & {
        _reputationLogEntry: ColonyNetworkDataTypes.ReputationLogEntryStructOutput;
      }
    >;

    /**
     * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
     * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
     */
    getReplacementReputationUpdateLogsExist(
      _reputationMiningCycle: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { _exists: boolean }>;

    /**
     * Get the Meta Colony address.
     */
    getMetaColony(
      overrides?: CallOverrides
    ): Promise<[string] & { _colonyAddress: string }>;

    /**
     * Get the number of colonies in the network.
     */
    getColonyCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _count: BigNumber }>;

    /**
     * Check if specific address is a colony created on colony network.
     * @param _colony Address of the colony
     */
    isColony(
      _colony: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { _addressIsColony: boolean }>;

    /**
     * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
     * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
     * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
     */
    addSkill(
      _parentSkillId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get the `nParents` and `nChildren` of skill with id `_skillId`.
     * @param _skillId Id of the skill
     */
    getSkill(
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [ColonyNetworkDataTypes.SkillStructOutput] & {
        _skill: ColonyNetworkDataTypes.SkillStructOutput;
      }
    >;

    /**
     * This function is deprecated and will be removed in a future release
     * Mark a skill as deprecated which stops new tasks and payments from using it.
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256)"(
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Set deprecation status for a skill
     * @param _deprecated Deprecation status
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256,bool)"(
      _skillId: BigNumberish,
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Initialise the local skills tree for a colony
     */
    initialiseRootLocalSkill(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
     * Adds a reputation update entry to log.
     * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
     * @param _skillId The skill for the reputation update
     * @param _user The address of the user for the reputation update
     */
    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get the number of skills in the network including both global and local skills.
     */
    getSkillCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _count: BigNumber }>;

    /**
     * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
     */
    getReputationMiningSkillId(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _skillId: BigNumber }>;

    /**
     * Sets the token locking address. This is only set once, and can't be changed afterwards.
     * @param _tokenLockingAddress Address of the locking contract
     */
    setTokenLocking(
      _tokenLockingAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get token locking contract address.
     */
    getTokenLocking(
      overrides?: CallOverrides
    ): Promise<[string] & { _lockingAddress: string }>;

    /**
     * Create the Meta Colony, same as a normal colony plus the root skill.
     * @param _tokenAddress Address of the CLNY token
     */
    createMetaColony(
      _tokenAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, at version 3
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
     */
    "createColony(address)"(
      _tokenAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _metadata The metadata associated with the new colony
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _orbitdb DEPRECATED Currently a no-op
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _useExtensionManager DEPRECATED Currently a no-op
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string,bool)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _orbitdb: string,
      _useExtensionManager: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * We expect this function to only be used by the dapp
     * Creates a new colony in the network, possibly with a token and token authority, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to (optional) In the case of ETH, and most tokens, this is 18.
     * @param _metadata The metadata associated with the new colony
     * @param _name The name of the token (optional)
     * @param _symbol The short 'ticket' symbol for the token (optional)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token (optional)
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    createColonyForFrontend(
      _tokenAddress: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
     * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
     * @param _version The new Colony contract version
     */
    addColonyVersion(
      _version: BigNumberish,
      _resolver: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Only allowed to be run once, by the Network owner before any Colony versions are added.
     * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
     * @param _resolver Address of the resolver for Colony contract
     * @param _version Version of the Colony contract the resolver represents
     */
    initialise(
      _resolver: string,
      _version: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get a colony address by its Id in the network.
     * @param _id Id of the colony to get
     */
    getColony(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { _colonyAddress: string }>;

    /**
     * Returns the latest Colony contract version. This is the version used to create all new colonies.
     */
    getCurrentColonyVersion(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _version: BigNumber }>;

    /**
     * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
     * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
     * @param _skillId Id of the skill
     */
    getParentSkillId(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _parentSkillId: BigNumber }>;

    /**
     * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
     * @param _childSkillIndex Index of the `skill.children` array to get
     * @param _skillId Id of the skill
     */
    getChildSkillId(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _childSkillId: BigNumber }>;

    /**
     * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
     * @param _active Whether the user wants the active or inactive reputation mining cycle
     */
    getReputationMiningCycle(
      _active: boolean,
      overrides?: CallOverrides
    ): Promise<[string] & { _repMiningCycleAddress: string }>;

    /**
     * Calculate raw miner weight in WADs.
     * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
     * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
     */
    calculateMinerWeight(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _minerWeight: BigNumber }>;

    /**
     * Get the `Resolver` address for Colony contract version `_version`.
     * @param _version The Colony contract version
     */
    getColonyVersionResolver(
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { _resolverAddress: string }>;

    /**
     * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
     * @param _newHash The reputation root hash
     * @param _newNLeaves The updated leaves count value
     * @param _stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    setReputationRootHash(
      _newHash: BytesLike,
      _newNLeaves: BigNumberish,
      _stakers: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
     */
    startNextCycle(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Creates initial inactive reputation mining cycle.
     */
    initialiseReputationMining(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get the root hash of the current reputation state tree.
     */
    getReputationRootHash(
      overrides?: CallOverrides
    ): Promise<[string] & { rootHash: string }>;

    /**
     * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNLeaves(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nLeaves: BigNumber }>;

    /**
     * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNNodes(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nNodes: BigNumber }>;

    /**
     * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
     * @param _token Address of the token held by the network to be auctioned
     */
    startTokenAuction(
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Setup registrar with ENS and root node.
     * @param _ens Address of ENS registrar
     * @param _rootNode Namehash of the root node for the domain
     */
    setupRegistrar(
      _ens: string,
      _rootNode: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Register a "user.joincolony.eth" label.
     * @param _orbitdb The path of the orbitDB database associated with the user profile
     * @param _username The label to register
     */
    registerUserLabel(
      _username: string,
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
     * @param _colonyName The label to register.
     * @param _orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      _colonyName: string,
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param _orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
     * @param _orbitdb The path of the orbitDB database to be associated with the user
     */
    updateUserOrbitDB(
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Retrieve the orbitdb address corresponding to a registered account.
     * @param _node The Namehash of the account being queried.
     */
    getProfileDBAddress(
      _node: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { _orbitdb: string }>;

    /**
     * Reverse lookup a username from an address.
     * @param _addr The address we wish to find the corresponding ENS domain for (if any)
     */
    lookupRegisteredENSDomain(
      _addr: string,
      overrides?: CallOverrides
    ): Promise<[string] & { _domain: string }>;

    /**
     * Returns the address the supplied node resolves do, if we are the resolver.
     * @param _node The namehash of the ENS address being requested
     */
    addr(
      _node: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string] & { _address: string }>;

    /**
     * Returns the address of the ENSRegistrar for the Network.
     */
    getENSRegistrar(
      overrides?: CallOverrides
    ): Promise<[string] & { _address: string }>;

    /**
     * Set the resolver to be used by new instances of ReputationMiningCycle.
     * @param _miningResolverAddress The address of the Resolver contract with the functions correctly wired.
     */
    setMiningResolver(
      _miningResolverAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get the resolver to be used by new instances of ReputationMiningCycle.
     */
    getMiningResolver(
      overrides?: CallOverrides
    ): Promise<[string] & { miningResolverAddress: string }>;

    /**
     * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
     * Add a new extension resolver to the Extensions repository.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _resolver The deployed resolver containing the extension contract logic
     */
    addExtensionToNetwork(
      _extensionId: BytesLike,
      _resolver: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Install an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _version Version of the extension to install
     */
    installExtension(
      _extensionId: BytesLike,
      _version: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Upgrade an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _newVersion Version of the extension to upgrade to (must be one greater than current)
     */
    upgradeExtension(
      _extensionId: BytesLike,
      _newVersion: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Set the deprecation of an extension in a colony. Can only be called by a Colony.
     * @param _deprecated Whether to deprecate the extension or not
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      _extensionId: BytesLike,
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Uninstall an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      _extensionId: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get an extension's resolver.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _version Version of the extension
     */
    getExtensionResolver(
      _extensionId: BytesLike,
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<[string] & { _resolver: string }>;

    /**
     * Get an extension's installation.
     * @param _colony Address of the colony the extension is installed in
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    getExtensionInstallation(
      _extensionId: BytesLike,
      _colony: string,
      overrides?: CallOverrides
    ): Promise<[string] & { _installation: string }>;

    /**
     * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getFeeInverse(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _feeInverse: BigNumber }>;

    /**
     * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
     * @param _feeInverse The inverse of the network fee to set
     */
    setFeeInverse(
      _feeInverse: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Get a token's status in the payout whitelist
     * @param _token The token being queried
     */
    getPayoutWhitelist(
      _token: string,
      overrides?: CallOverrides
    ): Promise<[boolean] & { _status: boolean }>;

    /**
     * Set a token's status in the payout whitelist
     * @param _status The whitelist status
     * @param _token The token being set
     */
    setPayoutWhitelist(
      _token: string,
      _status: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * While external, it can only be called successfully by the current ReputationMiningCycle.
     * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
     * @param _amount Amount of stake to slash
     * @param _stakers Array of the addresses of stakers to punish
     */
    punishStakers(
      _stakers: string[],
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Stake CLNY to allow the staker to participate in reputation mining.
     * @param _amount Amount of CLNY to stake for the purposes of mining
     */
    stakeForMining(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Unstake CLNY currently staked for reputation mining.
     * @param _amount Amount of CLNY staked for mining to unstake
     */
    unstakeForMining(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * returns how much CLNY _user has staked for the purposes of reputation mining
     * @param _user The user to query
     */
    getMiningStake(
      _user: string,
      overrides?: CallOverrides
    ): Promise<
      [ColonyNetworkDataTypes.MiningStakeStructOutput] & {
        _info: ColonyNetworkDataTypes.MiningStakeStructOutput;
      }
    >;

    /**
     * Only callable by the active reputation mining cycle
     * Used to track that a user is eligible to claim a reward
     * @param _amount The amount of CLNY to be awarded
     * @param _recipient The address receiving the award
     */
    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
     * @param _amount The amount of CLNY to burn
     */
    burnUnneededRewards(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Can be called by anyone, not just _recipient
     * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
     * @param _recipient The user whose rewards to claim
     */
    claimMiningReward(
      _recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the total per-cycle reputation reward, which will be split between all miners.
     * @param _amount The CLNY awarded per mining cycle to the miners
     */
    setReputationMiningCycleReward(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    getReputationMiningCycleReward(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _amount: BigNumber }>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token.
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
     * @param _name The name of the token
     * @param _symbol The short 'ticket' symbol for the token
     */
    deployTokenViaNetwork(
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token authority
     * @param _allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
     * @param _colony The address of the colony in control of the token
     * @param _token The address of the token
     */
    deployTokenAuthority(
      _token: string,
      _colony: string,
      _allowedToTransfer: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called to give or remove another address's permission to mine on your behalf
     * @param _allowed Whether they are allowed (true) or not (false) to mine on your behalf
     * @param _delegate The address you're giving or removing permission from
     */
    setMiningDelegate(
      _delegate: string,
      _allowed: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    /**
     * Called to get the address _delegate is allowed to mine for
     * @param _delegate The address that wants to mine
     */
    getMiningDelegator(
      _delegate: string,
      overrides?: CallOverrides
    ): Promise<[string] & { _delegator: string }>;
  };

  /**
   * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
   */
  approveExitRecovery(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
   * Check whether the supplied slot is a protected variable specific to this contract
   * @param _slot The storage slot number to check.
   */
  checkNotAdditionalProtectedVariable(
    _slot: BigNumberish,
    overrides?: CallOverrides
  ): Promise<void>;

  /**
   * Put colony network mining into recovery mode. Can only be called by user with recovery role.
   */
  enterRecoveryMode(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Executes a metatransaction targeting this contract
   * @param payload The transaction data that will be executed if signature valid
   * @param sigR The 'r' part of the signature
   * @param sigS The 's' part of the signature
   * @param sigV The 'v' part of the signature
   * @param userAddress The address of the user that signed the metatransaction
   */
  executeMetaTransaction(
    userAddress: string,
    payload: BytesLike,
    sigR: BytesLike,
    sigS: BytesLike,
    sigV: BigNumberish,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
   */
  exitRecoveryMode(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Gets the next metatransaction nonce for user that should be used targeting this contract
   * @param userAddress The address of the user that will sign the metatransaction
   */
  getMetatransactionNonce(
    userAddress: string,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Is colony network in recovery mode.
   */
  isInRecoveryMode(overrides?: CallOverrides): Promise<boolean>;

  /**
   * The `msg.value` should not be trusted for any method callable from multicall.
   * Call multiple functions in the current contract and return the data from all of them if they all succeed
   * @param data The encoded function data for each of the calls to make to this contract
   */
  multicall(
    data: BytesLike[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Return number of recovery roles.
   */
  numRecoveryRoles(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Remove colony recovery role. Can only be called by root role.
   * @param _user User we want to remove recovery role from
   */
  removeRecoveryRole(
    _user: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Set new colony recovery role. Can be called by root.
   * @param _user User we want to give a recovery role to
   */
  setRecoveryRole(
    _user: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * certain critical variables are protected from editing in this function
   * Update value of arbitrary storage variable. Can only be called by user with recovery role.
   * @param _slot Uint address of storage slot to be updated
   * @param _value word of data to be set
   */
  setStorageSlotRecovery(
    _slot: BigNumberish,
    _value: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Interface identification is specified in ERC-165.
   * Query if a contract implements an interface
   * @param _interfaceID The interface identifier, as specified in ERC-165
   */
  supportsInterface(
    _interfaceID: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
   * Set a replacement log entry if we're in recovery mode.
   * @param _amount The amount of reputation being earned / lost
   * @param _colony The address of the colony being updated
   * @param _id The number of the log entry in the reputation mining cycle in question.
   * @param _nPreviousUpdates The number of updates in the log before this entry
   * @param _nUpdates The number of updates the log entry corresponds to
   * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
   * @param _skillId The id of the origin skill for the reputation update
   * @param _user The address of the user earning / losing the reputation
   */
  setReplacementReputationUpdateLogEntry(
    _reputationMiningCycle: string,
    _id: BigNumberish,
    _user: string,
    _amount: BigNumberish,
    _skillId: BigNumberish,
    _colony: string,
    _nUpdates: BigNumberish,
    _nPreviousUpdates: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
   * @param _id The log entry number we wish to see if there is a replacement for
   * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
   */
  getReplacementReputationUpdateLogEntry(
    _reputationMiningCycle: string,
    _id: BigNumberish,
    overrides?: CallOverrides
  ): Promise<ColonyNetworkDataTypes.ReputationLogEntryStructOutput>;

  /**
   * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
   * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
   */
  getReplacementReputationUpdateLogsExist(
    _reputationMiningCycle: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Get the Meta Colony address.
   */
  getMetaColony(overrides?: CallOverrides): Promise<string>;

  /**
   * Get the number of colonies in the network.
   */
  getColonyCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Check if specific address is a colony created on colony network.
   * @param _colony Address of the colony
   */
  isColony(_colony: string, overrides?: CallOverrides): Promise<boolean>;

  /**
   * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
   * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
   * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
   */
  addSkill(
    _parentSkillId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get the `nParents` and `nChildren` of skill with id `_skillId`.
   * @param _skillId Id of the skill
   */
  getSkill(
    _skillId: BigNumberish,
    overrides?: CallOverrides
  ): Promise<ColonyNetworkDataTypes.SkillStructOutput>;

  /**
   * This function is deprecated and will be removed in a future release
   * Mark a skill as deprecated which stops new tasks and payments from using it.
   * @param _skillId Id of the skill
   */
  "deprecateSkill(uint256)"(
    _skillId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Set deprecation status for a skill
   * @param _deprecated Deprecation status
   * @param _skillId Id of the skill
   */
  "deprecateSkill(uint256,bool)"(
    _skillId: BigNumberish,
    _deprecated: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Initialise the local skills tree for a colony
   */
  initialiseRootLocalSkill(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
   * Adds a reputation update entry to log.
   * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
   * @param _skillId The skill for the reputation update
   * @param _user The address of the user for the reputation update
   */
  appendReputationUpdateLog(
    _user: string,
    _amount: BigNumberish,
    _skillId: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get the number of skills in the network including both global and local skills.
   */
  getSkillCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
   */
  getReputationMiningSkillId(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Sets the token locking address. This is only set once, and can't be changed afterwards.
   * @param _tokenLockingAddress Address of the locking contract
   */
  setTokenLocking(
    _tokenLockingAddress: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get token locking contract address.
   */
  getTokenLocking(overrides?: CallOverrides): Promise<string>;

  /**
   * Create the Meta Colony, same as a normal colony plus the root skill.
   * @param _tokenAddress Address of the CLNY token
   */
  createMetaColony(
    _tokenAddress: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
   * Creates a new colony in the network, at version 3
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
   */
  "createColony(address)"(
    _tokenAddress: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
   * Creates a new colony in the network, with an optional ENS name
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _metadata The metadata associated with the new colony
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  "createColony(address,uint256,string,string)"(
    _tokenAddress: string,
    _version: BigNumberish,
    _colonyName: string,
    _metadata: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * For the colony to mint tokens, token ownership must be transferred to the new colony
   * Creates a new colony in the network, with an optional ENS name
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  "createColony(address,uint256,string)"(
    _tokenAddress: string,
    _version: BigNumberish,
    _colonyName: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
   * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _orbitdb DEPRECATED Currently a no-op
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token
   * @param _useExtensionManager DEPRECATED Currently a no-op
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  "createColony(address,uint256,string,string,bool)"(
    _tokenAddress: string,
    _version: BigNumberish,
    _colonyName: string,
    _orbitdb: string,
    _useExtensionManager: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * We expect this function to only be used by the dapp
   * Creates a new colony in the network, possibly with a token and token authority, with an optional ENS name
   * @param _colonyName The label to register (if null, no label is registered)
   * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to (optional) In the case of ETH, and most tokens, this is 18.
   * @param _metadata The metadata associated with the new colony
   * @param _name The name of the token (optional)
   * @param _symbol The short 'ticket' symbol for the token (optional)
   * @param _tokenAddress Address of an ERC20 token to serve as the colony token (optional)
   * @param _version The version of colony to deploy (pass 0 for the current version)
   */
  createColonyForFrontend(
    _tokenAddress: string,
    _name: string,
    _symbol: string,
    _decimals: BigNumberish,
    _version: BigNumberish,
    _colonyName: string,
    _metadata: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
   * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
   * @param _version The new Colony contract version
   */
  addColonyVersion(
    _version: BigNumberish,
    _resolver: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Only allowed to be run once, by the Network owner before any Colony versions are added.
   * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
   * @param _resolver Address of the resolver for Colony contract
   * @param _version Version of the Colony contract the resolver represents
   */
  initialise(
    _resolver: string,
    _version: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get a colony address by its Id in the network.
   * @param _id Id of the colony to get
   */
  getColony(_id: BigNumberish, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the latest Colony contract version. This is the version used to create all new colonies.
   */
  getCurrentColonyVersion(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
   * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
   * @param _skillId Id of the skill
   */
  getParentSkillId(
    _skillId: BigNumberish,
    _parentSkillIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
   * @param _childSkillIndex Index of the `skill.children` array to get
   * @param _skillId Id of the skill
   */
  getChildSkillId(
    _skillId: BigNumberish,
    _childSkillIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
   * @param _active Whether the user wants the active or inactive reputation mining cycle
   */
  getReputationMiningCycle(
    _active: boolean,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Calculate raw miner weight in WADs.
   * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
   * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
   */
  calculateMinerWeight(
    _timeStaked: BigNumberish,
    _submissonIndex: BigNumberish,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Get the `Resolver` address for Colony contract version `_version`.
   * @param _version The Colony contract version
   */
  getColonyVersionResolver(
    _version: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
   * @param _newHash The reputation root hash
   * @param _newNLeaves The updated leaves count value
   * @param _stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
   */
  setReputationRootHash(
    _newHash: BytesLike,
    _newNLeaves: BigNumberish,
    _stakers: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
   */
  startNextCycle(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Creates initial inactive reputation mining cycle.
   */
  initialiseReputationMining(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get the root hash of the current reputation state tree.
   */
  getReputationRootHash(overrides?: CallOverrides): Promise<string>;

  /**
   * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
   * Get the number of leaves in the current reputation state tree.
   */
  getReputationRootHashNLeaves(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
   * Get the number of leaves in the current reputation state tree.
   */
  getReputationRootHashNNodes(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
   * @param _token Address of the token held by the network to be auctioned
   */
  startTokenAuction(
    _token: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Setup registrar with ENS and root node.
   * @param _ens Address of ENS registrar
   * @param _rootNode Namehash of the root node for the domain
   */
  setupRegistrar(
    _ens: string,
    _rootNode: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Register a "user.joincolony.eth" label.
   * @param _orbitdb The path of the orbitDB database associated with the user profile
   * @param _username The label to register
   */
  registerUserLabel(
    _username: string,
    _orbitdb: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
   * @param _colonyName The label to register.
   * @param _orbitdb The path of the orbitDB database associated with the colony name
   */
  registerColonyLabel(
    _colonyName: string,
    _orbitdb: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
   * @param _orbitdb The path of the orbitDB database to be associated with the colony
   */
  updateColonyOrbitDB(
    _orbitdb: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
   * @param _orbitdb The path of the orbitDB database to be associated with the user
   */
  updateUserOrbitDB(
    _orbitdb: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Retrieve the orbitdb address corresponding to a registered account.
   * @param _node The Namehash of the account being queried.
   */
  getProfileDBAddress(
    _node: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Reverse lookup a username from an address.
   * @param _addr The address we wish to find the corresponding ENS domain for (if any)
   */
  lookupRegisteredENSDomain(
    _addr: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Returns the address the supplied node resolves do, if we are the resolver.
   * @param _node The namehash of the ENS address being requested
   */
  addr(_node: BytesLike, overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the address of the ENSRegistrar for the Network.
   */
  getENSRegistrar(overrides?: CallOverrides): Promise<string>;

  /**
   * Set the resolver to be used by new instances of ReputationMiningCycle.
   * @param _miningResolverAddress The address of the Resolver contract with the functions correctly wired.
   */
  setMiningResolver(
    _miningResolverAddress: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get the resolver to be used by new instances of ReputationMiningCycle.
   */
  getMiningResolver(overrides?: CallOverrides): Promise<string>;

  /**
   * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
   * Add a new extension resolver to the Extensions repository.
   * @param _extensionId keccak256 hash of the extension name, used as an indentifier
   * @param _resolver The deployed resolver containing the extension contract logic
   */
  addExtensionToNetwork(
    _extensionId: BytesLike,
    _resolver: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Install an extension in a colony. Can only be called by a Colony.
   * @param _extensionId keccak256 hash of the extension name, used as an indentifier
   * @param _version Version of the extension to install
   */
  installExtension(
    _extensionId: BytesLike,
    _version: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Upgrade an extension in a colony. Can only be called by a Colony.
   * @param _extensionId keccak256 hash of the extension name, used as an indentifier
   * @param _newVersion Version of the extension to upgrade to (must be one greater than current)
   */
  upgradeExtension(
    _extensionId: BytesLike,
    _newVersion: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Set the deprecation of an extension in a colony. Can only be called by a Colony.
   * @param _deprecated Whether to deprecate the extension or not
   * @param _extensionId keccak256 hash of the extension name, used as an indentifier
   */
  deprecateExtension(
    _extensionId: BytesLike,
    _deprecated: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Uninstall an extension in a colony. Can only be called by a Colony.
   * @param _extensionId keccak256 hash of the extension name, used as an indentifier
   */
  uninstallExtension(
    _extensionId: BytesLike,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get an extension's resolver.
   * @param _extensionId keccak256 hash of the extension name, used as an indentifier
   * @param _version Version of the extension
   */
  getExtensionResolver(
    _extensionId: BytesLike,
    _version: BigNumberish,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Get an extension's installation.
   * @param _colony Address of the colony the extension is installed in
   * @param _extensionId keccak256 hash of the extension name, used as an indentifier
   */
  getExtensionInstallation(
    _extensionId: BytesLike,
    _colony: string,
    overrides?: CallOverrides
  ): Promise<string>;

  /**
   * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
   */
  getFeeInverse(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
   * @param _feeInverse The inverse of the network fee to set
   */
  setFeeInverse(
    _feeInverse: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Get a token's status in the payout whitelist
   * @param _token The token being queried
   */
  getPayoutWhitelist(
    _token: string,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Set a token's status in the payout whitelist
   * @param _status The whitelist status
   * @param _token The token being set
   */
  setPayoutWhitelist(
    _token: string,
    _status: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * While external, it can only be called successfully by the current ReputationMiningCycle.
   * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
   * @param _amount Amount of stake to slash
   * @param _stakers Array of the addresses of stakers to punish
   */
  punishStakers(
    _stakers: string[],
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Stake CLNY to allow the staker to participate in reputation mining.
   * @param _amount Amount of CLNY to stake for the purposes of mining
   */
  stakeForMining(
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Unstake CLNY currently staked for reputation mining.
   * @param _amount Amount of CLNY staked for mining to unstake
   */
  unstakeForMining(
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * returns how much CLNY _user has staked for the purposes of reputation mining
   * @param _user The user to query
   */
  getMiningStake(
    _user: string,
    overrides?: CallOverrides
  ): Promise<ColonyNetworkDataTypes.MiningStakeStructOutput>;

  /**
   * Only callable by the active reputation mining cycle
   * Used to track that a user is eligible to claim a reward
   * @param _amount The amount of CLNY to be awarded
   * @param _recipient The address receiving the award
   */
  reward(
    _recipient: string,
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Only callable by the active reputation mining cycle
   * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
   * @param _amount The amount of CLNY to burn
   */
  burnUnneededRewards(
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Can be called by anyone, not just _recipient
   * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
   * @param _recipient The user whose rewards to claim
   */
  claimMiningReward(
    _recipient: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Can only be called by the MetaColony.
   * Called to set the total per-cycle reputation reward, which will be split between all miners.
   * @param _amount The CLNY awarded per mining cycle to the miners
   */
  setReputationMiningCycleReward(
    _amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called to get the total per-cycle reputation mining reward.
   */
  getReputationMiningCycleReward(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
   * Called to deploy a token.
   * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
   * @param _name The name of the token
   * @param _symbol The short 'ticket' symbol for the token
   */
  deployTokenViaNetwork(
    _name: string,
    _symbol: string,
    _decimals: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
   * Called to deploy a token authority
   * @param _allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
   * @param _colony The address of the colony in control of the token
   * @param _token The address of the token
   */
  deployTokenAuthority(
    _token: string,
    _colony: string,
    _allowedToTransfer: string[],
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called to give or remove another address's permission to mine on your behalf
   * @param _allowed Whether they are allowed (true) or not (false) to mine on your behalf
   * @param _delegate The address you're giving or removing permission from
   */
  setMiningDelegate(
    _delegate: string,
    _allowed: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  /**
   * Called to get the address _delegate is allowed to mine for
   * @param _delegate The address that wants to mine
   */
  getMiningDelegator(
    _delegate: string,
    overrides?: CallOverrides
  ): Promise<string>;

  callStatic: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(overrides?: CallOverrides): Promise<void>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(overrides?: CallOverrides): Promise<void>;

    /**
     * Executes a metatransaction targeting this contract
     * @param payload The transaction data that will be executed if signature valid
     * @param sigR The 'r' part of the signature
     * @param sigS The 's' part of the signature
     * @param sigV The 'v' part of the signature
     * @param userAddress The address of the user that signed the metatransaction
     */
    executeMetaTransaction(
      userAddress: string,
      payload: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(overrides?: CallOverrides): Promise<void>;

    /**
     * Gets the next metatransaction nonce for user that should be used targeting this contract
     * @param userAddress The address of the user that will sign the metatransaction
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(overrides?: CallOverrides): Promise<boolean>;

    /**
     * The `msg.value` should not be trusted for any method callable from multicall.
     * Call multiple functions in the current contract and return the data from all of them if they all succeed
     * @param data The encoded function data for each of the calls to make to this contract
     */
    multicall(data: BytesLike[], overrides?: CallOverrides): Promise<string[]>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(_user: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(_user: string, overrides?: CallOverrides): Promise<void>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Interface identification is specified in ERC-165.
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
     * Set a replacement log entry if we're in recovery mode.
     * @param _amount The amount of reputation being earned / lost
     * @param _colony The address of the colony being updated
     * @param _id The number of the log entry in the reputation mining cycle in question.
     * @param _nPreviousUpdates The number of updates in the log before this entry
     * @param _nUpdates The number of updates the log entry corresponds to
     * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
     * @param _skillId The id of the origin skill for the reputation update
     * @param _user The address of the user earning / losing the reputation
     */
    setReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
     * @param _id The log entry number we wish to see if there is a replacement for
     * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
     */
    getReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ColonyNetworkDataTypes.ReputationLogEntryStructOutput>;

    /**
     * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
     * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
     */
    getReplacementReputationUpdateLogsExist(
      _reputationMiningCycle: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Get the Meta Colony address.
     */
    getMetaColony(overrides?: CallOverrides): Promise<string>;

    /**
     * Get the number of colonies in the network.
     */
    getColonyCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Check if specific address is a colony created on colony network.
     * @param _colony Address of the colony
     */
    isColony(_colony: string, overrides?: CallOverrides): Promise<boolean>;

    /**
     * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
     * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
     * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
     */
    addSkill(
      _parentSkillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `nParents` and `nChildren` of skill with id `_skillId`.
     * @param _skillId Id of the skill
     */
    getSkill(
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<ColonyNetworkDataTypes.SkillStructOutput>;

    /**
     * This function is deprecated and will be removed in a future release
     * Mark a skill as deprecated which stops new tasks and payments from using it.
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256)"(
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set deprecation status for a skill
     * @param _deprecated Deprecation status
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256,bool)"(
      _skillId: BigNumberish,
      _deprecated: boolean,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Initialise the local skills tree for a colony
     */
    initialiseRootLocalSkill(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
     * Adds a reputation update entry to log.
     * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
     * @param _skillId The skill for the reputation update
     * @param _user The address of the user for the reputation update
     */
    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the number of skills in the network including both global and local skills.
     */
    getSkillCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
     */
    getReputationMiningSkillId(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Sets the token locking address. This is only set once, and can't be changed afterwards.
     * @param _tokenLockingAddress Address of the locking contract
     */
    setTokenLocking(
      _tokenLockingAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get token locking contract address.
     */
    getTokenLocking(overrides?: CallOverrides): Promise<string>;

    /**
     * Create the Meta Colony, same as a normal colony plus the root skill.
     * @param _tokenAddress Address of the CLNY token
     */
    createMetaColony(
      _tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, at version 3
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
     */
    "createColony(address)"(
      _tokenAddress: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _metadata The metadata associated with the new colony
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _orbitdb DEPRECATED Currently a no-op
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _useExtensionManager DEPRECATED Currently a no-op
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string,bool)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _orbitdb: string,
      _useExtensionManager: boolean,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * We expect this function to only be used by the dapp
     * Creates a new colony in the network, possibly with a token and token authority, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to (optional) In the case of ETH, and most tokens, this is 18.
     * @param _metadata The metadata associated with the new colony
     * @param _name The name of the token (optional)
     * @param _symbol The short 'ticket' symbol for the token (optional)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token (optional)
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    createColonyForFrontend(
      _tokenAddress: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: CallOverrides
    ): Promise<[string, string] & { token: string; colony: string }>;

    /**
     * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
     * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
     * @param _version The new Colony contract version
     */
    addColonyVersion(
      _version: BigNumberish,
      _resolver: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only allowed to be run once, by the Network owner before any Colony versions are added.
     * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
     * @param _resolver Address of the resolver for Colony contract
     * @param _version Version of the Colony contract the resolver represents
     */
    initialise(
      _resolver: string,
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get a colony address by its Id in the network.
     * @param _id Id of the colony to get
     */
    getColony(_id: BigNumberish, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the latest Colony contract version. This is the version used to create all new colonies.
     */
    getCurrentColonyVersion(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
     * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
     * @param _skillId Id of the skill
     */
    getParentSkillId(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
     * @param _childSkillIndex Index of the `skill.children` array to get
     * @param _skillId Id of the skill
     */
    getChildSkillId(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
     * @param _active Whether the user wants the active or inactive reputation mining cycle
     */
    getReputationMiningCycle(
      _active: boolean,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Calculate raw miner weight in WADs.
     * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
     * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
     */
    calculateMinerWeight(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `Resolver` address for Colony contract version `_version`.
     * @param _version The Colony contract version
     */
    getColonyVersionResolver(
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
     * @param _newHash The reputation root hash
     * @param _newNLeaves The updated leaves count value
     * @param _stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    setReputationRootHash(
      _newHash: BytesLike,
      _newNLeaves: BigNumberish,
      _stakers: string[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
     */
    startNextCycle(overrides?: CallOverrides): Promise<void>;

    /**
     * Creates initial inactive reputation mining cycle.
     */
    initialiseReputationMining(overrides?: CallOverrides): Promise<void>;

    /**
     * Get the root hash of the current reputation state tree.
     */
    getReputationRootHash(overrides?: CallOverrides): Promise<string>;

    /**
     * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNLeaves(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNNodes(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
     * @param _token Address of the token held by the network to be auctioned
     */
    startTokenAuction(_token: string, overrides?: CallOverrides): Promise<void>;

    /**
     * Setup registrar with ENS and root node.
     * @param _ens Address of ENS registrar
     * @param _rootNode Namehash of the root node for the domain
     */
    setupRegistrar(
      _ens: string,
      _rootNode: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Register a "user.joincolony.eth" label.
     * @param _orbitdb The path of the orbitDB database associated with the user profile
     * @param _username The label to register
     */
    registerUserLabel(
      _username: string,
      _orbitdb: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
     * @param _colonyName The label to register.
     * @param _orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      _colonyName: string,
      _orbitdb: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param _orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      _orbitdb: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
     * @param _orbitdb The path of the orbitDB database to be associated with the user
     */
    updateUserOrbitDB(
      _orbitdb: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Retrieve the orbitdb address corresponding to a registered account.
     * @param _node The Namehash of the account being queried.
     */
    getProfileDBAddress(
      _node: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Reverse lookup a username from an address.
     * @param _addr The address we wish to find the corresponding ENS domain for (if any)
     */
    lookupRegisteredENSDomain(
      _addr: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Returns the address the supplied node resolves do, if we are the resolver.
     * @param _node The namehash of the ENS address being requested
     */
    addr(_node: BytesLike, overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the address of the ENSRegistrar for the Network.
     */
    getENSRegistrar(overrides?: CallOverrides): Promise<string>;

    /**
     * Set the resolver to be used by new instances of ReputationMiningCycle.
     * @param _miningResolverAddress The address of the Resolver contract with the functions correctly wired.
     */
    setMiningResolver(
      _miningResolverAddress: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the resolver to be used by new instances of ReputationMiningCycle.
     */
    getMiningResolver(overrides?: CallOverrides): Promise<string>;

    /**
     * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
     * Add a new extension resolver to the Extensions repository.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _resolver The deployed resolver containing the extension contract logic
     */
    addExtensionToNetwork(
      _extensionId: BytesLike,
      _resolver: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Install an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _version Version of the extension to install
     */
    installExtension(
      _extensionId: BytesLike,
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Upgrade an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _newVersion Version of the extension to upgrade to (must be one greater than current)
     */
    upgradeExtension(
      _extensionId: BytesLike,
      _newVersion: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Set the deprecation of an extension in a colony. Can only be called by a Colony.
     * @param _deprecated Whether to deprecate the extension or not
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      _extensionId: BytesLike,
      _deprecated: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Uninstall an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      _extensionId: BytesLike,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get an extension's resolver.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _version Version of the extension
     */
    getExtensionResolver(
      _extensionId: BytesLike,
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Get an extension's installation.
     * @param _colony Address of the colony the extension is installed in
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    getExtensionInstallation(
      _extensionId: BytesLike,
      _colony: string,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getFeeInverse(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
     * @param _feeInverse The inverse of the network fee to set
     */
    setFeeInverse(
      _feeInverse: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get a token's status in the payout whitelist
     * @param _token The token being queried
     */
    getPayoutWhitelist(
      _token: string,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Set a token's status in the payout whitelist
     * @param _status The whitelist status
     * @param _token The token being set
     */
    setPayoutWhitelist(
      _token: string,
      _status: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * While external, it can only be called successfully by the current ReputationMiningCycle.
     * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
     * @param _amount Amount of stake to slash
     * @param _stakers Array of the addresses of stakers to punish
     */
    punishStakers(
      _stakers: string[],
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Stake CLNY to allow the staker to participate in reputation mining.
     * @param _amount Amount of CLNY to stake for the purposes of mining
     */
    stakeForMining(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Unstake CLNY currently staked for reputation mining.
     * @param _amount Amount of CLNY staked for mining to unstake
     */
    unstakeForMining(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * returns how much CLNY _user has staked for the purposes of reputation mining
     * @param _user The user to query
     */
    getMiningStake(
      _user: string,
      overrides?: CallOverrides
    ): Promise<ColonyNetworkDataTypes.MiningStakeStructOutput>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to track that a user is eligible to claim a reward
     * @param _amount The amount of CLNY to be awarded
     * @param _recipient The address receiving the award
     */
    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
     * @param _amount The amount of CLNY to burn
     */
    burnUnneededRewards(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Can be called by anyone, not just _recipient
     * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
     * @param _recipient The user whose rewards to claim
     */
    claimMiningReward(
      _recipient: string,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the total per-cycle reputation reward, which will be split between all miners.
     * @param _amount The CLNY awarded per mining cycle to the miners
     */
    setReputationMiningCycleReward(
      _amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    getReputationMiningCycleReward(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token.
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
     * @param _name The name of the token
     * @param _symbol The short 'ticket' symbol for the token
     */
    deployTokenViaNetwork(
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token authority
     * @param _allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
     * @param _colony The address of the colony in control of the token
     * @param _token The address of the token
     */
    deployTokenAuthority(
      _token: string,
      _colony: string,
      _allowedToTransfer: string[],
      overrides?: CallOverrides
    ): Promise<string>;

    /**
     * Called to give or remove another address's permission to mine on your behalf
     * @param _allowed Whether they are allowed (true) or not (false) to mine on your behalf
     * @param _delegate The address you're giving or removing permission from
     */
    setMiningDelegate(
      _delegate: string,
      _allowed: boolean,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Called to get the address _delegate is allowed to mine for
     * @param _delegate The address that wants to mine
     */
    getMiningDelegator(
      _delegate: string,
      overrides?: CallOverrides
    ): Promise<string>;
  };

  filters: {
    "AuctionCreated(address,address,uint256)"(
      auction?: null,
      token?: null,
      quantity?: null
    ): AuctionCreatedEventFilter;
    AuctionCreated(
      auction?: null,
      token?: null,
      quantity?: null
    ): AuctionCreatedEventFilter;

    "ColonyAdded(uint256,address,address)"(
      colonyId?: BigNumberish | null,
      colonyAddress?: string | null,
      token?: null
    ): ColonyAddedEventFilter;
    ColonyAdded(
      colonyId?: BigNumberish | null,
      colonyAddress?: string | null,
      token?: null
    ): ColonyAddedEventFilter;

    "ColonyLabelRegistered(address,bytes32)"(
      colony?: string | null,
      label?: null
    ): ColonyLabelRegisteredEventFilter;
    ColonyLabelRegistered(
      colony?: string | null,
      label?: null
    ): ColonyLabelRegisteredEventFilter;

    "ColonyNetworkInitialised(address)"(
      resolver?: null
    ): ColonyNetworkInitialisedEventFilter;
    ColonyNetworkInitialised(
      resolver?: null
    ): ColonyNetworkInitialisedEventFilter;

    "ColonyVersionAdded(uint256,address)"(
      version?: null,
      resolver?: null
    ): ColonyVersionAddedEventFilter;
    ColonyVersionAdded(
      version?: null,
      resolver?: null
    ): ColonyVersionAddedEventFilter;

    "ExtensionAddedToNetwork(bytes32,uint256)"(
      extensionId?: BytesLike | null,
      version?: null
    ): ExtensionAddedToNetworkEventFilter;
    ExtensionAddedToNetwork(
      extensionId?: BytesLike | null,
      version?: null
    ): ExtensionAddedToNetworkEventFilter;

    "ExtensionDeprecated(bytes32,address,bool)"(
      extensionId?: BytesLike | null,
      colony?: string | null,
      deprecated?: null
    ): ExtensionDeprecatedEventFilter;
    ExtensionDeprecated(
      extensionId?: BytesLike | null,
      colony?: string | null,
      deprecated?: null
    ): ExtensionDeprecatedEventFilter;

    "ExtensionInstalled(bytes32,address,uint256)"(
      extensionId?: BytesLike | null,
      colony?: string | null,
      version?: null
    ): ExtensionInstalledEventFilter;
    ExtensionInstalled(
      extensionId?: BytesLike | null,
      colony?: string | null,
      version?: null
    ): ExtensionInstalledEventFilter;

    "ExtensionUninstalled(bytes32,address)"(
      extensionId?: BytesLike | null,
      colony?: string | null
    ): ExtensionUninstalledEventFilter;
    ExtensionUninstalled(
      extensionId?: BytesLike | null,
      colony?: string | null
    ): ExtensionUninstalledEventFilter;

    "ExtensionUpgraded(bytes32,address,uint256)"(
      extensionId?: BytesLike | null,
      colony?: string | null,
      version?: null
    ): ExtensionUpgradedEventFilter;
    ExtensionUpgraded(
      extensionId?: BytesLike | null,
      colony?: string | null,
      version?: null
    ): ExtensionUpgradedEventFilter;

    "MetaColonyCreated(address,address,uint256)"(
      metaColony?: null,
      token?: null,
      rootSkillId?: null
    ): MetaColonyCreatedEventFilter;
    MetaColonyCreated(
      metaColony?: null,
      token?: null,
      rootSkillId?: null
    ): MetaColonyCreatedEventFilter;

    "MetaTransactionExecuted(address,address,bytes)"(
      userAddress?: null,
      relayerAddress?: null,
      payload?: null
    ): MetaTransactionExecutedEventFilter;
    MetaTransactionExecuted(
      userAddress?: null,
      relayerAddress?: null,
      payload?: null
    ): MetaTransactionExecutedEventFilter;

    "MiningCycleResolverSet(address)"(
      miningCycleResolver?: null
    ): MiningCycleResolverSetEventFilter;
    MiningCycleResolverSet(
      miningCycleResolver?: null
    ): MiningCycleResolverSetEventFilter;

    "NetworkFeeInverseSet(uint256)"(
      feeInverse?: null
    ): NetworkFeeInverseSetEventFilter;
    NetworkFeeInverseSet(feeInverse?: null): NetworkFeeInverseSetEventFilter;

    "RecoveryModeEntered(address)"(user?: null): RecoveryModeEnteredEventFilter;
    RecoveryModeEntered(user?: null): RecoveryModeEnteredEventFilter;

    "RecoveryModeExitApproved(address)"(
      user?: null
    ): RecoveryModeExitApprovedEventFilter;
    RecoveryModeExitApproved(user?: null): RecoveryModeExitApprovedEventFilter;

    "RecoveryModeExited(address)"(user?: null): RecoveryModeExitedEventFilter;
    RecoveryModeExited(user?: null): RecoveryModeExitedEventFilter;

    "RecoveryRoleSet(address,bool)"(
      user?: string | null,
      setTo?: null
    ): RecoveryRoleSetEventFilter;
    RecoveryRoleSet(
      user?: string | null,
      setTo?: null
    ): RecoveryRoleSetEventFilter;

    "RecoveryStorageSlotSet(address,uint256,bytes32,bytes32)"(
      user?: null,
      slot?: null,
      fromValue?: null,
      toValue?: null
    ): RecoveryStorageSlotSetEventFilter;
    RecoveryStorageSlotSet(
      user?: null,
      slot?: null,
      fromValue?: null,
      toValue?: null
    ): RecoveryStorageSlotSetEventFilter;

    "RegistrarInitialised(address,bytes32)"(
      ens?: null,
      rootNode?: null
    ): RegistrarInitialisedEventFilter;
    RegistrarInitialised(
      ens?: null,
      rootNode?: null
    ): RegistrarInitialisedEventFilter;

    "ReputationMinerPenalised(address,uint256)"(
      miner?: null,
      tokensLost?: null
    ): ReputationMinerPenalisedEventFilter;
    ReputationMinerPenalised(
      miner?: null,
      tokensLost?: null
    ): ReputationMinerPenalisedEventFilter;

    "ReputationMiningCycleComplete(bytes32,uint256)"(
      hash?: null,
      nLeaves?: null
    ): ReputationMiningCycleCompleteEventFilter;
    ReputationMiningCycleComplete(
      hash?: null,
      nLeaves?: null
    ): ReputationMiningCycleCompleteEventFilter;

    "ReputationMiningInitialised(address)"(
      inactiveReputationMiningCycle?: null
    ): ReputationMiningInitialisedEventFilter;
    ReputationMiningInitialised(
      inactiveReputationMiningCycle?: null
    ): ReputationMiningInitialisedEventFilter;

    "ReputationMiningRewardSet(uint256)"(
      amount?: null
    ): ReputationMiningRewardSetEventFilter;
    ReputationMiningRewardSet(
      amount?: null
    ): ReputationMiningRewardSetEventFilter;

    "ReputationRootHashSet(bytes32,uint256,address[],uint256)"(
      newHash?: null,
      newNLeaves?: null,
      stakers?: null,
      reward?: null
    ): ReputationRootHashSetEventFilter;
    ReputationRootHashSet(
      newHash?: null,
      newNLeaves?: null,
      stakers?: null,
      reward?: null
    ): ReputationRootHashSetEventFilter;

    "SkillAdded(uint256,uint256)"(
      skillId?: null,
      parentSkillId?: null
    ): SkillAddedEventFilter;
    SkillAdded(skillId?: null, parentSkillId?: null): SkillAddedEventFilter;

    "TokenAuthorityDeployed(address)"(
      tokenAuthorityAddress?: null
    ): TokenAuthorityDeployedEventFilter;
    TokenAuthorityDeployed(
      tokenAuthorityAddress?: null
    ): TokenAuthorityDeployedEventFilter;

    "TokenDeployed(address)"(tokenAddress?: null): TokenDeployedEventFilter;
    TokenDeployed(tokenAddress?: null): TokenDeployedEventFilter;

    "TokenLockingAddressSet(address)"(
      tokenLocking?: null
    ): TokenLockingAddressSetEventFilter;
    TokenLockingAddressSet(
      tokenLocking?: null
    ): TokenLockingAddressSetEventFilter;

    "TokenWhitelisted(address,bool)"(
      token?: null,
      status?: null
    ): TokenWhitelistedEventFilter;
    TokenWhitelisted(token?: null, status?: null): TokenWhitelistedEventFilter;

    "UserLabelRegistered(address,bytes32)"(
      user?: string | null,
      label?: null
    ): UserLabelRegisteredEventFilter;
    UserLabelRegistered(
      user?: string | null,
      label?: null
    ): UserLabelRegisteredEventFilter;
  };

  estimateGas: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Executes a metatransaction targeting this contract
     * @param payload The transaction data that will be executed if signature valid
     * @param sigR The 'r' part of the signature
     * @param sigS The 's' part of the signature
     * @param sigV The 'v' part of the signature
     * @param userAddress The address of the user that signed the metatransaction
     */
    executeMetaTransaction(
      userAddress: string,
      payload: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Gets the next metatransaction nonce for user that should be used targeting this contract
     * @param userAddress The address of the user that will sign the metatransaction
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * The `msg.value` should not be trusted for any method callable from multicall.
     * Call multiple functions in the current contract and return the data from all of them if they all succeed
     * @param data The encoded function data for each of the calls to make to this contract
     */
    multicall(
      data: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Interface identification is specified in ERC-165.
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
     * Set a replacement log entry if we're in recovery mode.
     * @param _amount The amount of reputation being earned / lost
     * @param _colony The address of the colony being updated
     * @param _id The number of the log entry in the reputation mining cycle in question.
     * @param _nPreviousUpdates The number of updates in the log before this entry
     * @param _nUpdates The number of updates the log entry corresponds to
     * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
     * @param _skillId The id of the origin skill for the reputation update
     * @param _user The address of the user earning / losing the reputation
     */
    setReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
     * @param _id The log entry number we wish to see if there is a replacement for
     * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
     */
    getReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
     * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
     */
    getReplacementReputationUpdateLogsExist(
      _reputationMiningCycle: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the Meta Colony address.
     */
    getMetaColony(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the number of colonies in the network.
     */
    getColonyCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Check if specific address is a colony created on colony network.
     * @param _colony Address of the colony
     */
    isColony(_colony: string, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
     * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
     * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
     */
    addSkill(
      _parentSkillId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get the `nParents` and `nChildren` of skill with id `_skillId`.
     * @param _skillId Id of the skill
     */
    getSkill(
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This function is deprecated and will be removed in a future release
     * Mark a skill as deprecated which stops new tasks and payments from using it.
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256)"(
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Set deprecation status for a skill
     * @param _deprecated Deprecation status
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256,bool)"(
      _skillId: BigNumberish,
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Initialise the local skills tree for a colony
     */
    initialiseRootLocalSkill(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
     * Adds a reputation update entry to log.
     * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
     * @param _skillId The skill for the reputation update
     * @param _user The address of the user for the reputation update
     */
    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get the number of skills in the network including both global and local skills.
     */
    getSkillCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
     */
    getReputationMiningSkillId(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Sets the token locking address. This is only set once, and can't be changed afterwards.
     * @param _tokenLockingAddress Address of the locking contract
     */
    setTokenLocking(
      _tokenLockingAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get token locking contract address.
     */
    getTokenLocking(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Create the Meta Colony, same as a normal colony plus the root skill.
     * @param _tokenAddress Address of the CLNY token
     */
    createMetaColony(
      _tokenAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, at version 3
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
     */
    "createColony(address)"(
      _tokenAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _metadata The metadata associated with the new colony
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _orbitdb DEPRECATED Currently a no-op
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _useExtensionManager DEPRECATED Currently a no-op
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string,bool)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _orbitdb: string,
      _useExtensionManager: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * We expect this function to only be used by the dapp
     * Creates a new colony in the network, possibly with a token and token authority, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to (optional) In the case of ETH, and most tokens, this is 18.
     * @param _metadata The metadata associated with the new colony
     * @param _name The name of the token (optional)
     * @param _symbol The short 'ticket' symbol for the token (optional)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token (optional)
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    createColonyForFrontend(
      _tokenAddress: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
     * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
     * @param _version The new Colony contract version
     */
    addColonyVersion(
      _version: BigNumberish,
      _resolver: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Only allowed to be run once, by the Network owner before any Colony versions are added.
     * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
     * @param _resolver Address of the resolver for Colony contract
     * @param _version Version of the Colony contract the resolver represents
     */
    initialise(
      _resolver: string,
      _version: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get a colony address by its Id in the network.
     * @param _id Id of the colony to get
     */
    getColony(_id: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the latest Colony contract version. This is the version used to create all new colonies.
     */
    getCurrentColonyVersion(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
     * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
     * @param _skillId Id of the skill
     */
    getParentSkillId(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
     * @param _childSkillIndex Index of the `skill.children` array to get
     * @param _skillId Id of the skill
     */
    getChildSkillId(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
     * @param _active Whether the user wants the active or inactive reputation mining cycle
     */
    getReputationMiningCycle(
      _active: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Calculate raw miner weight in WADs.
     * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
     * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
     */
    calculateMinerWeight(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get the `Resolver` address for Colony contract version `_version`.
     * @param _version The Colony contract version
     */
    getColonyVersionResolver(
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
     * @param _newHash The reputation root hash
     * @param _newNLeaves The updated leaves count value
     * @param _stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    setReputationRootHash(
      _newHash: BytesLike,
      _newNLeaves: BigNumberish,
      _stakers: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
     */
    startNextCycle(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Creates initial inactive reputation mining cycle.
     */
    initialiseReputationMining(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get the root hash of the current reputation state tree.
     */
    getReputationRootHash(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNLeaves(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNNodes(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
     * @param _token Address of the token held by the network to be auctioned
     */
    startTokenAuction(
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Setup registrar with ENS and root node.
     * @param _ens Address of ENS registrar
     * @param _rootNode Namehash of the root node for the domain
     */
    setupRegistrar(
      _ens: string,
      _rootNode: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Register a "user.joincolony.eth" label.
     * @param _orbitdb The path of the orbitDB database associated with the user profile
     * @param _username The label to register
     */
    registerUserLabel(
      _username: string,
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
     * @param _colonyName The label to register.
     * @param _orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      _colonyName: string,
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param _orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
     * @param _orbitdb The path of the orbitDB database to be associated with the user
     */
    updateUserOrbitDB(
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Retrieve the orbitdb address corresponding to a registered account.
     * @param _node The Namehash of the account being queried.
     */
    getProfileDBAddress(
      _node: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Reverse lookup a username from an address.
     * @param _addr The address we wish to find the corresponding ENS domain for (if any)
     */
    lookupRegisteredENSDomain(
      _addr: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the address the supplied node resolves do, if we are the resolver.
     * @param _node The namehash of the ENS address being requested
     */
    addr(_node: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the address of the ENSRegistrar for the Network.
     */
    getENSRegistrar(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Set the resolver to be used by new instances of ReputationMiningCycle.
     * @param _miningResolverAddress The address of the Resolver contract with the functions correctly wired.
     */
    setMiningResolver(
      _miningResolverAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get the resolver to be used by new instances of ReputationMiningCycle.
     */
    getMiningResolver(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
     * Add a new extension resolver to the Extensions repository.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _resolver The deployed resolver containing the extension contract logic
     */
    addExtensionToNetwork(
      _extensionId: BytesLike,
      _resolver: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Install an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _version Version of the extension to install
     */
    installExtension(
      _extensionId: BytesLike,
      _version: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Upgrade an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _newVersion Version of the extension to upgrade to (must be one greater than current)
     */
    upgradeExtension(
      _extensionId: BytesLike,
      _newVersion: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Set the deprecation of an extension in a colony. Can only be called by a Colony.
     * @param _deprecated Whether to deprecate the extension or not
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      _extensionId: BytesLike,
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Uninstall an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      _extensionId: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get an extension's resolver.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _version Version of the extension
     */
    getExtensionResolver(
      _extensionId: BytesLike,
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Get an extension's installation.
     * @param _colony Address of the colony the extension is installed in
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    getExtensionInstallation(
      _extensionId: BytesLike,
      _colony: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getFeeInverse(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
     * @param _feeInverse The inverse of the network fee to set
     */
    setFeeInverse(
      _feeInverse: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Get a token's status in the payout whitelist
     * @param _token The token being queried
     */
    getPayoutWhitelist(
      _token: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Set a token's status in the payout whitelist
     * @param _status The whitelist status
     * @param _token The token being set
     */
    setPayoutWhitelist(
      _token: string,
      _status: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * While external, it can only be called successfully by the current ReputationMiningCycle.
     * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
     * @param _amount Amount of stake to slash
     * @param _stakers Array of the addresses of stakers to punish
     */
    punishStakers(
      _stakers: string[],
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Stake CLNY to allow the staker to participate in reputation mining.
     * @param _amount Amount of CLNY to stake for the purposes of mining
     */
    stakeForMining(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Unstake CLNY currently staked for reputation mining.
     * @param _amount Amount of CLNY staked for mining to unstake
     */
    unstakeForMining(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * returns how much CLNY _user has staked for the purposes of reputation mining
     * @param _user The user to query
     */
    getMiningStake(
      _user: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to track that a user is eligible to claim a reward
     * @param _amount The amount of CLNY to be awarded
     * @param _recipient The address receiving the award
     */
    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
     * @param _amount The amount of CLNY to burn
     */
    burnUnneededRewards(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Can be called by anyone, not just _recipient
     * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
     * @param _recipient The user whose rewards to claim
     */
    claimMiningReward(
      _recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the total per-cycle reputation reward, which will be split between all miners.
     * @param _amount The CLNY awarded per mining cycle to the miners
     */
    setReputationMiningCycleReward(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    getReputationMiningCycleReward(
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token.
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
     * @param _name The name of the token
     * @param _symbol The short 'ticket' symbol for the token
     */
    deployTokenViaNetwork(
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token authority
     * @param _allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
     * @param _colony The address of the colony in control of the token
     * @param _token The address of the token
     */
    deployTokenAuthority(
      _token: string,
      _colony: string,
      _allowedToTransfer: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called to give or remove another address's permission to mine on your behalf
     * @param _allowed Whether they are allowed (true) or not (false) to mine on your behalf
     * @param _delegate The address you're giving or removing permission from
     */
    setMiningDelegate(
      _delegate: string,
      _allowed: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    /**
     * Called to get the address _delegate is allowed to mine for
     * @param _delegate The address that wants to mine
     */
    getMiningDelegator(
      _delegate: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    /**
     * Indicate approval to exit recovery mode. Can only be called by user with recovery role.
     */
    approveExitRecovery(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * No return value, but should throw if protected.This is external, but is only expected to be called from ContractRecovery; no need toexpose this to any users.
     * Check whether the supplied slot is a protected variable specific to this contract
     * @param _slot The storage slot number to check.
     */
    checkNotAdditionalProtectedVariable(
      _slot: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Put colony network mining into recovery mode. Can only be called by user with recovery role.
     */
    enterRecoveryMode(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Executes a metatransaction targeting this contract
     * @param payload The transaction data that will be executed if signature valid
     * @param sigR The 'r' part of the signature
     * @param sigS The 's' part of the signature
     * @param sigV The 'v' part of the signature
     * @param userAddress The address of the user that signed the metatransaction
     */
    executeMetaTransaction(
      userAddress: string,
      payload: BytesLike,
      sigR: BytesLike,
      sigS: BytesLike,
      sigV: BigNumberish,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Exit recovery mode, can be called by anyone if enough whitelist approvals are given.
     */
    exitRecoveryMode(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the next metatransaction nonce for user that should be used targeting this contract
     * @param userAddress The address of the user that will sign the metatransaction
     */
    getMetatransactionNonce(
      userAddress: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Is colony network in recovery mode.
     */
    isInRecoveryMode(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * The `msg.value` should not be trusted for any method callable from multicall.
     * Call multiple functions in the current contract and return the data from all of them if they all succeed
     * @param data The encoded function data for each of the calls to make to this contract
     */
    multicall(
      data: BytesLike[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Return number of recovery roles.
     */
    numRecoveryRoles(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Remove colony recovery role. Can only be called by root role.
     * @param _user User we want to remove recovery role from
     */
    removeRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Set new colony recovery role. Can be called by root.
     * @param _user User we want to give a recovery role to
     */
    setRecoveryRole(
      _user: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * certain critical variables are protected from editing in this function
     * Update value of arbitrary storage variable. Can only be called by user with recovery role.
     * @param _slot Uint address of storage slot to be updated
     * @param _value word of data to be set
     */
    setStorageSlotRecovery(
      _slot: BigNumberish,
      _value: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Interface identification is specified in ERC-165.
     * Query if a contract implements an interface
     * @param _interfaceID The interface identifier, as specified in ERC-165
     */
    supportsInterface(
      _interfaceID: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Note that strictly, `_nUpdates` and `_nPreviousUpdates` don't need to be set - they're only used during dispute resolution, which these replacement log entries are never used for. However, for ease of resyncing the client, we have decided to include them for now.
     * Set a replacement log entry if we're in recovery mode.
     * @param _amount The amount of reputation being earned / lost
     * @param _colony The address of the colony being updated
     * @param _id The number of the log entry in the reputation mining cycle in question.
     * @param _nPreviousUpdates The number of updates in the log before this entry
     * @param _nUpdates The number of updates the log entry corresponds to
     * @param _reputationMiningCycle The address of the reputation mining cycle that the log was in.
     * @param _skillId The id of the origin skill for the reputation update
     * @param _user The address of the user earning / losing the reputation
     */
    setReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colony: string,
      _nUpdates: BigNumberish,
      _nPreviousUpdates: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get a replacement log entry (if set) for the log entry `_id` in the mining cycle that was at the address `_reputationMiningCycle`.
     * @param _id The log entry number we wish to see if there is a replacement for
     * @param _reputationMiningCycle The address of the reputation mining cycle we are asking about
     */
    getReplacementReputationUpdateLogEntry(
      _reputationMiningCycle: string,
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get whether any replacement log entries have been set for the supplied reputation mining cycle.Used by the client to avoid doubling the number of RPC calls when syncing from scratch.
     * @param _reputationMiningCycle The reputation mining cycle address we want to know if any entries have been replaced in.
     */
    getReplacementReputationUpdateLogsExist(
      _reputationMiningCycle: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the Meta Colony address.
     */
    getMetaColony(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the number of colonies in the network.
     */
    getColonyCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Check if specific address is a colony created on colony network.
     * @param _colony Address of the colony
     */
    isColony(
      _colony: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Errors if the parent skill does not exist or if this is called by an unauthorised sender.
     * Adds a new skill to the global or local skills tree, under skill `_parentSkillId`. Only the Meta Colony is allowed to add a global skill, called via `IColony.addGlobalSkill`. Any colony is allowed to add a local skill and which is associated with a new domain via `IColony.addDomain`.
     * @param _parentSkillId Id of the skill under which the new skill will be added. If 0, a global skill is added with no parent.
     */
    addSkill(
      _parentSkillId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the `nParents` and `nChildren` of skill with id `_skillId`.
     * @param _skillId Id of the skill
     */
    getSkill(
      _skillId: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This function is deprecated and will be removed in a future release
     * Mark a skill as deprecated which stops new tasks and payments from using it.
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256)"(
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Set deprecation status for a skill
     * @param _deprecated Deprecation status
     * @param _skillId Id of the skill
     */
    "deprecateSkill(uint256,bool)"(
      _skillId: BigNumberish,
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Initialise the local skills tree for a colony
     */
    initialiseRootLocalSkill(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Errors if it is called by anyone but a colony or if skill with id `_skillId` does not exist or.
     * Adds a reputation update entry to log.
     * @param _amount The amount of reputation change for the update, this can be a negative as well as a positive value
     * @param _skillId The skill for the reputation update
     * @param _user The address of the user for the reputation update
     */
    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the number of skills in the network including both global and local skills.
     */
    getSkillCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the `skillId` of the reputation mining skill. Only set once the metacolony is set up.
     */
    getReputationMiningSkillId(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Sets the token locking address. This is only set once, and can't be changed afterwards.
     * @param _tokenLockingAddress Address of the locking contract
     */
    setTokenLocking(
      _tokenLockingAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get token locking contract address.
     */
    getTokenLocking(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Create the Meta Colony, same as a normal colony plus the root skill.
     * @param _tokenAddress Address of the CLNY token
     */
    createMetaColony(
      _tokenAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, at version 3
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token.
     */
    "createColony(address)"(
      _tokenAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colonyWe expect this function to only be used by the dapp
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _metadata The metadata associated with the new colony
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * For the colony to mint tokens, token ownership must be transferred to the new colony
     * Creates a new colony in the network, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * This is now deprecated and will be removed in a future versionFor the colony to mint tokens, token ownership must be transferred to the new colony
     * Overload of the simpler `createColony` -- creates a new colony in the network with a variety of options, at version 4
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _orbitdb DEPRECATED Currently a no-op
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token
     * @param _useExtensionManager DEPRECATED Currently a no-op
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    "createColony(address,uint256,string,string,bool)"(
      _tokenAddress: string,
      _version: BigNumberish,
      _colonyName: string,
      _orbitdb: string,
      _useExtensionManager: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * We expect this function to only be used by the dapp
     * Creates a new colony in the network, possibly with a token and token authority, with an optional ENS name
     * @param _colonyName The label to register (if null, no label is registered)
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to (optional) In the case of ETH, and most tokens, this is 18.
     * @param _metadata The metadata associated with the new colony
     * @param _name The name of the token (optional)
     * @param _symbol The short 'ticket' symbol for the token (optional)
     * @param _tokenAddress Address of an ERC20 token to serve as the colony token (optional)
     * @param _version The version of colony to deploy (pass 0 for the current version)
     */
    createColonyForFrontend(
      _tokenAddress: string,
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      _version: BigNumberish,
      _colonyName: string,
      _metadata: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Adds a new Colony contract version and the address of associated `_resolver` contract. Secured function to authorised members. Allowed to be called by the Meta Colony only.
     * @param _resolver Address of the `Resolver` contract which will be used with the underlying `EtherRouter` contract
     * @param _version The new Colony contract version
     */
    addColonyVersion(
      _version: BigNumberish,
      _resolver: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Only allowed to be run once, by the Network owner before any Colony versions are added.
     * Initialises the colony network by setting the first Colony version resolver to `_resolver` address.
     * @param _resolver Address of the resolver for Colony contract
     * @param _version Version of the Colony contract the resolver represents
     */
    initialise(
      _resolver: string,
      _version: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get a colony address by its Id in the network.
     * @param _id Id of the colony to get
     */
    getColony(
      _id: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the latest Colony contract version. This is the version used to create all new colonies.
     */
    getCurrentColonyVersion(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the id of the parent skill at index `_parentSkillIndex` for skill with Id `_skillId`.
     * @param _parentSkillIndex Index of the `skill.parents` array to get Note that not all parent skill ids are stored here. See `Skill.parents` member for definition on which parents are stored
     * @param _skillId Id of the skill
     */
    getParentSkillId(
      _skillId: BigNumberish,
      _parentSkillIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the id of the child skill at index `_childSkillIndex` for skill with Id `_skillId`.
     * @param _childSkillIndex Index of the `skill.children` array to get
     * @param _skillId Id of the skill
     */
    getChildSkillId(
      _skillId: BigNumberish,
      _childSkillIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the address of either the active or inactive reputation mining cycle, based on `active`. The active reputation mining cycle is the one currently under consideration by reputation miners. The inactive reputation cycle is the one with the log that is being appended to.
     * @param _active Whether the user wants the active or inactive reputation mining cycle
     */
    getReputationMiningCycle(
      _active: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Calculate raw miner weight in WADs.
     * @param _submissonIndex Index of reputation hash submission (between 0 and 11)
     * @param _timeStaked Amount of time (in seconds) that the miner has staked their CLNY
     */
    calculateMinerWeight(
      _timeStaked: BigNumberish,
      _submissonIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get the `Resolver` address for Colony contract version `_version`.
     * @param _version The Colony contract version
     */
    getColonyVersionResolver(
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set a new Reputation root hash and starts a new mining cycle. Can only be called by the ReputationMiningCycle contract.
     * @param _newHash The reputation root hash
     * @param _newNLeaves The updated leaves count value
     * @param _stakers Array of users who submitted or backed the hash, being accepted here as the new reputation root hash
     */
    setReputationRootHash(
      _newHash: BytesLike,
      _newNLeaves: BigNumberish,
      _stakers: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Starts a new Reputation Mining cycle. Explicitly called only the first time, subsequently called from within `setReputationRootHash`.
     */
    startNextCycle(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Creates initial inactive reputation mining cycle.
     */
    initialiseReputationMining(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the root hash of the current reputation state tree.
     */
    getReputationRootHash(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * I cannot see a reason why a user's client would need to call this - only stored to help with some edge cases in reputation mining dispute resolution.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNLeaves(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Deprecated, replaced by getReputationRootHashNLeaves which does the same thing but is more accurately named.will be removed in a later version.
     * Get the number of leaves in the current reputation state tree.
     */
    getReputationRootHashNNodes(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Create and start a new `DutchAuction` for the entire amount of `_token` owned by the Colony Network.
     * @param _token Address of the token held by the network to be auctioned
     */
    startTokenAuction(
      _token: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Setup registrar with ENS and root node.
     * @param _ens Address of ENS registrar
     * @param _rootNode Namehash of the root node for the domain
     */
    setupRegistrar(
      _ens: string,
      _rootNode: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Register a "user.joincolony.eth" label.
     * @param _orbitdb The path of the orbitDB database associated with the user profile
     * @param _username The label to register
     */
    registerUserLabel(
      _username: string,
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Register a "colony.joincolony.eth" label. Can only be called by a Colony.
     * @param _colonyName The label to register.
     * @param _orbitdb The path of the orbitDB database associated with the colony name
     */
    registerColonyLabel(
      _colonyName: string,
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Update a colony's orbitdb address. Can only be called by a colony with a registered subdomain
     * @param _orbitdb The path of the orbitDB database to be associated with the colony
     */
    updateColonyOrbitDB(
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Update a user's orbitdb address. Can only be called by a user with a registered subdomain
     * @param _orbitdb The path of the orbitDB database to be associated with the user
     */
    updateUserOrbitDB(
      _orbitdb: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Retrieve the orbitdb address corresponding to a registered account.
     * @param _node The Namehash of the account being queried.
     */
    getProfileDBAddress(
      _node: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Reverse lookup a username from an address.
     * @param _addr The address we wish to find the corresponding ENS domain for (if any)
     */
    lookupRegisteredENSDomain(
      _addr: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address the supplied node resolves do, if we are the resolver.
     * @param _node The namehash of the ENS address being requested
     */
    addr(
      _node: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the address of the ENSRegistrar for the Network.
     */
    getENSRegistrar(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Set the resolver to be used by new instances of ReputationMiningCycle.
     * @param _miningResolverAddress The address of the Resolver contract with the functions correctly wired.
     */
    setMiningResolver(
      _miningResolverAddress: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the resolver to be used by new instances of ReputationMiningCycle.
     */
    getMiningResolver(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Can only be called by the MetaColony.The extension version is queried from the resolver itself.
     * Add a new extension resolver to the Extensions repository.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _resolver The deployed resolver containing the extension contract logic
     */
    addExtensionToNetwork(
      _extensionId: BytesLike,
      _resolver: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Install an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _version Version of the extension to install
     */
    installExtension(
      _extensionId: BytesLike,
      _version: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Upgrade an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _newVersion Version of the extension to upgrade to (must be one greater than current)
     */
    upgradeExtension(
      _extensionId: BytesLike,
      _newVersion: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Set the deprecation of an extension in a colony. Can only be called by a Colony.
     * @param _deprecated Whether to deprecate the extension or not
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    deprecateExtension(
      _extensionId: BytesLike,
      _deprecated: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Uninstall an extension in a colony. Can only be called by a Colony.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    uninstallExtension(
      _extensionId: BytesLike,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get an extension's resolver.
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     * @param _version Version of the extension
     */
    getExtensionResolver(
      _extensionId: BytesLike,
      _version: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Get an extension's installation.
     * @param _colony Address of the colony the extension is installed in
     * @param _extensionId keccak256 hash of the extension name, used as an indentifier
     */
    getExtensionInstallation(
      _extensionId: BytesLike,
      _colony: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Return 1 / the fee to pay to the network. e.g. if the fee is 1% (or 0.01), return 100.
     */
    getFeeInverse(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Set the colony network fee to pay. e.g. if the fee is 1% (or 0.01), pass 100 as `_feeInverse`.
     * @param _feeInverse The inverse of the network fee to set
     */
    setFeeInverse(
      _feeInverse: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Get a token's status in the payout whitelist
     * @param _token The token being queried
     */
    getPayoutWhitelist(
      _token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Set a token's status in the payout whitelist
     * @param _status The whitelist status
     * @param _token The token being set
     */
    setPayoutWhitelist(
      _token: string,
      _status: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * While external, it can only be called successfully by the current ReputationMiningCycle.
     * Function called to punish people who staked against a new reputation root hash that turned out to be incorrect.
     * @param _amount Amount of stake to slash
     * @param _stakers Array of the addresses of stakers to punish
     */
    punishStakers(
      _stakers: string[],
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Stake CLNY to allow the staker to participate in reputation mining.
     * @param _amount Amount of CLNY to stake for the purposes of mining
     */
    stakeForMining(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Unstake CLNY currently staked for reputation mining.
     * @param _amount Amount of CLNY staked for mining to unstake
     */
    unstakeForMining(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * returns how much CLNY _user has staked for the purposes of reputation mining
     * @param _user The user to query
     */
    getMiningStake(
      _user: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to track that a user is eligible to claim a reward
     * @param _amount The amount of CLNY to be awarded
     * @param _recipient The address receiving the award
     */
    reward(
      _recipient: string,
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Only callable by the active reputation mining cycle
     * Used to burn tokens that are not needed to pay out rewards (because not every possible defence was made for all submissions)
     * @param _amount The amount of CLNY to burn
     */
    burnUnneededRewards(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Can be called by anyone, not just _recipient
     * Used by a user to claim any mining rewards due to them. This will place them in their balance or pending balance, as appropriate.
     * @param _recipient The user whose rewards to claim
     */
    claimMiningReward(
      _recipient: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Can only be called by the MetaColony.
     * Called to set the total per-cycle reputation reward, which will be split between all miners.
     * @param _amount The CLNY awarded per mining cycle to the miners
     */
    setReputationMiningCycleReward(
      _amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called to get the total per-cycle reputation mining reward.
     */
    getReputationMiningCycleReward(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token.
     * @param _decimals The number of decimal places that 1 user-facing token can be divided up in to In the case of ETH, and most tokens, this is 18.
     * @param _name The name of the token
     * @param _symbol The short 'ticket' symbol for the token
     */
    deployTokenViaNetwork(
      _name: string,
      _symbol: string,
      _decimals: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * This is more expensive than deploying a token directly, but is able to be done via a metatransaction
     * Called to deploy a token authority
     * @param _allowedToTransfer An array of addresses that are allowed to transfer the token even if it's locked
     * @param _colony The address of the colony in control of the token
     * @param _token The address of the token
     */
    deployTokenAuthority(
      _token: string,
      _colony: string,
      _allowedToTransfer: string[],
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called to give or remove another address's permission to mine on your behalf
     * @param _allowed Whether they are allowed (true) or not (false) to mine on your behalf
     * @param _delegate The address you're giving or removing permission from
     */
    setMiningDelegate(
      _delegate: string,
      _allowed: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    /**
     * Called to get the address _delegate is allowed to mine for
     * @param _delegate The address that wants to mine
     */
    getMiningDelegator(
      _delegate: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
