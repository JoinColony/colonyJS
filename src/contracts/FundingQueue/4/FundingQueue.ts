/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from "./common";

export declare namespace FundingQueue {
  export type ProposalStruct = {
    state: PromiseOrValue<BigNumberish>;
    creator: PromiseOrValue<string>;
    token: PromiseOrValue<string>;
    domainId: PromiseOrValue<BigNumberish>;
    domainTotalRep: PromiseOrValue<BigNumberish>;
    fromPot: PromiseOrValue<BigNumberish>;
    toPot: PromiseOrValue<BigNumberish>;
    fromChildSkillIndex: PromiseOrValue<BigNumberish>;
    toChildSkillIndex: PromiseOrValue<BigNumberish>;
    totalRequested: PromiseOrValue<BigNumberish>;
    totalPaid: PromiseOrValue<BigNumberish>;
    lastUpdated: PromiseOrValue<BigNumberish>;
    totalSupport: PromiseOrValue<BigNumberish>;
  };

  export type ProposalStructOutput = [
    number,
    string,
    string,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    state: number;
    creator: string;
    token: string;
    domainId: BigNumber;
    domainTotalRep: BigNumber;
    fromPot: BigNumber;
    toPot: BigNumber;
    fromChildSkillIndex: BigNumber;
    toChildSkillIndex: BigNumber;
    totalRequested: BigNumber;
    totalPaid: BigNumber;
    lastUpdated: BigNumber;
    totalSupport: BigNumber;
  };
}

export interface FundingQueueInterface extends utils.Interface {
  functions: {
    "authority()": FunctionFragment;
    "executeMetaTransaction(address,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getCapabilityRoles(bytes4)": FunctionFragment;
    "getChainId()": FunctionFragment;
    "getColony()": FunctionFragment;
    "getDeprecated()": FunctionFragment;
    "multicall(bytes[])": FunctionFragment;
    "owner()": FunctionFragment;
    "setAuthority(address)": FunctionFragment;
    "setOwner(address)": FunctionFragment;
    "verify(address,uint256,uint256,bytes,bytes32,bytes32,uint8)": FunctionFragment;
    "getMetatransactionNonce(address)": FunctionFragment;
    "identifier()": FunctionFragment;
    "version()": FunctionFragment;
    "install(address)": FunctionFragment;
    "finishUpgrade()": FunctionFragment;
    "deprecate(bool)": FunctionFragment;
    "uninstall()": FunctionFragment;
    "createProposal(uint256,uint256,uint256,uint256,uint256,uint256,address)": FunctionFragment;
    "cancelProposal(uint256,uint256)": FunctionFragment;
    "stakeProposal(uint256,bytes,bytes,uint256,bytes32[])": FunctionFragment;
    "backProposal(uint256,uint256,uint256,uint256,bytes,bytes,uint256,bytes32[])": FunctionFragment;
    "pingProposal(uint256)": FunctionFragment;
    "reclaimStake(uint256)": FunctionFragment;
    "getProposalCount()": FunctionFragment;
    "getProposal(uint256)": FunctionFragment;
    "getSupport(uint256,address)": FunctionFragment;
    "getNextProposalId(uint256)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "authority"
      | "executeMetaTransaction"
      | "getCapabilityRoles"
      | "getChainId"
      | "getColony"
      | "getDeprecated"
      | "multicall"
      | "owner"
      | "setAuthority"
      | "setOwner"
      | "verify"
      | "getMetatransactionNonce"
      | "identifier"
      | "version"
      | "install"
      | "finishUpgrade"
      | "deprecate"
      | "uninstall"
      | "createProposal"
      | "cancelProposal"
      | "stakeProposal"
      | "backProposal"
      | "pingProposal"
      | "reclaimStake"
      | "getProposalCount"
      | "getProposal"
      | "getSupport"
      | "getNextProposalId"
  ): FunctionFragment;

  encodeFunctionData(functionFragment: "authority", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "executeMetaTransaction",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getCapabilityRoles",
    values: [PromiseOrValue<BytesLike>]
  ): string;
  encodeFunctionData(
    functionFragment: "getChainId",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "getColony", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "getDeprecated",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "multicall",
    values: [PromiseOrValue<BytesLike>[]]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "setAuthority",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "setOwner",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "verify",
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "getMetatransactionNonce",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "identifier",
    values?: undefined
  ): string;
  encodeFunctionData(functionFragment: "version", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "install",
    values: [PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "finishUpgrade",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deprecate",
    values: [PromiseOrValue<boolean>]
  ): string;
  encodeFunctionData(functionFragment: "uninstall", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "createProposal",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "cancelProposal",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "stakeProposal",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "backProposal",
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BytesLike>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>[]
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "pingProposal",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "reclaimStake",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getProposalCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "getProposal",
    values: [PromiseOrValue<BigNumberish>]
  ): string;
  encodeFunctionData(
    functionFragment: "getSupport",
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string;
  encodeFunctionData(
    functionFragment: "getNextProposalId",
    values: [PromiseOrValue<BigNumberish>]
  ): string;

  decodeFunctionResult(functionFragment: "authority", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "executeMetaTransaction",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getCapabilityRoles",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getChainId", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "getColony", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getDeprecated",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "multicall", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "setAuthority",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "verify", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getMetatransactionNonce",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "identifier", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "version", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "install", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "finishUpgrade",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "deprecate", data: BytesLike): Result;
  decodeFunctionResult(functionFragment: "uninstall", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "createProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "cancelProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "stakeProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "backProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "pingProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "reclaimStake",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposalCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getProposal",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "getSupport", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "getNextProposalId",
    data: BytesLike
  ): Result;

  events: {
    "ExtensionInitialised()": EventFragment;
    "LogSetAuthority(address)": EventFragment;
    "LogSetOwner(address)": EventFragment;
    "MetaTransactionExecuted(address,address,bytes)": EventFragment;
    "ProposalBacked(uint256,uint256,address,uint256,uint256)": EventFragment;
    "ProposalCancelled(uint256)": EventFragment;
    "ProposalCompleted(uint256)": EventFragment;
    "ProposalCreated(uint256,uint256,uint256,address,uint256)": EventFragment;
    "ProposalPinged(uint256,uint256)": EventFragment;
    "ProposalStakeReclaimed(uint256)": EventFragment;
    "ProposalStaked(uint256,uint256)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "ExtensionInitialised"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetAuthority"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LogSetOwner"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetaTransactionExecuted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalBacked"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCancelled"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCompleted"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalPinged"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalStakeReclaimed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "ProposalStaked"): EventFragment;
}

export interface ExtensionInitialisedEventObject {}
export type ExtensionInitialisedEvent = TypedEvent<
  [],
  ExtensionInitialisedEventObject
>;

export type ExtensionInitialisedEventFilter =
  TypedEventFilter<ExtensionInitialisedEvent>;

export interface LogSetAuthorityEventObject {
  authority: string;
}
export type LogSetAuthorityEvent = TypedEvent<
  [string],
  LogSetAuthorityEventObject
>;

export type LogSetAuthorityEventFilter = TypedEventFilter<LogSetAuthorityEvent>;

export interface LogSetOwnerEventObject {
  owner: string;
}
export type LogSetOwnerEvent = TypedEvent<[string], LogSetOwnerEventObject>;

export type LogSetOwnerEventFilter = TypedEventFilter<LogSetOwnerEvent>;

export interface MetaTransactionExecutedEventObject {
  user: string;
  relayerAddress: string;
  functionSignature: string;
}
export type MetaTransactionExecutedEvent = TypedEvent<
  [string, string, string],
  MetaTransactionExecutedEventObject
>;

export type MetaTransactionExecutedEventFilter =
  TypedEventFilter<MetaTransactionExecutedEvent>;

export interface ProposalBackedEventObject {
  id: BigNumber;
  newPrevId: BigNumber;
  user: string;
  backing: BigNumber;
  prevBacking: BigNumber;
}
export type ProposalBackedEvent = TypedEvent<
  [BigNumber, BigNumber, string, BigNumber, BigNumber],
  ProposalBackedEventObject
>;

export type ProposalBackedEventFilter = TypedEventFilter<ProposalBackedEvent>;

export interface ProposalCancelledEventObject {
  id: BigNumber;
}
export type ProposalCancelledEvent = TypedEvent<
  [BigNumber],
  ProposalCancelledEventObject
>;

export type ProposalCancelledEventFilter =
  TypedEventFilter<ProposalCancelledEvent>;

export interface ProposalCompletedEventObject {
  id: BigNumber;
}
export type ProposalCompletedEvent = TypedEvent<
  [BigNumber],
  ProposalCompletedEventObject
>;

export type ProposalCompletedEventFilter =
  TypedEventFilter<ProposalCompletedEvent>;

export interface ProposalCreatedEventObject {
  id: BigNumber;
  fromPot: BigNumber;
  toPot: BigNumber;
  token: string;
  amount: BigNumber;
}
export type ProposalCreatedEvent = TypedEvent<
  [BigNumber, BigNumber, BigNumber, string, BigNumber],
  ProposalCreatedEventObject
>;

export type ProposalCreatedEventFilter = TypedEventFilter<ProposalCreatedEvent>;

export interface ProposalPingedEventObject {
  id: BigNumber;
  amount: BigNumber;
}
export type ProposalPingedEvent = TypedEvent<
  [BigNumber, BigNumber],
  ProposalPingedEventObject
>;

export type ProposalPingedEventFilter = TypedEventFilter<ProposalPingedEvent>;

export interface ProposalStakeReclaimedEventObject {
  id: BigNumber;
}
export type ProposalStakeReclaimedEvent = TypedEvent<
  [BigNumber],
  ProposalStakeReclaimedEventObject
>;

export type ProposalStakeReclaimedEventFilter =
  TypedEventFilter<ProposalStakeReclaimedEvent>;

export interface ProposalStakedEventObject {
  id: BigNumber;
  domainTotalRep: BigNumber;
}
export type ProposalStakedEvent = TypedEvent<
  [BigNumber, BigNumber],
  ProposalStakedEventObject
>;

export type ProposalStakedEventFilter = TypedEventFilter<ProposalStakedEvent>;

export interface FundingQueue extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: FundingQueueInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    authority(overrides?: CallOverrides): Promise<[string]>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    getCapabilityRoles(
      _sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getChainId(overrides?: CallOverrides): Promise<[BigNumber]>;

    getColony(overrides?: CallOverrides): Promise<[string]>;

    getDeprecated(overrides?: CallOverrides): Promise<[boolean]>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param userAddress The user's address
     */
    getMetatransactionNonce(
      userAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nonce: BigNumber }>;

    /**
     * Returns the identifier of the extension
     */
    identifier(
      overrides?: CallOverrides
    ): Promise<[string] & { _identifier: string }>;

    /**
     * Returns the version of the extension
     */
    version(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { _version: BigNumber }>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Create a new funding proposal
     * @param _domainId The domain the extension has the funding permission
     * @param _fromChildSkillIndex The index of the fromPot's domain in _domainId.children[]
     * @param _fromPot Funding pot id providing the funds
     * @param _toChildSkillIndex The index of the toPot's domain in _domainId.children[]
     * @param _toPot Funding pot id receiving the funds
     * @param _token The token being transferred
     * @param _totalRequested The total amount being requested
     */
    createProposal(
      _domainId: PromiseOrValue<BigNumberish>,
      _fromChildSkillIndex: PromiseOrValue<BigNumberish>,
      _toChildSkillIndex: PromiseOrValue<BigNumberish>,
      _fromPot: PromiseOrValue<BigNumberish>,
      _toPot: PromiseOrValue<BigNumberish>,
      _totalRequested: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Cancel a funding proposal and remove from linked list
     * @param _id The proposal Id
     * @param _prevId The id of the preceding proposal in the linked list
     */
    cancelProposal(
      _id: PromiseOrValue<BigNumberish>,
      _prevId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Stake a funding proposal
     * @param _branchMask The branchmask of the proof
     * @param _id The proposal Id
     * @param _key A reputation hash tree key, of the total reputation in _domainId
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the total reputation in _domainId
     */
    stakeProposal(
      _id: PromiseOrValue<BigNumberish>,
      _key: PromiseOrValue<BytesLike>,
      _value: PromiseOrValue<BytesLike>,
      _branchMask: PromiseOrValue<BigNumberish>,
      _siblings: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Back a funding proposal and advance it along the list
     * @param _backing The amount of backing to give the proposal (up to user's reputation)
     * @param _branchMask The branchmask of the proof
     * @param _currPrevId The current previous proposal in the list
     * @param _id The proposal Id
     * @param _key A reputation hash tree key, of the caller's reputation in _domainId
     * @param _newPrevId The new previous proposal after we re-arrange
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the caller's reputation in _domainId
     */
    backProposal(
      _id: PromiseOrValue<BigNumberish>,
      _backing: PromiseOrValue<BigNumberish>,
      _currPrevId: PromiseOrValue<BigNumberish>,
      _newPrevId: PromiseOrValue<BigNumberish>,
      _key: PromiseOrValue<BytesLike>,
      _value: PromiseOrValue<BytesLike>,
      _branchMask: PromiseOrValue<BigNumberish>,
      _siblings: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Transfer the marginal funds
     * @param _id The proposal Id
     */
    pingProposal(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Reclaim the stake after the proposal is funded
     * @param _id The proposal Id
     */
    reclaimStake(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>;

    /**
     * Get the total number of proposals
     */
    getProposalCount(
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { count: BigNumber }>;

    /**
     * Get the proposal struct for a given proposal
     * @param _id The proposal Id
     */
    getProposal(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [FundingQueue.ProposalStructOutput] & {
        proposal: FundingQueue.ProposalStructOutput;
      }
    >;

    /**
     * Gets the reputation support from a user to a proposal
     * @param _id The proposal Id
     * @param _supporter The supporter
     */
    getSupport(
      _id: PromiseOrValue<BigNumberish>,
      _supporter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { support: BigNumber }>;

    /**
     * Gets the id of the next proposal in the list
     * @param _id The proposal Id
     */
    getNextProposalId(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { nextId: BigNumber }>;
  };

  authority(overrides?: CallOverrides): Promise<string>;

  /**
   * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
   * @param _payload Function call to make via meta transaction
   * @param _sigR R part of the signature
   * @param _sigS S part of the signature
   * @param _sigV V part of the signature
   * @param _user Address of user trying to do meta transaction
   */
  executeMetaTransaction(
    _user: PromiseOrValue<string>,
    _payload: PromiseOrValue<BytesLike>,
    _sigR: PromiseOrValue<BytesLike>,
    _sigS: PromiseOrValue<BytesLike>,
    _sigV: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  getCapabilityRoles(
    _sig: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>;

  getChainId(overrides?: CallOverrides): Promise<BigNumber>;

  getColony(overrides?: CallOverrides): Promise<string>;

  getDeprecated(overrides?: CallOverrides): Promise<boolean>;

  multicall(
    data: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  owner(overrides?: CallOverrides): Promise<string>;

  setAuthority(
    authority_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  setOwner(
    owner_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  verify(
    _owner: PromiseOrValue<string>,
    _nonce: PromiseOrValue<BigNumberish>,
    _chainId: PromiseOrValue<BigNumberish>,
    _payload: PromiseOrValue<BytesLike>,
    _sigR: PromiseOrValue<BytesLike>,
    _sigS: PromiseOrValue<BytesLike>,
    _sigV: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>;

  /**
   * Gets the next nonce for a meta-transaction
   * @param userAddress The user's address
   */
  getMetatransactionNonce(
    userAddress: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Returns the identifier of the extension
   */
  identifier(overrides?: CallOverrides): Promise<string>;

  /**
   * Returns the version of the extension
   */
  version(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Configures the extension
   * @param _colony The colony in which the extension holds permissions
   */
  install(
    _colony: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called when upgrading the extension
   */
  finishUpgrade(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called when deprecating (or undeprecating) the extension
   * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
   */
  deprecate(
    _deprecated: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Called when uninstalling the extension
   */
  uninstall(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Create a new funding proposal
   * @param _domainId The domain the extension has the funding permission
   * @param _fromChildSkillIndex The index of the fromPot's domain in _domainId.children[]
   * @param _fromPot Funding pot id providing the funds
   * @param _toChildSkillIndex The index of the toPot's domain in _domainId.children[]
   * @param _toPot Funding pot id receiving the funds
   * @param _token The token being transferred
   * @param _totalRequested The total amount being requested
   */
  createProposal(
    _domainId: PromiseOrValue<BigNumberish>,
    _fromChildSkillIndex: PromiseOrValue<BigNumberish>,
    _toChildSkillIndex: PromiseOrValue<BigNumberish>,
    _fromPot: PromiseOrValue<BigNumberish>,
    _toPot: PromiseOrValue<BigNumberish>,
    _totalRequested: PromiseOrValue<BigNumberish>,
    _token: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Cancel a funding proposal and remove from linked list
   * @param _id The proposal Id
   * @param _prevId The id of the preceding proposal in the linked list
   */
  cancelProposal(
    _id: PromiseOrValue<BigNumberish>,
    _prevId: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Stake a funding proposal
   * @param _branchMask The branchmask of the proof
   * @param _id The proposal Id
   * @param _key A reputation hash tree key, of the total reputation in _domainId
   * @param _siblings The siblings of the proof
   * @param _value Reputation value indicating the total reputation in _domainId
   */
  stakeProposal(
    _id: PromiseOrValue<BigNumberish>,
    _key: PromiseOrValue<BytesLike>,
    _value: PromiseOrValue<BytesLike>,
    _branchMask: PromiseOrValue<BigNumberish>,
    _siblings: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Back a funding proposal and advance it along the list
   * @param _backing The amount of backing to give the proposal (up to user's reputation)
   * @param _branchMask The branchmask of the proof
   * @param _currPrevId The current previous proposal in the list
   * @param _id The proposal Id
   * @param _key A reputation hash tree key, of the caller's reputation in _domainId
   * @param _newPrevId The new previous proposal after we re-arrange
   * @param _siblings The siblings of the proof
   * @param _value Reputation value indicating the caller's reputation in _domainId
   */
  backProposal(
    _id: PromiseOrValue<BigNumberish>,
    _backing: PromiseOrValue<BigNumberish>,
    _currPrevId: PromiseOrValue<BigNumberish>,
    _newPrevId: PromiseOrValue<BigNumberish>,
    _key: PromiseOrValue<BytesLike>,
    _value: PromiseOrValue<BytesLike>,
    _branchMask: PromiseOrValue<BigNumberish>,
    _siblings: PromiseOrValue<BytesLike>[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Transfer the marginal funds
   * @param _id The proposal Id
   */
  pingProposal(
    _id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Reclaim the stake after the proposal is funded
   * @param _id The proposal Id
   */
  reclaimStake(
    _id: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>;

  /**
   * Get the total number of proposals
   */
  getProposalCount(overrides?: CallOverrides): Promise<BigNumber>;

  /**
   * Get the proposal struct for a given proposal
   * @param _id The proposal Id
   */
  getProposal(
    _id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<FundingQueue.ProposalStructOutput>;

  /**
   * Gets the reputation support from a user to a proposal
   * @param _id The proposal Id
   * @param _supporter The supporter
   */
  getSupport(
    _id: PromiseOrValue<BigNumberish>,
    _supporter: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  /**
   * Gets the id of the next proposal in the list
   * @param _id The proposal Id
   */
  getNextProposalId(
    _id: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>;

  callStatic: {
    authority(overrides?: CallOverrides): Promise<string>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>;

    getCapabilityRoles(
      _sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<string>;

    getDeprecated(overrides?: CallOverrides): Promise<boolean>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string[]>;

    owner(overrides?: CallOverrides): Promise<string>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param userAddress The user's address
     */
    getMetatransactionNonce(
      userAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<string>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(overrides?: CallOverrides): Promise<void>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(overrides?: CallOverrides): Promise<void>;

    /**
     * Create a new funding proposal
     * @param _domainId The domain the extension has the funding permission
     * @param _fromChildSkillIndex The index of the fromPot's domain in _domainId.children[]
     * @param _fromPot Funding pot id providing the funds
     * @param _toChildSkillIndex The index of the toPot's domain in _domainId.children[]
     * @param _toPot Funding pot id receiving the funds
     * @param _token The token being transferred
     * @param _totalRequested The total amount being requested
     */
    createProposal(
      _domainId: PromiseOrValue<BigNumberish>,
      _fromChildSkillIndex: PromiseOrValue<BigNumberish>,
      _toChildSkillIndex: PromiseOrValue<BigNumberish>,
      _fromPot: PromiseOrValue<BigNumberish>,
      _toPot: PromiseOrValue<BigNumberish>,
      _totalRequested: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Cancel a funding proposal and remove from linked list
     * @param _id The proposal Id
     * @param _prevId The id of the preceding proposal in the linked list
     */
    cancelProposal(
      _id: PromiseOrValue<BigNumberish>,
      _prevId: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Stake a funding proposal
     * @param _branchMask The branchmask of the proof
     * @param _id The proposal Id
     * @param _key A reputation hash tree key, of the total reputation in _domainId
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the total reputation in _domainId
     */
    stakeProposal(
      _id: PromiseOrValue<BigNumberish>,
      _key: PromiseOrValue<BytesLike>,
      _value: PromiseOrValue<BytesLike>,
      _branchMask: PromiseOrValue<BigNumberish>,
      _siblings: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Back a funding proposal and advance it along the list
     * @param _backing The amount of backing to give the proposal (up to user's reputation)
     * @param _branchMask The branchmask of the proof
     * @param _currPrevId The current previous proposal in the list
     * @param _id The proposal Id
     * @param _key A reputation hash tree key, of the caller's reputation in _domainId
     * @param _newPrevId The new previous proposal after we re-arrange
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the caller's reputation in _domainId
     */
    backProposal(
      _id: PromiseOrValue<BigNumberish>,
      _backing: PromiseOrValue<BigNumberish>,
      _currPrevId: PromiseOrValue<BigNumberish>,
      _newPrevId: PromiseOrValue<BigNumberish>,
      _key: PromiseOrValue<BytesLike>,
      _value: PromiseOrValue<BytesLike>,
      _branchMask: PromiseOrValue<BigNumberish>,
      _siblings: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Transfer the marginal funds
     * @param _id The proposal Id
     */
    pingProposal(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Reclaim the stake after the proposal is funded
     * @param _id The proposal Id
     */
    reclaimStake(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>;

    /**
     * Get the total number of proposals
     */
    getProposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the proposal struct for a given proposal
     * @param _id The proposal Id
     */
    getProposal(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<FundingQueue.ProposalStructOutput>;

    /**
     * Gets the reputation support from a user to a proposal
     * @param _id The proposal Id
     * @param _supporter The supporter
     */
    getSupport(
      _id: PromiseOrValue<BigNumberish>,
      _supporter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the id of the next proposal in the list
     * @param _id The proposal Id
     */
    getNextProposalId(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  filters: {
    "ExtensionInitialised()"(): ExtensionInitialisedEventFilter;
    ExtensionInitialised(): ExtensionInitialisedEventFilter;

    "LogSetAuthority(address)"(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;
    LogSetAuthority(
      authority?: PromiseOrValue<string> | null
    ): LogSetAuthorityEventFilter;

    "LogSetOwner(address)"(
      owner?: PromiseOrValue<string> | null
    ): LogSetOwnerEventFilter;
    LogSetOwner(owner?: PromiseOrValue<string> | null): LogSetOwnerEventFilter;

    "MetaTransactionExecuted(address,address,bytes)"(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;
    MetaTransactionExecuted(
      user?: null,
      relayerAddress?: null,
      functionSignature?: null
    ): MetaTransactionExecutedEventFilter;

    "ProposalBacked(uint256,uint256,address,uint256,uint256)"(
      id?: PromiseOrValue<BigNumberish> | null,
      newPrevId?: PromiseOrValue<BigNumberish> | null,
      user?: PromiseOrValue<string> | null,
      backing?: null,
      prevBacking?: null
    ): ProposalBackedEventFilter;
    ProposalBacked(
      id?: PromiseOrValue<BigNumberish> | null,
      newPrevId?: PromiseOrValue<BigNumberish> | null,
      user?: PromiseOrValue<string> | null,
      backing?: null,
      prevBacking?: null
    ): ProposalBackedEventFilter;

    "ProposalCancelled(uint256)"(
      id?: PromiseOrValue<BigNumberish> | null
    ): ProposalCancelledEventFilter;
    ProposalCancelled(
      id?: PromiseOrValue<BigNumberish> | null
    ): ProposalCancelledEventFilter;

    "ProposalCompleted(uint256)"(
      id?: PromiseOrValue<BigNumberish> | null
    ): ProposalCompletedEventFilter;
    ProposalCompleted(
      id?: PromiseOrValue<BigNumberish> | null
    ): ProposalCompletedEventFilter;

    "ProposalCreated(uint256,uint256,uint256,address,uint256)"(
      id?: null,
      fromPot?: PromiseOrValue<BigNumberish> | null,
      toPot?: PromiseOrValue<BigNumberish> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): ProposalCreatedEventFilter;
    ProposalCreated(
      id?: null,
      fromPot?: PromiseOrValue<BigNumberish> | null,
      toPot?: PromiseOrValue<BigNumberish> | null,
      token?: PromiseOrValue<string> | null,
      amount?: null
    ): ProposalCreatedEventFilter;

    "ProposalPinged(uint256,uint256)"(
      id?: PromiseOrValue<BigNumberish> | null,
      amount?: null
    ): ProposalPingedEventFilter;
    ProposalPinged(
      id?: PromiseOrValue<BigNumberish> | null,
      amount?: null
    ): ProposalPingedEventFilter;

    "ProposalStakeReclaimed(uint256)"(
      id?: PromiseOrValue<BigNumberish> | null
    ): ProposalStakeReclaimedEventFilter;
    ProposalStakeReclaimed(
      id?: PromiseOrValue<BigNumberish> | null
    ): ProposalStakeReclaimedEventFilter;

    "ProposalStaked(uint256,uint256)"(
      id?: PromiseOrValue<BigNumberish> | null,
      domainTotalRep?: null
    ): ProposalStakedEventFilter;
    ProposalStaked(
      id?: PromiseOrValue<BigNumberish> | null,
      domainTotalRep?: null
    ): ProposalStakedEventFilter;
  };

  estimateGas: {
    authority(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    getCapabilityRoles(
      _sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getChainId(overrides?: CallOverrides): Promise<BigNumber>;

    getColony(overrides?: CallOverrides): Promise<BigNumber>;

    getDeprecated(overrides?: CallOverrides): Promise<BigNumber>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param userAddress The user's address
     */
    getMetatransactionNonce(
      userAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Create a new funding proposal
     * @param _domainId The domain the extension has the funding permission
     * @param _fromChildSkillIndex The index of the fromPot's domain in _domainId.children[]
     * @param _fromPot Funding pot id providing the funds
     * @param _toChildSkillIndex The index of the toPot's domain in _domainId.children[]
     * @param _toPot Funding pot id receiving the funds
     * @param _token The token being transferred
     * @param _totalRequested The total amount being requested
     */
    createProposal(
      _domainId: PromiseOrValue<BigNumberish>,
      _fromChildSkillIndex: PromiseOrValue<BigNumberish>,
      _toChildSkillIndex: PromiseOrValue<BigNumberish>,
      _fromPot: PromiseOrValue<BigNumberish>,
      _toPot: PromiseOrValue<BigNumberish>,
      _totalRequested: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Cancel a funding proposal and remove from linked list
     * @param _id The proposal Id
     * @param _prevId The id of the preceding proposal in the linked list
     */
    cancelProposal(
      _id: PromiseOrValue<BigNumberish>,
      _prevId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Stake a funding proposal
     * @param _branchMask The branchmask of the proof
     * @param _id The proposal Id
     * @param _key A reputation hash tree key, of the total reputation in _domainId
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the total reputation in _domainId
     */
    stakeProposal(
      _id: PromiseOrValue<BigNumberish>,
      _key: PromiseOrValue<BytesLike>,
      _value: PromiseOrValue<BytesLike>,
      _branchMask: PromiseOrValue<BigNumberish>,
      _siblings: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Back a funding proposal and advance it along the list
     * @param _backing The amount of backing to give the proposal (up to user's reputation)
     * @param _branchMask The branchmask of the proof
     * @param _currPrevId The current previous proposal in the list
     * @param _id The proposal Id
     * @param _key A reputation hash tree key, of the caller's reputation in _domainId
     * @param _newPrevId The new previous proposal after we re-arrange
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the caller's reputation in _domainId
     */
    backProposal(
      _id: PromiseOrValue<BigNumberish>,
      _backing: PromiseOrValue<BigNumberish>,
      _currPrevId: PromiseOrValue<BigNumberish>,
      _newPrevId: PromiseOrValue<BigNumberish>,
      _key: PromiseOrValue<BytesLike>,
      _value: PromiseOrValue<BytesLike>,
      _branchMask: PromiseOrValue<BigNumberish>,
      _siblings: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Transfer the marginal funds
     * @param _id The proposal Id
     */
    pingProposal(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Reclaim the stake after the proposal is funded
     * @param _id The proposal Id
     */
    reclaimStake(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>;

    /**
     * Get the total number of proposals
     */
    getProposalCount(overrides?: CallOverrides): Promise<BigNumber>;

    /**
     * Get the proposal struct for a given proposal
     * @param _id The proposal Id
     */
    getProposal(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the reputation support from a user to a proposal
     * @param _id The proposal Id
     * @param _supporter The supporter
     */
    getSupport(
      _id: PromiseOrValue<BigNumberish>,
      _supporter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    /**
     * Gets the id of the next proposal in the list
     * @param _id The proposal Id
     */
    getNextProposalId(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Main function to be called when user wants to execute meta transaction. The actual function to be called should be passed as param with name functionSignature Here the basic signature recovery is being used. Signature is expected to be generated using personal_sign method.
     * @param _payload Function call to make via meta transaction
     * @param _sigR R part of the signature
     * @param _sigS S part of the signature
     * @param _sigV V part of the signature
     * @param _user Address of user trying to do meta transaction
     */
    executeMetaTransaction(
      _user: PromiseOrValue<string>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    getCapabilityRoles(
      _sig: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getChainId(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getColony(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    getDeprecated(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    setAuthority(
      authority_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    setOwner(
      owner_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    verify(
      _owner: PromiseOrValue<string>,
      _nonce: PromiseOrValue<BigNumberish>,
      _chainId: PromiseOrValue<BigNumberish>,
      _payload: PromiseOrValue<BytesLike>,
      _sigR: PromiseOrValue<BytesLike>,
      _sigS: PromiseOrValue<BytesLike>,
      _sigV: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the next nonce for a meta-transaction
     * @param userAddress The user's address
     */
    getMetatransactionNonce(
      userAddress: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Returns the identifier of the extension
     */
    identifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Returns the version of the extension
     */
    version(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Configures the extension
     * @param _colony The colony in which the extension holds permissions
     */
    install(
      _colony: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when upgrading the extension
     */
    finishUpgrade(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when deprecating (or undeprecating) the extension
     * @param _deprecated Indicates whether the extension should be deprecated or undeprecated
     */
    deprecate(
      _deprecated: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Called when uninstalling the extension
     */
    uninstall(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Create a new funding proposal
     * @param _domainId The domain the extension has the funding permission
     * @param _fromChildSkillIndex The index of the fromPot's domain in _domainId.children[]
     * @param _fromPot Funding pot id providing the funds
     * @param _toChildSkillIndex The index of the toPot's domain in _domainId.children[]
     * @param _toPot Funding pot id receiving the funds
     * @param _token The token being transferred
     * @param _totalRequested The total amount being requested
     */
    createProposal(
      _domainId: PromiseOrValue<BigNumberish>,
      _fromChildSkillIndex: PromiseOrValue<BigNumberish>,
      _toChildSkillIndex: PromiseOrValue<BigNumberish>,
      _fromPot: PromiseOrValue<BigNumberish>,
      _toPot: PromiseOrValue<BigNumberish>,
      _totalRequested: PromiseOrValue<BigNumberish>,
      _token: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Cancel a funding proposal and remove from linked list
     * @param _id The proposal Id
     * @param _prevId The id of the preceding proposal in the linked list
     */
    cancelProposal(
      _id: PromiseOrValue<BigNumberish>,
      _prevId: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Stake a funding proposal
     * @param _branchMask The branchmask of the proof
     * @param _id The proposal Id
     * @param _key A reputation hash tree key, of the total reputation in _domainId
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the total reputation in _domainId
     */
    stakeProposal(
      _id: PromiseOrValue<BigNumberish>,
      _key: PromiseOrValue<BytesLike>,
      _value: PromiseOrValue<BytesLike>,
      _branchMask: PromiseOrValue<BigNumberish>,
      _siblings: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Back a funding proposal and advance it along the list
     * @param _backing The amount of backing to give the proposal (up to user's reputation)
     * @param _branchMask The branchmask of the proof
     * @param _currPrevId The current previous proposal in the list
     * @param _id The proposal Id
     * @param _key A reputation hash tree key, of the caller's reputation in _domainId
     * @param _newPrevId The new previous proposal after we re-arrange
     * @param _siblings The siblings of the proof
     * @param _value Reputation value indicating the caller's reputation in _domainId
     */
    backProposal(
      _id: PromiseOrValue<BigNumberish>,
      _backing: PromiseOrValue<BigNumberish>,
      _currPrevId: PromiseOrValue<BigNumberish>,
      _newPrevId: PromiseOrValue<BigNumberish>,
      _key: PromiseOrValue<BytesLike>,
      _value: PromiseOrValue<BytesLike>,
      _branchMask: PromiseOrValue<BigNumberish>,
      _siblings: PromiseOrValue<BytesLike>[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Transfer the marginal funds
     * @param _id The proposal Id
     */
    pingProposal(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Reclaim the stake after the proposal is funded
     * @param _id The proposal Id
     */
    reclaimStake(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>;

    /**
     * Get the total number of proposals
     */
    getProposalCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    /**
     * Get the proposal struct for a given proposal
     * @param _id The proposal Id
     */
    getProposal(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the reputation support from a user to a proposal
     * @param _id The proposal Id
     * @param _supporter The supporter
     */
    getSupport(
      _id: PromiseOrValue<BigNumberish>,
      _supporter: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    /**
     * Gets the id of the next proposal in the list
     * @param _id The proposal Id
     */
    getNextProposalId(
      _id: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;
  };
}
