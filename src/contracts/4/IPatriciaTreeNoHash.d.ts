/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface IPatriciaTreeNoHashInterface extends Interface {
  functions: {
    getNode: TypedFunctionDescription<{ encode([hash]: [Arrayish]): string }>;

    getRootHash: TypedFunctionDescription<{ encode([]: []): string }>;

    getRootEdge: TypedFunctionDescription<{ encode([]: []): string }>;

    insert: TypedFunctionDescription<{
      encode([key, value]: [Arrayish, Arrayish]): string;
    }>;

    getProof: TypedFunctionDescription<{ encode([key]: [Arrayish]): string }>;

    getImpliedRoot: TypedFunctionDescription<{
      encode([key, value, branchMask, siblings]: [
        Arrayish,
        Arrayish,
        BigNumberish,
        Arrayish[]
      ]): string;
    }>;
  };

  events: {};
}

export class IPatriciaTreeNoHash extends Contract {
  connect(signerOrProvider: Signer | Provider | string): IPatriciaTreeNoHash;
  attach(addressOrName: string): IPatriciaTreeNoHash;
  deployed(): Promise<IPatriciaTreeNoHash>;

  on(event: EventFilter | string, listener: Listener): IPatriciaTreeNoHash;
  once(event: EventFilter | string, listener: Listener): IPatriciaTreeNoHash;
  addListener(
    eventName: EventFilter | string,
    listener: Listener
  ): IPatriciaTreeNoHash;
  removeAllListeners(eventName: EventFilter | string): IPatriciaTreeNoHash;
  removeListener(eventName: any, listener: Listener): IPatriciaTreeNoHash;

  interface: IPatriciaTreeNoHashInterface;

  functions: {
    /**
     * Get the node with the given key
     * @param hash The `keccak256` hash of the actual key
     * @returns n `Data.Node` for key `hash`
     */
    getNode(
      hash: Arrayish
    ): Promise<{
      children: {
        node: string;
        label: { data: string; length: BigNumber; 0: string; 1: BigNumber };
        0: string;
        1: { data: string; length: BigNumber; 0: string; 1: BigNumber };
      }[];
      0: {
        node: string;
        label: { data: string; length: BigNumber; 0: string; 1: BigNumber };
        0: string;
        1: { data: string; length: BigNumber; 0: string; 1: BigNumber };
      }[];
    }>;

    /**
     * This value is a keccak256 hash of the rootEdge: `keccak256(Edge.node, Edge.label.length, Edge.label.data)`
     * Get the root hash
     * @returns rootHash The `bytes32` hash value
     */
    getRootHash(): Promise<string>;

    /**
     * Get the root edge
     * @returns e The root `Data.Edge`
     */
    getRootEdge(): Promise<{
      node: string;
      label: { data: string; length: BigNumber; 0: string; 1: BigNumber };
      0: string;
      1: { data: string; length: BigNumber; 0: string; 1: BigNumber };
    }>;

    insert(
      key: Arrayish,
      value: Arrayish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    /**
     * Returns the Merkle-proof for the given `key`
     * @returns branchMask Bitmask with high bits at the positions in the `key` where we have branch nodes (bit in key denotes direction)_siblings Hashes of sibling edges
     */
    getProof(
      key: Arrayish
    ): Promise<{
      branchMask: BigNumber;
      _siblings: string[];
      0: BigNumber;
      1: string[];
    }>;

    /**
     * Calculates and returns a root hash for the `key`, `value`, `branchMask` and `siblings`
     * @returns rootHash The calculated hash
     */
    getImpliedRoot(
      key: Arrayish,
      value: Arrayish,
      branchMask: BigNumberish,
      siblings: Arrayish[]
    ): Promise<string>;
  };

  /**
   * Get the node with the given key
   * @param hash The `keccak256` hash of the actual key
   * @returns n `Data.Node` for key `hash`
   */
  getNode(
    hash: Arrayish
  ): Promise<{
    children: {
      node: string;
      label: { data: string; length: BigNumber; 0: string; 1: BigNumber };
      0: string;
      1: { data: string; length: BigNumber; 0: string; 1: BigNumber };
    }[];
    0: {
      node: string;
      label: { data: string; length: BigNumber; 0: string; 1: BigNumber };
      0: string;
      1: { data: string; length: BigNumber; 0: string; 1: BigNumber };
    }[];
  }>;

  /**
   * This value is a keccak256 hash of the rootEdge: `keccak256(Edge.node, Edge.label.length, Edge.label.data)`
   * Get the root hash
   * @returns rootHash The `bytes32` hash value
   */
  getRootHash(): Promise<string>;

  /**
   * Get the root edge
   * @returns e The root `Data.Edge`
   */
  getRootEdge(): Promise<{
    node: string;
    label: { data: string; length: BigNumber; 0: string; 1: BigNumber };
    0: string;
    1: { data: string; length: BigNumber; 0: string; 1: BigNumber };
  }>;

  insert(
    key: Arrayish,
    value: Arrayish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  /**
   * Returns the Merkle-proof for the given `key`
   * @returns branchMask Bitmask with high bits at the positions in the `key` where we have branch nodes (bit in key denotes direction)_siblings Hashes of sibling edges
   */
  getProof(
    key: Arrayish
  ): Promise<{
    branchMask: BigNumber;
    _siblings: string[];
    0: BigNumber;
    1: string[];
  }>;

  /**
   * Calculates and returns a root hash for the `key`, `value`, `branchMask` and `siblings`
   * @returns rootHash The calculated hash
   */
  getImpliedRoot(
    key: Arrayish,
    value: Arrayish,
    branchMask: BigNumberish,
    siblings: Arrayish[]
  ): Promise<string>;

  filters: {};

  estimate: {
    getNode(hash: Arrayish): Promise<BigNumber>;

    getRootHash(): Promise<BigNumber>;

    getRootEdge(): Promise<BigNumber>;

    insert(key: Arrayish, value: Arrayish): Promise<BigNumber>;

    getProof(key: Arrayish): Promise<BigNumber>;

    getImpliedRoot(
      key: Arrayish,
      value: Arrayish,
      branchMask: BigNumberish,
      siblings: Arrayish[]
    ): Promise<BigNumber>;
  };
}
