/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter, Signer } from "ethers";
import { Listener, Provider } from "ethers/providers";
import { Arrayish, BigNumber, BigNumberish, Interface } from "ethers/utils";
import {
  TransactionOverrides,
  TypedEventDescription,
  TypedFunctionDescription
} from ".";

interface IReputationMiningCycleInterface extends Interface {
  functions: {
    getDisputeRound: TypedFunctionDescription<{
      encode([_round]: [BigNumberish]): string;
    }>;

    getReputationHashSubmission: TypedFunctionDescription<{
      encode([_user]: [string]): string;
    }>;

    getEntryHash: TypedFunctionDescription<{
      encode([submitter, entryIndex, newHash]: [
        string,
        BigNumberish,
        Arrayish
      ]): string;
    }>;

    minerSubmittedEntryIndex: TypedFunctionDescription<{
      encode([_miner, _index]: [string, BigNumberish]): string;
    }>;

    resetWindow: TypedFunctionDescription<{ encode([]: []): string }>;

    submitRootHash: TypedFunctionDescription<{
      encode([newHash, nNodes, jrh, entryIndex]: [
        Arrayish,
        BigNumberish,
        Arrayish,
        BigNumberish
      ]): string;
    }>;

    challengeRoundComplete: TypedFunctionDescription<{
      encode([round]: [BigNumberish]): string;
    }>;

    confirmNewHash: TypedFunctionDescription<{
      encode([roundNumber]: [BigNumberish]): string;
    }>;

    invalidateHash: TypedFunctionDescription<{
      encode([round, idx]: [BigNumberish, BigNumberish]): string;
    }>;

    respondToBinarySearchForChallenge: TypedFunctionDescription<{
      encode([round, idx, jhIntermediateValue, siblings]: [
        BigNumberish,
        BigNumberish,
        Arrayish,
        Arrayish[]
      ]): string;
    }>;

    confirmBinarySearchResult: TypedFunctionDescription<{
      encode([round, idx, jhIntermediateValue, siblings]: [
        BigNumberish,
        BigNumberish,
        Arrayish,
        Arrayish[]
      ]): string;
    }>;

    respondToChallenge: TypedFunctionDescription<{
      encode([
        u,
        b32,
        reputationSiblings,
        agreeStateSiblings,
        disagreeStateSiblings,
        userOriginReputationSiblings,
        childReputationSiblings,
        adjacentReputationSiblings
      ]: [
        BigNumberish[],
        Arrayish[],
        Arrayish[],
        Arrayish[],
        Arrayish[],
        Arrayish[],
        Arrayish[],
        Arrayish[]
      ]): string;
    }>;

    confirmJustificationRootHash: TypedFunctionDescription<{
      encode([round, index, siblings1, siblings2]: [
        BigNumberish,
        BigNumberish,
        Arrayish[],
        Arrayish[]
      ]): string;
    }>;

    appendReputationUpdateLog: TypedFunctionDescription<{
      encode([
        _user,
        _amount,
        _skillId,
        _colonyAddress,
        _nParents,
        _nChildren
      ]: [
        string,
        BigNumberish,
        BigNumberish,
        string,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getReputationUpdateLogLength: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getReputationUpdateLogEntry: TypedFunctionDescription<{
      encode([_id]: [BigNumberish]): string;
    }>;

    rewardStakersWithReputation: TypedFunctionDescription<{
      encode([stakers, weights, metaColonyAddress, reward, miningSkillId]: [
        string[],
        BigNumberish[],
        string,
        BigNumberish,
        BigNumberish
      ]): string;
    }>;

    getReputationMiningWindowOpenTimestamp: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    initialise: TypedFunctionDescription<{
      encode([tokenLocking, clnyToken]: [string, string]): string;
    }>;

    getNUniqueSubmittedHashes: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getNInvalidatedHashes: TypedFunctionDescription<{ encode([]: []): string }>;

    getMinStake: TypedFunctionDescription<{ encode([]: []): string }>;

    getMiningWindowDuration: TypedFunctionDescription<{
      encode([]: []): string;
    }>;

    getDecayConstant: TypedFunctionDescription<{ encode([]: []): string }>;

    getSubmissionUser: TypedFunctionDescription<{
      encode([hash, nNodes, jrh, index]: [
        Arrayish,
        BigNumberish,
        Arrayish,
        BigNumberish
      ]): string;
    }>;

    getNSubmissionsForHash: TypedFunctionDescription<{
      encode([hash, nNodes, jrh]: [Arrayish, BigNumberish, Arrayish]): string;
    }>;
  };

  events: {
    ReputationRootHashSubmitted: TypedEventDescription<{
      encodeTopics([_miner, _newHash, _nNodes, _jrh, _entryIndex]: [
        null,
        null,
        null,
        null,
        null
      ]): string[];
    }>;

    JustificationRootHashConfirmed: TypedEventDescription<{
      encodeTopics([_newHash, _nNodes, _jrh]: [null, null, null]): string[];
    }>;

    BinarySearchConfirmed: TypedEventDescription<{
      encodeTopics([_newHash, _nNodes, _jrh, _firstDisagreeIdx]: [
        null,
        null,
        null,
        null
      ]): string[];
    }>;

    ChallengeCompleted: TypedEventDescription<{
      encodeTopics([_newHash, _nNodes, _jrh]: [null, null, null]): string[];
    }>;

    HashInvalidated: TypedEventDescription<{
      encodeTopics([_newHash, _nNodes, _jrh]: [null, null, null]): string[];
    }>;

    ProveUIDSuccess: TypedEventDescription<{
      encodeTopics([
        previousNewReputationUID,
        _disagreeStateReputationUID,
        existingUID
      ]: [null, null, null]): string[];
    }>;

    ProveValueSuccess: TypedEventDescription<{
      encodeTopics([
        _agreeStateReputationValue,
        _disagreeStateReputationValue,
        _originReputationValue
      ]: [null, null, null]): string[];
    }>;
  };
}

export class IReputationMiningCycle extends Contract {
  connect(signerOrProvider: Signer | Provider | string): IReputationMiningCycle;
  attach(addressOrName: string): IReputationMiningCycle;
  deployed(): Promise<IReputationMiningCycle>;

  on(event: EventFilter | string, listener: Listener): IReputationMiningCycle;
  once(event: EventFilter | string, listener: Listener): IReputationMiningCycle;
  addListener(
    eventName: EventFilter | string,
    listener: Listener
  ): IReputationMiningCycle;
  removeAllListeners(eventName: EventFilter | string): IReputationMiningCycle;
  removeListener(eventName: any, listener: Listener): IReputationMiningCycle;

  interface: IReputationMiningCycleInterface;

  functions: {
    getDisputeRound(
      _round: BigNumberish
    ): Promise<
      {
        firstSubmitter: string;
        lastResponseTimestamp: BigNumber;
        challengeStepCompleted: BigNumber;
        intermediateReputationHash: string;
        intermediateReputationNNodes: BigNumber;
        lowerBound: BigNumber;
        upperBound: BigNumber;
        targetHashDuringSearch: string;
        hash1: string;
        hash2: string;
      }[]
    >;

    getReputationHashSubmission(
      _user: string
    ): Promise<{
      proposedNewRootHash: string;
      nNodes: BigNumber;
      jrh: string;
      jrhNNodes: BigNumber;
    }>;

    getEntryHash(
      submitter: string,
      entryIndex: BigNumberish,
      newHash: Arrayish
    ): Promise<string>;

    minerSubmittedEntryIndex(
      _miner: string,
      _index: BigNumberish
    ): Promise<boolean>;

    resetWindow(overrides?: TransactionOverrides): Promise<ContractTransaction>;

    submitRootHash(
      newHash: Arrayish,
      nNodes: BigNumberish,
      jrh: Arrayish,
      entryIndex: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    challengeRoundComplete(round: BigNumberish): Promise<boolean>;

    confirmNewHash(
      roundNumber: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    invalidateHash(
      round: BigNumberish,
      idx: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    respondToBinarySearchForChallenge(
      round: BigNumberish,
      idx: BigNumberish,
      jhIntermediateValue: Arrayish,
      siblings: Arrayish[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    confirmBinarySearchResult(
      round: BigNumberish,
      idx: BigNumberish,
      jhIntermediateValue: Arrayish,
      siblings: Arrayish[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    respondToChallenge(
      u: BigNumberish[],
      b32: Arrayish[],
      reputationSiblings: Arrayish[],
      agreeStateSiblings: Arrayish[],
      disagreeStateSiblings: Arrayish[],
      userOriginReputationSiblings: Arrayish[],
      childReputationSiblings: Arrayish[],
      adjacentReputationSiblings: Arrayish[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    confirmJustificationRootHash(
      round: BigNumberish,
      index: BigNumberish,
      siblings1: Arrayish[],
      siblings2: Arrayish[],
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colonyAddress: string,
      _nParents: BigNumberish,
      _nChildren: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    getReputationUpdateLogLength(): Promise<BigNumber>;

    getReputationUpdateLogEntry(
      _id: BigNumberish
    ): Promise<{
      user: string;
      amount: BigNumber;
      skillId: BigNumber;
      colony: string;
      nUpdates: BigNumber;
      nPreviousUpdates: BigNumber;
    }>;

    rewardStakersWithReputation(
      stakers: string[],
      weights: BigNumberish[],
      metaColonyAddress: string,
      reward: BigNumberish,
      miningSkillId: BigNumberish,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    getReputationMiningWindowOpenTimestamp(): Promise<BigNumber>;

    initialise(
      tokenLocking: string,
      clnyToken: string,
      overrides?: TransactionOverrides
    ): Promise<ContractTransaction>;

    getNUniqueSubmittedHashes(): Promise<BigNumber>;

    getNInvalidatedHashes(): Promise<BigNumber>;

    getMinStake(): Promise<BigNumber>;

    getMiningWindowDuration(): Promise<BigNumber>;

    getDecayConstant(): Promise<{
      numerator: BigNumber;
      denominator: BigNumber;
      0: BigNumber;
      1: BigNumber;
    }>;

    getSubmissionUser(
      hash: Arrayish,
      nNodes: BigNumberish,
      jrh: Arrayish,
      index: BigNumberish
    ): Promise<string>;

    getNSubmissionsForHash(
      hash: Arrayish,
      nNodes: BigNumberish,
      jrh: Arrayish
    ): Promise<BigNumber>;
  };

  getDisputeRound(
    _round: BigNumberish
  ): Promise<
    {
      firstSubmitter: string;
      lastResponseTimestamp: BigNumber;
      challengeStepCompleted: BigNumber;
      intermediateReputationHash: string;
      intermediateReputationNNodes: BigNumber;
      lowerBound: BigNumber;
      upperBound: BigNumber;
      targetHashDuringSearch: string;
      hash1: string;
      hash2: string;
    }[]
  >;

  getReputationHashSubmission(
    _user: string
  ): Promise<{
    proposedNewRootHash: string;
    nNodes: BigNumber;
    jrh: string;
    jrhNNodes: BigNumber;
  }>;

  getEntryHash(
    submitter: string,
    entryIndex: BigNumberish,
    newHash: Arrayish
  ): Promise<string>;

  minerSubmittedEntryIndex(
    _miner: string,
    _index: BigNumberish
  ): Promise<boolean>;

  resetWindow(overrides?: TransactionOverrides): Promise<ContractTransaction>;

  submitRootHash(
    newHash: Arrayish,
    nNodes: BigNumberish,
    jrh: Arrayish,
    entryIndex: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  challengeRoundComplete(round: BigNumberish): Promise<boolean>;

  confirmNewHash(
    roundNumber: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  invalidateHash(
    round: BigNumberish,
    idx: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  respondToBinarySearchForChallenge(
    round: BigNumberish,
    idx: BigNumberish,
    jhIntermediateValue: Arrayish,
    siblings: Arrayish[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  confirmBinarySearchResult(
    round: BigNumberish,
    idx: BigNumberish,
    jhIntermediateValue: Arrayish,
    siblings: Arrayish[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  respondToChallenge(
    u: BigNumberish[],
    b32: Arrayish[],
    reputationSiblings: Arrayish[],
    agreeStateSiblings: Arrayish[],
    disagreeStateSiblings: Arrayish[],
    userOriginReputationSiblings: Arrayish[],
    childReputationSiblings: Arrayish[],
    adjacentReputationSiblings: Arrayish[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  confirmJustificationRootHash(
    round: BigNumberish,
    index: BigNumberish,
    siblings1: Arrayish[],
    siblings2: Arrayish[],
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  appendReputationUpdateLog(
    _user: string,
    _amount: BigNumberish,
    _skillId: BigNumberish,
    _colonyAddress: string,
    _nParents: BigNumberish,
    _nChildren: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  getReputationUpdateLogLength(): Promise<BigNumber>;

  getReputationUpdateLogEntry(
    _id: BigNumberish
  ): Promise<{
    user: string;
    amount: BigNumber;
    skillId: BigNumber;
    colony: string;
    nUpdates: BigNumber;
    nPreviousUpdates: BigNumber;
  }>;

  rewardStakersWithReputation(
    stakers: string[],
    weights: BigNumberish[],
    metaColonyAddress: string,
    reward: BigNumberish,
    miningSkillId: BigNumberish,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  getReputationMiningWindowOpenTimestamp(): Promise<BigNumber>;

  initialise(
    tokenLocking: string,
    clnyToken: string,
    overrides?: TransactionOverrides
  ): Promise<ContractTransaction>;

  getNUniqueSubmittedHashes(): Promise<BigNumber>;

  getNInvalidatedHashes(): Promise<BigNumber>;

  getMinStake(): Promise<BigNumber>;

  getMiningWindowDuration(): Promise<BigNumber>;

  getDecayConstant(): Promise<{
    numerator: BigNumber;
    denominator: BigNumber;
    0: BigNumber;
    1: BigNumber;
  }>;

  getSubmissionUser(
    hash: Arrayish,
    nNodes: BigNumberish,
    jrh: Arrayish,
    index: BigNumberish
  ): Promise<string>;

  getNSubmissionsForHash(
    hash: Arrayish,
    nNodes: BigNumberish,
    jrh: Arrayish
  ): Promise<BigNumber>;

  filters: {
    ReputationRootHashSubmitted(
      _miner: null,
      _newHash: null,
      _nNodes: null,
      _jrh: null,
      _entryIndex: null
    ): EventFilter;

    JustificationRootHashConfirmed(
      _newHash: null,
      _nNodes: null,
      _jrh: null
    ): EventFilter;

    BinarySearchConfirmed(
      _newHash: null,
      _nNodes: null,
      _jrh: null,
      _firstDisagreeIdx: null
    ): EventFilter;

    ChallengeCompleted(_newHash: null, _nNodes: null, _jrh: null): EventFilter;

    HashInvalidated(_newHash: null, _nNodes: null, _jrh: null): EventFilter;

    ProveUIDSuccess(
      previousNewReputationUID: null,
      _disagreeStateReputationUID: null,
      existingUID: null
    ): EventFilter;

    ProveValueSuccess(
      _agreeStateReputationValue: null,
      _disagreeStateReputationValue: null,
      _originReputationValue: null
    ): EventFilter;
  };

  estimate: {
    getDisputeRound(_round: BigNumberish): Promise<BigNumber>;

    getReputationHashSubmission(_user: string): Promise<BigNumber>;

    getEntryHash(
      submitter: string,
      entryIndex: BigNumberish,
      newHash: Arrayish
    ): Promise<BigNumber>;

    minerSubmittedEntryIndex(
      _miner: string,
      _index: BigNumberish
    ): Promise<BigNumber>;

    resetWindow(): Promise<BigNumber>;

    submitRootHash(
      newHash: Arrayish,
      nNodes: BigNumberish,
      jrh: Arrayish,
      entryIndex: BigNumberish
    ): Promise<BigNumber>;

    challengeRoundComplete(round: BigNumberish): Promise<BigNumber>;

    confirmNewHash(roundNumber: BigNumberish): Promise<BigNumber>;

    invalidateHash(round: BigNumberish, idx: BigNumberish): Promise<BigNumber>;

    respondToBinarySearchForChallenge(
      round: BigNumberish,
      idx: BigNumberish,
      jhIntermediateValue: Arrayish,
      siblings: Arrayish[]
    ): Promise<BigNumber>;

    confirmBinarySearchResult(
      round: BigNumberish,
      idx: BigNumberish,
      jhIntermediateValue: Arrayish,
      siblings: Arrayish[]
    ): Promise<BigNumber>;

    respondToChallenge(
      u: BigNumberish[],
      b32: Arrayish[],
      reputationSiblings: Arrayish[],
      agreeStateSiblings: Arrayish[],
      disagreeStateSiblings: Arrayish[],
      userOriginReputationSiblings: Arrayish[],
      childReputationSiblings: Arrayish[],
      adjacentReputationSiblings: Arrayish[]
    ): Promise<BigNumber>;

    confirmJustificationRootHash(
      round: BigNumberish,
      index: BigNumberish,
      siblings1: Arrayish[],
      siblings2: Arrayish[]
    ): Promise<BigNumber>;

    appendReputationUpdateLog(
      _user: string,
      _amount: BigNumberish,
      _skillId: BigNumberish,
      _colonyAddress: string,
      _nParents: BigNumberish,
      _nChildren: BigNumberish
    ): Promise<BigNumber>;

    getReputationUpdateLogLength(): Promise<BigNumber>;

    getReputationUpdateLogEntry(_id: BigNumberish): Promise<BigNumber>;

    rewardStakersWithReputation(
      stakers: string[],
      weights: BigNumberish[],
      metaColonyAddress: string,
      reward: BigNumberish,
      miningSkillId: BigNumberish
    ): Promise<BigNumber>;

    getReputationMiningWindowOpenTimestamp(): Promise<BigNumber>;

    initialise(tokenLocking: string, clnyToken: string): Promise<BigNumber>;

    getNUniqueSubmittedHashes(): Promise<BigNumber>;

    getNInvalidatedHashes(): Promise<BigNumber>;

    getMinStake(): Promise<BigNumber>;

    getMiningWindowDuration(): Promise<BigNumber>;

    getDecayConstant(): Promise<BigNumber>;

    getSubmissionUser(
      hash: Arrayish,
      nNodes: BigNumberish,
      jrh: Arrayish,
      index: BigNumberish
    ): Promise<BigNumber>;

    getNSubmissionsForHash(
      hash: Arrayish,
      nNodes: BigNumberish,
      jrh: Arrayish
    ): Promise<BigNumber>;
  };
}
